<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>third-party/codemirror-3.20/test/vim_test.js - Lich.sc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Lich.sc"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/allpassC.html">allpassC</a></li>
            
                <li><a href="../classes/allpassL.html">allpassL</a></li>
            
                <li><a href="../classes/allpassN.html">allpassN</a></li>
            
                <li><a href="../classes/bandpass.html">bandpass</a></li>
            
                <li><a href="../classes/blip.html">blip</a></li>
            
                <li><a href="../classes/brown.html">brown</a></li>
            
                <li><a href="../classes/clipNoise.html">clipNoise</a></li>
            
                <li><a href="../classes/combC.html">combC</a></li>
            
                <li><a href="../classes/combL.html">combL</a></li>
            
                <li><a href="../classes/combN.html">combN</a></li>
            
                <li><a href="../classes/crackle.html">crackle</a></li>
            
                <li><a href="../classes/cuspL.html">cuspL</a></li>
            
                <li><a href="../classes/cuspN.html">cuspN</a></li>
            
                <li><a href="../classes/dc.html">dc</a></li>
            
                <li><a href="../classes/delayC.html">delayC</a></li>
            
                <li><a href="../classes/delayL.html">delayL</a></li>
            
                <li><a href="../classes/delayN.html">delayN</a></li>
            
                <li><a href="../classes/dust.html">dust</a></li>
            
                <li><a href="../classes/env.html">env</a></li>
            
                <li><a href="../classes/env2.html">env2</a></li>
            
                <li><a href="../classes/formant.html">formant</a></li>
            
                <li><a href="../classes/gbmanL.html">gbmanL</a></li>
            
                <li><a href="../classes/gbmanN.html">gbmanN</a></li>
            
                <li><a href="../classes/gray.html">gray</a></li>
            
                <li><a href="../classes/highpass.html">highpass</a></li>
            
                <li><a href="../classes/impulse.html">impulse</a></li>
            
                <li><a href="../classes/lag.html">lag</a></li>
            
                <li><a href="../classes/lowpass.html">lowpass</a></li>
            
                <li><a href="../classes/noiseL.html">noiseL</a></li>
            
                <li><a href="../classes/noiseN.html">noiseN</a></li>
            
                <li><a href="../classes/noiseX.html">noiseX</a></li>
            
                <li><a href="../classes/out.html">out</a></li>
            
                <li><a href="../classes/perc.html">perc</a></li>
            
                <li><a href="../classes/perc2.html">perc2</a></li>
            
                <li><a href="../classes/pink.html">pink</a></li>
            
                <li><a href="../classes/pulse.html">pulse</a></li>
            
                <li><a href="../classes/saw.html">saw</a></li>
            
                <li><a href="../classes/sin.html">sin</a></li>
            
                <li><a href="../classes/square.html">square</a></li>
            
                <li><a href="../classes/tri.html">tri</a></li>
            
                <li><a href="../classes/white.html">white</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Chaos.html">Chaos</a></li>
            
                <li><a href="../modules/Delays.html">Delays</a></li>
            
                <li><a href="../modules/Envelopes.html">Envelopes</a></li>
            
                <li><a href="../modules/Filters.html">Filters</a></li>
            
                <li><a href="../modules/InputOutput.html">InputOutput</a></li>
            
                <li><a href="../modules/Lich.sc UGens.html">Lich.sc UGens</a></li>
            
                <li><a href="../modules/Noise.html">Noise</a></li>
            
                <li><a href="../modules/Oscillators.html">Oscillators</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: third-party/codemirror-3.20/test/vim_test.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var code = &#x27;&#x27; +
&#x27; wOrd1 (#%\n&#x27; +
&#x27; word3] \n&#x27; +
&#x27;aopop pop 0 1 2 3 4\n&#x27; +
&#x27; (a) [b] {c} \n&#x27; +
&#x27;int getchar(void) {\n&#x27; +
&#x27;  static char buf[BUFSIZ];\n&#x27; +
&#x27;  static char *bufp = buf;\n&#x27; +
&#x27;  if (n == 0) {  /* buffer is empty */\n&#x27; +
&#x27;    n = read(0, buf, sizeof buf);\n&#x27; +
&#x27;    bufp = buf;\n&#x27; +
&#x27;  }\n&#x27; +
&#x27;\n&#x27; +
&#x27;  return (--n &gt;= 0) ? (unsigned char) *bufp++ : EOF;\n&#x27; +
&#x27; \n&#x27; +
&#x27;}\n&#x27;;

var lines = (function() {
  lineText = code.split(&#x27;\n&#x27;);
  var ret = [];
  for (var i = 0; i &lt; lineText.length; i++) {
    ret[i] = {
      line: i,
      length: lineText[i].length,
      lineText: lineText[i],
      textStart: /^\s*/.exec(lineText[i])[0].length
    };
  }
  return ret;
})();
var endOfDocument = makeCursor(lines.length - 1,
    lines[lines.length - 1].length);
var wordLine = lines[0];
var bigWordLine = lines[1];
var charLine = lines[2];
var bracesLine = lines[3];
var seekBraceLine = lines[4];

var word1 = {
  start: { line: wordLine.line, ch: 1 },
  end: { line: wordLine.line, ch: 5 }
};
var word2 = {
  start: { line: wordLine.line, ch: word1.end.ch + 2 },
  end: { line: wordLine.line, ch: word1.end.ch + 4 }
};
var word3 = {
  start: { line: bigWordLine.line, ch: 1 },
  end: { line: bigWordLine.line, ch: 5 }
};
var bigWord1 = word1;
var bigWord2 = word2;
var bigWord3 = {
  start: { line: bigWordLine.line, ch: 1 },
  end: { line: bigWordLine.line, ch: 7 }
};
var bigWord4 = {
  start: { line: bigWordLine.line, ch: bigWord1.end.ch + 3 },
  end: { line: bigWordLine.line, ch: bigWord1.end.ch + 7 }
};

var oChars = [ { line: charLine.line, ch: 1 },
    { line: charLine.line, ch: 3 },
    { line: charLine.line, ch: 7 } ];
var pChars = [ { line: charLine.line, ch: 2 },
    { line: charLine.line, ch: 4 },
    { line: charLine.line, ch: 6 },
    { line: charLine.line, ch: 8 } ];
var numChars = [ { line: charLine.line, ch: 10 },
    { line: charLine.line, ch: 12 },
    { line: charLine.line, ch: 14 },
    { line: charLine.line, ch: 16 },
    { line: charLine.line, ch: 18 }];
var parens1 = {
  start: { line: bracesLine.line, ch: 1 },
  end: { line: bracesLine.line, ch: 3 }
};
var squares1 = {
  start: { line: bracesLine.line, ch: 5 },
  end: { line: bracesLine.line, ch: 7 }
};
var curlys1 = {
  start: { line: bracesLine.line, ch: 9 },
  end: { line: bracesLine.line, ch: 11 }
};
var seekOutside = {
  start: { line: seekBraceLine.line, ch: 1 },
  end: { line: seekBraceLine.line, ch: 16 }
};
var seekInside = {
  start: { line: seekBraceLine.line, ch: 14 },
  end: { line: seekBraceLine.line, ch: 11 }
};

function copyCursor(cur) {
  return { ch: cur.ch, line: cur.line };
}

function testVim(name, run, opts, expectedFail) {
  var vimOpts = {
    lineNumbers: true,
    vimMode: true,
    showCursorWhenSelecting: true,
    value: code
  };
  for (var prop in opts) {
    if (opts.hasOwnProperty(prop)) {
      vimOpts[prop] = opts[prop];
    }
  }
  return test(&#x27;vim_&#x27; + name, function() {
    var place = document.getElementById(&quot;testground&quot;);
    var cm = CodeMirror(place, vimOpts);
    var vim = CodeMirror.Vim.maybeInitVimState_(cm);

    function doKeysFn(cm) {
      return function(args) {
        if (args instanceof Array) {
          arguments = args;
        }
        for (var i = 0; i &lt; arguments.length; i++) {
          CodeMirror.Vim.handleKey(cm, arguments[i]);
        }
      }
    }
    function doInsertModeKeysFn(cm) {
      return function(args) {
        if (args instanceof Array) { arguments = args; }
        function executeHandler(handler) {
          if (typeof handler == &#x27;string&#x27;) {
            CodeMirror.commands[handler](cm);
          } else {
            handler(cm);
          }
          return true;
        }
        for (var i = 0; i &lt; arguments.length; i++) {
          var key = arguments[i];
          // Find key in keymap and handle.
          var handled = CodeMirror.lookupKey(key, [&#x27;vim-insert&#x27;], executeHandler);
          // Record for insert mode.
          if (handled === true &amp;&amp; cm.state.vim.insertMode &amp;&amp; arguments[i] != &#x27;Esc&#x27;) {
            var lastChange = CodeMirror.Vim.getVimGlobalState_().macroModeState.lastInsertModeChanges;
            if (lastChange) {
              lastChange.changes.push(new CodeMirror.Vim.InsertModeKey(key));
            }
          }
        }
      }
    }
    function doExFn(cm) {
      return function(command) {
        cm.openDialog = helpers.fakeOpenDialog(command);
        helpers.doKeys(&#x27;:&#x27;);
      }
    }
    function assertCursorAtFn(cm) {
      return function(line, ch) {
        var pos;
        if (ch == null &amp;&amp; typeof line.line == &#x27;number&#x27;) {
          pos = line;
        } else {
          pos = makeCursor(line, ch);
        }
        eqPos(pos, cm.getCursor());
      }
    }
    function fakeOpenDialog(result) {
      return function(text, callback) {
        return callback(result);
      }
    }
    var helpers = {
      doKeys: doKeysFn(cm),
      // Warning: Only emulates keymap events, not character insertions. Use
      // replaceRange to simulate character insertions.
      // Keys are in CodeMirror format, NOT vim format.
      doInsertModeKeys: doInsertModeKeysFn(cm),
      doEx: doExFn(cm),
      assertCursorAt: assertCursorAtFn(cm),
      fakeOpenDialog: fakeOpenDialog,
      getRegisterController: function() {
        return CodeMirror.Vim.getRegisterController();
      }
    }
    CodeMirror.Vim.resetVimGlobalState_();
    var successful = false;
    try {
      run(cm, vim, helpers);
      successful = true;
    } finally {
      if ((debug &amp;&amp; !successful) || verbose) {
        place.style.visibility = &quot;visible&quot;;
      } else {
        place.removeChild(cm.getWrapperElement());
      }
    }
  }, expectedFail);
};
testVim(&#x27;qq@q&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;q&#x27;, &#x27;q&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;q&#x27;);
  helpers.assertCursorAt(0,2);
  helpers.doKeys(&#x27;@&#x27;, &#x27;q&#x27;);
  helpers.assertCursorAt(0,4);
}, { value: &#x27;            &#x27;});
testVim(&#x27;@@&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;q&#x27;, &#x27;q&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;q&#x27;);
  helpers.assertCursorAt(0,2);
  helpers.doKeys(&#x27;@&#x27;, &#x27;q&#x27;);
  helpers.assertCursorAt(0,4);
  helpers.doKeys(&#x27;@&#x27;, &#x27;@&#x27;);
  helpers.assertCursorAt(0,6);
}, { value: &#x27;            &#x27;});
var jumplistScene = &#x27;&#x27;+
  &#x27;word\n&#x27;+
  &#x27;(word)\n&#x27;+
  &#x27;{word\n&#x27;+
  &#x27;word.\n&#x27;+
  &#x27;\n&#x27;+
  &#x27;word search\n&#x27;+
  &#x27;}word\n&#x27;+
  &#x27;word\n&#x27;+
  &#x27;word\n&#x27;;
function testJumplist(name, keys, endPos, startPos, dialog) {
  endPos = makeCursor(endPos[0], endPos[1]);
  startPos = makeCursor(startPos[0], startPos[1]);
  testVim(name, function(cm, vim, helpers) {
    CodeMirror.Vim.resetVimGlobalState_();
    if(dialog)cm.openDialog = helpers.fakeOpenDialog(&#x27;word&#x27;);
    cm.setCursor(startPos);
    helpers.doKeys.apply(null, keys);
    helpers.assertCursorAt(endPos);
  }, {value: jumplistScene});
};
testJumplist(&#x27;jumplist_H&#x27;, [&#x27;H&#x27;, &#x27;&lt;C-o&gt;&#x27;], [5,2], [5,2]);
testJumplist(&#x27;jumplist_M&#x27;, [&#x27;M&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,2], [2,2]);
testJumplist(&#x27;jumplist_L&#x27;, [&#x27;L&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,2], [2,2]);
testJumplist(&#x27;jumplist_[[&#x27;, [&#x27;[&#x27;, &#x27;[&#x27;, &#x27;&lt;C-o&gt;&#x27;], [5,2], [5,2]);
testJumplist(&#x27;jumplist_]]&#x27;, [&#x27;]&#x27;, &#x27;]&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,2], [2,2]);
testJumplist(&#x27;jumplist_G&#x27;, [&#x27;G&#x27;, &#x27;&lt;C-o&gt;&#x27;], [5,2], [5,2]);
testJumplist(&#x27;jumplist_gg&#x27;, [&#x27;g&#x27;, &#x27;g&#x27;, &#x27;&lt;C-o&gt;&#x27;], [5,2], [5,2]);
testJumplist(&#x27;jumplist_%&#x27;, [&#x27;%&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,5], [1,5]);
testJumplist(&#x27;jumplist_{&#x27;, [&#x27;{&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,5], [1,5]);
testJumplist(&#x27;jumplist_}&#x27;, [&#x27;}&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,5], [1,5]);
testJumplist(&#x27;jumplist_\&#x27;&#x27;, [&#x27;m&#x27;, &#x27;a&#x27;, &#x27;h&#x27;, &#x27;\&#x27;&#x27;, &#x27;a&#x27;, &#x27;h&#x27;, &#x27;&lt;C-i&gt;&#x27;], [1,5], [1,5]);
testJumplist(&#x27;jumplist_&#x60;&#x27;, [&#x27;m&#x27;, &#x27;a&#x27;, &#x27;h&#x27;, &#x27;&#x60;&#x27;, &#x27;a&#x27;, &#x27;h&#x27;, &#x27;&lt;C-i&gt;&#x27;], [1,5], [1,5]);
testJumplist(&#x27;jumplist_*_cachedCursor&#x27;, [&#x27;*&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,3], [1,3]);
testJumplist(&#x27;jumplist_#_cachedCursor&#x27;, [&#x27;#&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,3], [1,3]);
testJumplist(&#x27;jumplist_n&#x27;, [&#x27;#&#x27;, &#x27;n&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,1], [2,3]);
testJumplist(&#x27;jumplist_N&#x27;, [&#x27;#&#x27;, &#x27;N&#x27;, &#x27;&lt;C-o&gt;&#x27;], [1,1], [2,3]);
testJumplist(&#x27;jumplist_repeat_&lt;c-o&gt;&#x27;, [&#x27;*&#x27;, &#x27;*&#x27;, &#x27;*&#x27;, &#x27;3&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,3], [2,3]);
testJumplist(&#x27;jumplist_repeat_&lt;c-i&gt;&#x27;, [&#x27;*&#x27;, &#x27;*&#x27;, &#x27;*&#x27;, &#x27;3&#x27;, &#x27;&lt;C-o&gt;&#x27;, &#x27;2&#x27;, &#x27;&lt;C-i&gt;&#x27;], [5,0], [2,3]);
testJumplist(&#x27;jumplist_repeated_motion&#x27;, [&#x27;3&#x27;, &#x27;*&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,3], [2,3]);
testJumplist(&#x27;jumplist_/&#x27;, [&#x27;/&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,3], [2,3], &#x27;dialog&#x27;);
testJumplist(&#x27;jumplist_?&#x27;, [&#x27;?&#x27;, &#x27;&lt;C-o&gt;&#x27;], [2,3], [2,3], &#x27;dialog&#x27;);
testJumplist(&#x27;jumplist_skip_delted_mark&lt;c-o&gt;&#x27;,
             [&#x27;*&#x27;, &#x27;n&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;d&#x27;, &#x27;k&#x27;, &#x27;&lt;C-o&gt;&#x27;, &#x27;&lt;C-o&gt;&#x27;, &#x27;&lt;C-o&gt;&#x27;],
             [0,2], [0,2]);
testJumplist(&#x27;jumplist_skip_delted_mark&lt;c-i&gt;&#x27;,
             [&#x27;*&#x27;, &#x27;n&#x27;, &#x27;n&#x27;, &#x27;k&#x27;, &#x27;d&#x27;, &#x27;k&#x27;, &#x27;&lt;C-o&gt;&#x27;, &#x27;&lt;C-i&gt;&#x27;, &#x27;&lt;C-i&gt;&#x27;],
             [1,0], [0,2]);
/**
 * @param name Name of the test
 * @param keys An array of keys or a string with a single key to simulate.
 * @param endPos The expected end position of the cursor.
 * @param startPos The position the cursor should start at, defaults to 0, 0.
 */
function testMotion(name, keys, endPos, startPos) {
  testVim(name, function(cm, vim, helpers) {
    if (!startPos) {
      startPos = { line: 0, ch: 0 };
    }
    cm.setCursor(startPos);
    helpers.doKeys(keys);
    helpers.assertCursorAt(endPos);
  });
};

function makeCursor(line, ch) {
  return { line: line, ch: ch };
};

function offsetCursor(cur, offsetLine, offsetCh) {
  return { line: cur.line + offsetLine, ch: cur.ch + offsetCh };
};

// Motion tests
testMotion(&#x27;|&#x27;, &#x27;|&#x27;, makeCursor(0, 0), makeCursor(0,4));
testMotion(&#x27;|_repeat&#x27;, [&#x27;3&#x27;, &#x27;|&#x27;], makeCursor(0, 2), makeCursor(0,4));
testMotion(&#x27;h&#x27;, &#x27;h&#x27;, makeCursor(0, 0), word1.start);
testMotion(&#x27;h_repeat&#x27;, [&#x27;3&#x27;, &#x27;h&#x27;], offsetCursor(word1.end, 0, -3), word1.end);
testMotion(&#x27;l&#x27;, &#x27;l&#x27;, makeCursor(0, 1));
testMotion(&#x27;l_repeat&#x27;, [&#x27;2&#x27;, &#x27;l&#x27;], makeCursor(0, 2));
testMotion(&#x27;j&#x27;, &#x27;j&#x27;, offsetCursor(word1.end, 1, 0), word1.end);
testMotion(&#x27;j_repeat&#x27;, [&#x27;2&#x27;, &#x27;j&#x27;], offsetCursor(word1.end, 2, 0), word1.end);
testMotion(&#x27;j_repeat_clip&#x27;, [&#x27;1000&#x27;, &#x27;j&#x27;], endOfDocument);
testMotion(&#x27;k&#x27;, &#x27;k&#x27;, offsetCursor(word3.end, -1, 0), word3.end);
testMotion(&#x27;k_repeat&#x27;, [&#x27;2&#x27;, &#x27;k&#x27;], makeCursor(0, 4), makeCursor(2, 4));
testMotion(&#x27;k_repeat_clip&#x27;, [&#x27;1000&#x27;, &#x27;k&#x27;], makeCursor(0, 4), makeCursor(2, 4));
testMotion(&#x27;w&#x27;, &#x27;w&#x27;, word1.start);
testMotion(&#x27;w_multiple_newlines_no_space&#x27;, &#x27;w&#x27;, makeCursor(12, 2), makeCursor(11, 2));
testMotion(&#x27;w_multiple_newlines_with_space&#x27;, &#x27;w&#x27;, makeCursor(14, 0), makeCursor(12, 51));
testMotion(&#x27;w_repeat&#x27;, [&#x27;2&#x27;, &#x27;w&#x27;], word2.start);
testMotion(&#x27;w_wrap&#x27;, [&#x27;w&#x27;], word3.start, word2.start);
testMotion(&#x27;w_endOfDocument&#x27;, &#x27;w&#x27;, endOfDocument, endOfDocument);
testMotion(&#x27;w_start_to_end&#x27;, [&#x27;1000&#x27;, &#x27;w&#x27;], endOfDocument, makeCursor(0, 0));
testMotion(&#x27;W&#x27;, &#x27;W&#x27;, bigWord1.start);
testMotion(&#x27;W_repeat&#x27;, [&#x27;2&#x27;, &#x27;W&#x27;], bigWord3.start, bigWord1.start);
testMotion(&#x27;e&#x27;, &#x27;e&#x27;, word1.end);
testMotion(&#x27;e_repeat&#x27;, [&#x27;2&#x27;, &#x27;e&#x27;], word2.end);
testMotion(&#x27;e_wrap&#x27;, &#x27;e&#x27;, word3.end, word2.end);
testMotion(&#x27;e_endOfDocument&#x27;, &#x27;e&#x27;, endOfDocument, endOfDocument);
testMotion(&#x27;e_start_to_end&#x27;, [&#x27;1000&#x27;, &#x27;e&#x27;], endOfDocument, makeCursor(0, 0));
testMotion(&#x27;b&#x27;, &#x27;b&#x27;, word3.start, word3.end);
testMotion(&#x27;b_repeat&#x27;, [&#x27;2&#x27;, &#x27;b&#x27;], word2.start, word3.end);
testMotion(&#x27;b_wrap&#x27;, &#x27;b&#x27;, word2.start, word3.start);
testMotion(&#x27;b_startOfDocument&#x27;, &#x27;b&#x27;, makeCursor(0, 0), makeCursor(0, 0));
testMotion(&#x27;b_end_to_start&#x27;, [&#x27;1000&#x27;, &#x27;b&#x27;], makeCursor(0, 0), endOfDocument);
testMotion(&#x27;ge&#x27;, [&#x27;g&#x27;, &#x27;e&#x27;], word2.end, word3.end);
testMotion(&#x27;ge_repeat&#x27;, [&#x27;2&#x27;, &#x27;g&#x27;, &#x27;e&#x27;], word1.end, word3.start);
testMotion(&#x27;ge_wrap&#x27;, [&#x27;g&#x27;, &#x27;e&#x27;], word2.end, word3.start);
testMotion(&#x27;ge_startOfDocument&#x27;, [&#x27;g&#x27;, &#x27;e&#x27;], makeCursor(0, 0),
    makeCursor(0, 0));
testMotion(&#x27;ge_end_to_start&#x27;, [&#x27;1000&#x27;, &#x27;g&#x27;, &#x27;e&#x27;], makeCursor(0, 0), endOfDocument);
testMotion(&#x27;gg&#x27;, [&#x27;g&#x27;, &#x27;g&#x27;], makeCursor(lines[0].line, lines[0].textStart),
    makeCursor(3, 1));
testMotion(&#x27;gg_repeat&#x27;, [&#x27;3&#x27;, &#x27;g&#x27;, &#x27;g&#x27;],
    makeCursor(lines[2].line, lines[2].textStart));
testMotion(&#x27;G&#x27;, &#x27;G&#x27;,
    makeCursor(lines[lines.length - 1].line, lines[lines.length - 1].textStart),
    makeCursor(3, 1));
testMotion(&#x27;G_repeat&#x27;, [&#x27;3&#x27;, &#x27;G&#x27;], makeCursor(lines[2].line,
    lines[2].textStart));
// TODO: Make the test code long enough to test Ctrl-F and Ctrl-B.
testMotion(&#x27;0&#x27;, &#x27;0&#x27;, makeCursor(0, 0), makeCursor(0, 8));
testMotion(&#x27;^&#x27;, &#x27;^&#x27;, makeCursor(0, lines[0].textStart), makeCursor(0, 8));
testMotion(&#x27;+&#x27;, &#x27;+&#x27;, makeCursor(1, lines[1].textStart), makeCursor(0, 8));
testMotion(&#x27;-&#x27;, &#x27;-&#x27;, makeCursor(0, lines[0].textStart), makeCursor(1, 4));
testMotion(&#x27;_&#x27;, [&#x27;6&#x27;,&#x27;_&#x27;], makeCursor(5, lines[5].textStart), makeCursor(0, 8));
testMotion(&#x27;$&#x27;, &#x27;$&#x27;, makeCursor(0, lines[0].length - 1), makeCursor(0, 1));
testMotion(&#x27;$_repeat&#x27;, [&#x27;2&#x27;, &#x27;$&#x27;], makeCursor(1, lines[1].length - 1),
    makeCursor(0, 3));
testMotion(&#x27;f&#x27;, [&#x27;f&#x27;, &#x27;p&#x27;], pChars[0], makeCursor(charLine.line, 0));
testMotion(&#x27;f_repeat&#x27;, [&#x27;2&#x27;, &#x27;f&#x27;, &#x27;p&#x27;], pChars[2], pChars[0]);
testMotion(&#x27;f_num&#x27;, [&#x27;f&#x27;, &#x27;2&#x27;], numChars[2], makeCursor(charLine.line, 0));
testMotion(&#x27;t&#x27;, [&#x27;t&#x27;,&#x27;p&#x27;], offsetCursor(pChars[0], 0, -1),
    makeCursor(charLine.line, 0));
testMotion(&#x27;t_repeat&#x27;, [&#x27;2&#x27;, &#x27;t&#x27;, &#x27;p&#x27;], offsetCursor(pChars[2], 0, -1),
    pChars[0]);
testMotion(&#x27;F&#x27;, [&#x27;F&#x27;, &#x27;p&#x27;], pChars[0], pChars[1]);
testMotion(&#x27;F_repeat&#x27;, [&#x27;2&#x27;, &#x27;F&#x27;, &#x27;p&#x27;], pChars[0], pChars[2]);
testMotion(&#x27;T&#x27;, [&#x27;T&#x27;, &#x27;p&#x27;], offsetCursor(pChars[0], 0, 1), pChars[1]);
testMotion(&#x27;T_repeat&#x27;, [&#x27;2&#x27;, &#x27;T&#x27;, &#x27;p&#x27;], offsetCursor(pChars[0], 0, 1), pChars[2]);
testMotion(&#x27;%_parens&#x27;, [&#x27;%&#x27;], parens1.end, parens1.start);
testMotion(&#x27;%_squares&#x27;, [&#x27;%&#x27;], squares1.end, squares1.start);
testMotion(&#x27;%_braces&#x27;, [&#x27;%&#x27;], curlys1.end, curlys1.start);
testMotion(&#x27;%_seek_outside&#x27;, [&#x27;%&#x27;], seekOutside.end, seekOutside.start);
testMotion(&#x27;%_seek_inside&#x27;, [&#x27;%&#x27;], seekInside.end, seekInside.start);
testVim(&#x27;%_seek_skip&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0,0);
  helpers.doKeys([&#x27;%&#x27;]);
  helpers.assertCursorAt(0,9);
}, {value:&#x27;01234&quot;(&quot;()&#x27;});
testVim(&#x27;%_skip_string&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0,0);
  helpers.doKeys([&#x27;%&#x27;]);
  helpers.assertCursorAt(0,4);
  cm.setCursor(0,2);
  helpers.doKeys([&#x27;%&#x27;]);
  helpers.assertCursorAt(0,0);
}, {value:&#x27;(&quot;)&quot;)&#x27;});
(&#x27;)&#x27;)
testVim(&#x27;%_skip_comment&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0,0);
  helpers.doKeys([&#x27;%&#x27;]);
  helpers.assertCursorAt(0,6);
  cm.setCursor(0,3);
  helpers.doKeys([&#x27;%&#x27;]);
  helpers.assertCursorAt(0,0);
}, {value:&#x27;(/*)*/)&#x27;});
// Make sure that moving down after going to the end of a line always leaves you
// at the end of a line, but preserves the offset in other cases
testVim(&#x27;Changing lines after Eol operation&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0,0);
  helpers.doKeys([&#x27;$&#x27;]);
  helpers.doKeys([&#x27;j&#x27;]);
  // After moving to Eol and then down, we should be at Eol of line 2
  helpers.assertCursorAt({ line: 1, ch: lines[1].length - 1 });
  helpers.doKeys([&#x27;j&#x27;]);
  // After moving down, we should be at Eol of line 3
  helpers.assertCursorAt({ line: 2, ch: lines[2].length - 1 });
  helpers.doKeys([&#x27;h&#x27;]);
  helpers.doKeys([&#x27;j&#x27;]);
  // After moving back one space and then down, since line 4 is shorter than line 2, we should
  // be at Eol of line 2 - 1
  helpers.assertCursorAt({ line: 3, ch: lines[3].length - 1 });
  helpers.doKeys([&#x27;j&#x27;]);
  helpers.doKeys([&#x27;j&#x27;]);
  // After moving down again, since line 3 has enough characters, we should be back to the
  // same place we were at on line 1
  helpers.assertCursorAt({ line: 5, ch: lines[2].length - 2 });
});
//making sure gj and gk recover from clipping
testVim(&#x27;gj_gk_clipping&#x27;, function(cm,vim,helpers){
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;g&#x27;,&#x27;j&#x27;,&#x27;g&#x27;,&#x27;j&#x27;);
  helpers.assertCursorAt(2, 1);
  helpers.doKeys(&#x27;g&#x27;,&#x27;k&#x27;,&#x27;g&#x27;,&#x27;k&#x27;);
  helpers.assertCursorAt(0, 1);
},{value: &#x27;line 1\n\nline 2&#x27;});
//testing a mix of j/k and gj/gk
testVim(&#x27;j_k_and_gj_gk&#x27;, function(cm,vim,helpers){
  cm.setSize(120);
  cm.setCursor(0, 0);
  //go to the last character on the first line
  helpers.doKeys(&#x27;$&#x27;);
  //move up/down on the column within the wrapped line
  //side-effect: cursor is not locked to eol anymore
  helpers.doKeys(&#x27;g&#x27;,&#x27;k&#x27;);
  var cur=cm.getCursor();
  eq(cur.line,0);
  is((cur.ch&lt;176),&#x27;gk didn\&#x27;t move cursor back (1)&#x27;);
  helpers.doKeys(&#x27;g&#x27;,&#x27;j&#x27;);
  helpers.assertCursorAt(0, 176);
  //should move to character 177 on line 2 (j/k preserve character index within line)
  helpers.doKeys(&#x27;j&#x27;);
  //due to different line wrapping, the cursor can be on a different screen-x now
  //gj and gk preserve screen-x on movement, much like moveV
  helpers.doKeys(&#x27;3&#x27;,&#x27;g&#x27;,&#x27;k&#x27;);
  cur=cm.getCursor();
  eq(cur.line,1);
  is((cur.ch&lt;176),&#x27;gk didn\&#x27;t move cursor back (2)&#x27;);
  helpers.doKeys(&#x27;g&#x27;,&#x27;j&#x27;,&#x27;2&#x27;,&#x27;g&#x27;,&#x27;j&#x27;);
  //should return to the same character-index
  helpers.doKeys(&#x27;k&#x27;);
  helpers.assertCursorAt(0, 176);
},{ lineWrapping:true, value: &#x27;This line is intentially long to test movement of gj and gk over wrapped lines. I will start on the end of this line, then make a step up and back to set the origin for j and k.\nThis line is supposed to be even longer than the previous. I will jump here and make another wiggle with gj and gk, before I jump back to the line above. Both wiggles should not change my cursor\&#x27;s target character but both j/k and gj/gk change each other\&#x27;s reference position.&#x27;});
testVim(&#x27;gj_gk&#x27;, function(cm, vim, helpers) {
  if (phantom) return;
  cm.setSize(120);
  // Test top of document edge case.
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;g&#x27;, &#x27;j&#x27;);
  helpers.doKeys(&#x27;10&#x27;, &#x27;g&#x27;, &#x27;k&#x27;);
  helpers.assertCursorAt(0, 4);

  // Test moving down preserves column position.
  helpers.doKeys(&#x27;g&#x27;, &#x27;j&#x27;);
  var pos1 = cm.getCursor();
  var expectedPos2 = { line: 0, ch: (pos1.ch - 4) * 2 + 4};
  helpers.doKeys(&#x27;g&#x27;, &#x27;j&#x27;);
  helpers.assertCursorAt(expectedPos2);

  // Move to the last character
  cm.setCursor(0, 0);
  // Move left to reset HSPos
  helpers.doKeys(&#x27;h&#x27;);
  // Test bottom of document edge case.
  helpers.doKeys(&#x27;100&#x27;, &#x27;g&#x27;, &#x27;j&#x27;);
  var endingPos = cm.getCursor();
  is(endingPos != 0, &#x27;gj should not be on wrapped line 0&#x27;);
  var topLeftCharCoords = cm.charCoords(makeCursor(0, 0));
  var endingCharCoords = cm.charCoords(endingPos);
  is(topLeftCharCoords.left == endingCharCoords.left, &#x27;gj should end up on column 0&#x27;);
},{ lineNumbers: false, lineWrapping:true, value: &#x27;Thislineisintentiallylongtotestmovementofgjandgkoverwrappedlines.&#x27; });
testVim(&#x27;}&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;}&#x27;);
  helpers.assertCursorAt(1, 0);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;}&#x27;);
  helpers.assertCursorAt(4, 0);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;6&#x27;, &#x27;}&#x27;);
  helpers.assertCursorAt(5, 0);
}, { value: &#x27;a\n\nb\nc\n\nd&#x27; });
testVim(&#x27;{&#x27;, function(cm, vim, helpers) {
  cm.setCursor(5, 0);
  helpers.doKeys(&#x27;{&#x27;);
  helpers.assertCursorAt(4, 0);
  cm.setCursor(5, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;{&#x27;);
  helpers.assertCursorAt(1, 0);
  cm.setCursor(5, 0);
  helpers.doKeys(&#x27;6&#x27;, &#x27;{&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;a\n\nb\nc\n\nd&#x27; });

// Operator tests
testVim(&#x27;dl&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 0);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;l&#x27;);
  eq(&#x27;word1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; &#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dl_eol&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 6);
  helpers.doKeys(&#x27;d&#x27;, &#x27;l&#x27;);
  eq(&#x27; word1&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; &#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 5);
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dl_repeat&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 0);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;2&#x27;, &#x27;d&#x27;, &#x27;l&#x27;);
  eq(&#x27;ord1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; w&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dh&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;h&#x27;);
  eq(&#x27; wrd1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;o&#x27;, register.text);
  is(!register.linewise);
  eqPos(offsetCursor(curStart, 0 , -1), cm.getCursor());
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dj&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;j&#x27;);
  eq(&#x27; word3&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; word1\nword2\n&#x27;, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, 1);
}, { value: &#x27; word1\nword2\n word3&#x27; });
testVim(&#x27;dj_end_of_document&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;j&#x27;);
  eq(&#x27; word1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 3);
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dk&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(1, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;k&#x27;);
  eq(&#x27; word3&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; word1\nword2\n&#x27;, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, 1);
}, { value: &#x27; word1\nword2\n word3&#x27; });
testVim(&#x27;dk_start_of_document&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;k&#x27;);
  eq(&#x27; word1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 3);
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dw_space&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 0);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;word1 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27; &#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dw_word&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 1);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27; word2&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1 &#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1 word2&#x27; });
testVim(&#x27;dw_only_word&#x27;, function(cm, vim, helpers) {
  // Test that if there is only 1 word left, dw deletes till the end of the
  // line.
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27; &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1 &#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;dw_eol&#x27;, function(cm, vim, helpers) {
  // Assert that dw does not delete the newline if last word to delete is at end
  // of line.
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27; \nword2&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27; word1\nword2&#x27; });
testVim(&#x27;dw_eol_with_multiple_newlines&#x27;, function(cm, vim, helpers) {
  // Assert that dw does not delete the newline if last word to delete is at end
  // of line and it is followed by multiple newlines.
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27; \n\nword2&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27; word1\n\nword2&#x27; });
testVim(&#x27;dw_empty_line_followed_by_whitespace&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;  \nword&#x27;, cm.getValue());
}, { value: &#x27;\n  \nword&#x27; });
testVim(&#x27;dw_empty_line_followed_by_word&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;word&#x27;, cm.getValue());
}, { value: &#x27;\nword&#x27; });
testVim(&#x27;dw_empty_line_followed_by_empty_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;\n&#x27;, cm.getValue());
}, { value: &#x27;\n\n&#x27; });
testVim(&#x27;dw_whitespace_followed_by_whitespace&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;\n   \n&#x27;, cm.getValue());
}, { value: &#x27;  \n   \n&#x27; });
testVim(&#x27;dw_whitespace_followed_by_empty_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;\n\n&#x27;, cm.getValue());
}, { value: &#x27;  \n\n&#x27; });
testVim(&#x27;dw_word_whitespace_word&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;\n   \nword2&#x27;, cm.getValue());
}, { value: &#x27;word1\n   \nword2&#x27;})
testVim(&#x27;dw_end_of_document&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;d&#x27;, &#x27;w&#x27;);
  eq(&#x27;\nab&#x27;, cm.getValue());
}, { value: &#x27;\nabc&#x27; });
testVim(&#x27;dw_repeat&#x27;, function(cm, vim, helpers) {
  // Assert that dw does delete newline if it should go to the next line, and
  // that repeat works properly.
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;d&#x27;, &#x27;2&#x27;, &#x27;w&#x27;);
  eq(&#x27; &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1\nword2&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27; word1\nword2&#x27; });
testVim(&#x27;de_word_start_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;e&#x27;);
  eq(&#x27;\n\n&#x27;, cm.getValue());
}, { value: &#x27;word\n\n&#x27; });
testVim(&#x27;de_word_end_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;d&#x27;, &#x27;e&#x27;);
  eq(&#x27;wor&#x27;, cm.getValue());
}, { value: &#x27;word\n\n\n&#x27; });
testVim(&#x27;de_whitespace_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;e&#x27;);
  eq(&#x27;&#x27;, cm.getValue());
}, { value: &#x27;   \n\n\n&#x27; });
testVim(&#x27;de_end_of_document&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;d&#x27;, &#x27;e&#x27;);
  eq(&#x27;\nab&#x27;, cm.getValue());
}, { value: &#x27;\nabc&#x27; });
testVim(&#x27;db_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27;\n\n&#x27;, cm.getValue());
}, { value: &#x27;\n\n\n&#x27; });
testVim(&#x27;db_word_start_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27;\nword&#x27;, cm.getValue());
}, { value: &#x27;\n\nword&#x27; });
testVim(&#x27;db_word_end_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 3);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27;\n\nd&#x27;, cm.getValue());
}, { value: &#x27;\n\nword&#x27; });
testVim(&#x27;db_whitespace_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27;&#x27;, cm.getValue());
}, { value: &#x27;\n   \n&#x27; });
testVim(&#x27;db_start_of_document&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27;abc\n&#x27;, cm.getValue());
}, { value: &#x27;abc\n&#x27; });
testVim(&#x27;dge_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;g&#x27;, &#x27;e&#x27;);
  // Note: In real VIM the result should be &#x27;&#x27;, but it&#x27;s not quite consistent,
  // since 2 newlines are deleted. But in the similar case of word\n\n, only
  // 1 newline is deleted. We&#x27;ll diverge from VIM&#x27;s behavior since it&#x27;s much
  // easier this way.
  eq(&#x27;\n&#x27;, cm.getValue());
}, { value: &#x27;\n\n&#x27; });
testVim(&#x27;dge_word_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;g&#x27;, &#x27;e&#x27;);
  eq(&#x27;wor\n&#x27;, cm.getValue());
}, { value: &#x27;word\n\n&#x27;});
testVim(&#x27;dge_whitespace_and_empty_lines&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;g&#x27;, &#x27;e&#x27;);
  eq(&#x27;&#x27;, cm.getValue());
}, { value: &#x27;\n  \n&#x27; });
testVim(&#x27;dge_start_of_document&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;g&#x27;, &#x27;e&#x27;);
  eq(&#x27;bc\n&#x27;, cm.getValue());
}, { value: &#x27;abc\n&#x27; });
testVim(&#x27;d_inclusive&#x27;, function(cm, vim, helpers) {
  // Assert that when inclusive is set, the character the cursor is on gets
  // deleted too.
  var curStart = makeCursor(0, 1);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;d&#x27;, &#x27;e&#x27;);
  eq(&#x27;  &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1 &#x27; });
testVim(&#x27;d_reverse&#x27;, function(cm, vim, helpers) {
  // Test that deleting in reverse works.
  cm.setCursor(1, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;b&#x27;);
  eq(&#x27; word2 &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1\n&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 1);
}, { value: &#x27; word1\nword2 &#x27; });
testVim(&#x27;dd&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 1, ch: 0 });
  var expectedLineCount = cm.lineCount() - 1;
  helpers.doKeys(&#x27;d&#x27;, &#x27;d&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, lines[1].textStart);
});
testVim(&#x27;dd_prefix_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 2, ch: 0 });
  var expectedLineCount = cm.lineCount() - 2;
  helpers.doKeys(&#x27;2&#x27;, &#x27;d&#x27;, &#x27;d&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, lines[2].textStart);
});
testVim(&#x27;dd_motion_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 2, ch: 0 });
  var expectedLineCount = cm.lineCount() - 2;
  helpers.doKeys(&#x27;d&#x27;, &#x27;2&#x27;, &#x27;d&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, lines[2].textStart);
});
testVim(&#x27;dd_multiply_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 6, ch: 0 });
  var expectedLineCount = cm.lineCount() - 6;
  helpers.doKeys(&#x27;2&#x27;, &#x27;d&#x27;, &#x27;3&#x27;, &#x27;d&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  helpers.assertCursorAt(0, lines[6].textStart);
});
testVim(&#x27;dd_lastline&#x27;, function(cm, vim, helpers) {
  cm.setCursor(cm.lineCount(), 0);
  var expectedLineCount = cm.lineCount() - 1;
  helpers.doKeys(&#x27;d&#x27;, &#x27;d&#x27;);
  eq(expectedLineCount, cm.lineCount());
  helpers.assertCursorAt(cm.lineCount() - 1, 0);
});
// Yank commands should behave the exact same as d commands, expect that nothing
// gets deleted.
testVim(&#x27;yw_repeat&#x27;, function(cm, vim, helpers) {
  // Assert that yw does yank newline if it should go to the next line, and
  // that repeat works properly.
  var curStart = makeCursor(0, 1);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;y&#x27;, &#x27;2&#x27;, &#x27;w&#x27;);
  eq(&#x27; word1\nword2&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1\nword2&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1\nword2&#x27; });
testVim(&#x27;yy_multiply_repeat&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 6, ch: 0 });
  var expectedLineCount = cm.lineCount();
  helpers.doKeys(&#x27;2&#x27;, &#x27;y&#x27;, &#x27;3&#x27;, &#x27;y&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  eqPos(curStart, cm.getCursor());
});
// Change commands behave like d commands except that it also enters insert
// mode. In addition, when the change is linewise, an additional newline is
// inserted so that insert mode starts on that line.
testVim(&#x27;cw&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;2&#x27;, &#x27;w&#x27;);
  eq(&#x27; word3&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;word1 word2 word3&#x27;});
testVim(&#x27;cw_repeat&#x27;, function(cm, vim, helpers) {
  // Assert that cw does delete newline if it should go to the next line, and
  // that repeat works properly.
  var curStart = makeCursor(0, 1);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;c&#x27;, &#x27;2&#x27;, &#x27;w&#x27;);
  eq(&#x27; &#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;word1\nword2&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
}, { value: &#x27; word1\nword2&#x27; });
testVim(&#x27;cc_multiply_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedBuffer = cm.getRange({ line: 0, ch: 0 },
    { line: 6, ch: 0 });
  var expectedLineCount = cm.lineCount() - 5;
  helpers.doKeys(&#x27;2&#x27;, &#x27;c&#x27;, &#x27;3&#x27;, &#x27;c&#x27;);
  eq(expectedLineCount, cm.lineCount());
  var register = helpers.getRegisterController().getRegister();
  eq(expectedBuffer, register.text);
  is(register.linewise);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;cc_append&#x27;, function(cm, vim, helpers) {
  var expectedLineCount = cm.lineCount();
  cm.setCursor(cm.lastLine(), 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;c&#x27;);
  eq(expectedLineCount, cm.lineCount());
});
// Swapcase commands edit in place and do not modify registers.
testVim(&#x27;g~w_repeat&#x27;, function(cm, vim, helpers) {
  // Assert that dw does delete newline if it should go to the next line, and
  // that repeat works properly.
  var curStart = makeCursor(0, 1);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;g&#x27;, &#x27;~&#x27;, &#x27;2&#x27;, &#x27;w&#x27;);
  eq(&#x27; WORD1\nWORD2&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1\nword2&#x27; });
testVim(&#x27;g~g~&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  var expectedLineCount = cm.lineCount();
  var expectedValue = cm.getValue().toUpperCase();
  helpers.doKeys(&#x27;2&#x27;, &#x27;g&#x27;, &#x27;~&#x27;, &#x27;3&#x27;, &#x27;g&#x27;, &#x27;~&#x27;);
  eq(expectedValue, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
}, { value: &#x27; word1\nword2\nword3\nword4\nword5\nword6&#x27; });
testVim(&#x27;&gt;{motion}&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 3);
  var expectedLineCount = cm.lineCount();
  var expectedValue = &#x27;   word1\n  word2\nword3 &#x27;;
  helpers.doKeys(&#x27;&gt;&#x27;, &#x27;k&#x27;);
  eq(expectedValue, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 3);
}, { value: &#x27; word1\nword2\nword3 &#x27;, indentUnit: 2 });
testVim(&#x27;&gt;&gt;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedLineCount = cm.lineCount();
  var expectedValue = &#x27;   word1\n  word2\nword3 &#x27;;
  helpers.doKeys(&#x27;2&#x27;, &#x27;&gt;&#x27;, &#x27;&gt;&#x27;);
  eq(expectedValue, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 3);
}, { value: &#x27; word1\nword2\nword3 &#x27;, indentUnit: 2 });
testVim(&#x27;&lt;{motion}&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 3);
  var expectedLineCount = cm.lineCount();
  var expectedValue = &#x27; word1\nword2\nword3 &#x27;;
  helpers.doKeys(&#x27;&lt;&#x27;, &#x27;k&#x27;);
  eq(expectedValue, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;   word1\n  word2\nword3 &#x27;, indentUnit: 2 });
testVim(&#x27;&lt;&lt;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  var expectedLineCount = cm.lineCount();
  var expectedValue = &#x27; word1\nword2\nword3 &#x27;;
  helpers.doKeys(&#x27;2&#x27;, &#x27;&lt;&#x27;, &#x27;&lt;&#x27;);
  eq(expectedValue, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;   word1\n  word2\nword3 &#x27;, indentUnit: 2 });

// Edit tests
function testEdit(name, before, pos, edit, after) {
  return testVim(name, function(cm, vim, helpers) {
             cm.setCursor(0, before.search(pos));
             helpers.doKeys.apply(this, edit.split(&#x27;&#x27;));
             eq(after, cm.getValue());
           }, {value: before});
}

// These Delete tests effectively cover word-wise Change, Visual &amp; Yank.
// Tabs are used as differentiated whitespace to catch edge cases.
// Normal word:
testEdit(&#x27;diw_mid_spc&#x27;, &#x27;foo \tbAr\t baz&#x27;, /A/, &#x27;diw&#x27;, &#x27;foo \t\t baz&#x27;);
testEdit(&#x27;daw_mid_spc&#x27;, &#x27;foo \tbAr\t baz&#x27;, /A/, &#x27;daw&#x27;, &#x27;foo \tbaz&#x27;);
testEdit(&#x27;diw_mid_punct&#x27;, &#x27;foo \tbAr.\t baz&#x27;, /A/, &#x27;diw&#x27;, &#x27;foo \t.\t baz&#x27;);
testEdit(&#x27;daw_mid_punct&#x27;, &#x27;foo \tbAr.\t baz&#x27;, /A/, &#x27;daw&#x27;, &#x27;foo.\t baz&#x27;);
testEdit(&#x27;diw_mid_punct2&#x27;, &#x27;foo \t,bAr.\t baz&#x27;, /A/, &#x27;diw&#x27;, &#x27;foo \t,.\t baz&#x27;);
testEdit(&#x27;daw_mid_punct2&#x27;, &#x27;foo \t,bAr.\t baz&#x27;, /A/, &#x27;daw&#x27;, &#x27;foo \t,.\t baz&#x27;);
testEdit(&#x27;diw_start_spc&#x27;, &#x27;bAr \tbaz&#x27;, /A/, &#x27;diw&#x27;, &#x27; \tbaz&#x27;);
testEdit(&#x27;daw_start_spc&#x27;, &#x27;bAr \tbaz&#x27;, /A/, &#x27;daw&#x27;, &#x27;baz&#x27;);
testEdit(&#x27;diw_start_punct&#x27;, &#x27;bAr. \tbaz&#x27;, /A/, &#x27;diw&#x27;, &#x27;. \tbaz&#x27;);
testEdit(&#x27;daw_start_punct&#x27;, &#x27;bAr. \tbaz&#x27;, /A/, &#x27;daw&#x27;, &#x27;. \tbaz&#x27;);
testEdit(&#x27;diw_end_spc&#x27;, &#x27;foo \tbAr&#x27;, /A/, &#x27;diw&#x27;, &#x27;foo \t&#x27;);
testEdit(&#x27;daw_end_spc&#x27;, &#x27;foo \tbAr&#x27;, /A/, &#x27;daw&#x27;, &#x27;foo&#x27;);
testEdit(&#x27;diw_end_punct&#x27;, &#x27;foo \tbAr.&#x27;, /A/, &#x27;diw&#x27;, &#x27;foo \t.&#x27;);
testEdit(&#x27;daw_end_punct&#x27;, &#x27;foo \tbAr.&#x27;, /A/, &#x27;daw&#x27;, &#x27;foo.&#x27;);
// Big word:
testEdit(&#x27;diW_mid_spc&#x27;, &#x27;foo \tbAr\t baz&#x27;, /A/, &#x27;diW&#x27;, &#x27;foo \t\t baz&#x27;);
testEdit(&#x27;daW_mid_spc&#x27;, &#x27;foo \tbAr\t baz&#x27;, /A/, &#x27;daW&#x27;, &#x27;foo \tbaz&#x27;);
testEdit(&#x27;diW_mid_punct&#x27;, &#x27;foo \tbAr.\t baz&#x27;, /A/, &#x27;diW&#x27;, &#x27;foo \t\t baz&#x27;);
testEdit(&#x27;daW_mid_punct&#x27;, &#x27;foo \tbAr.\t baz&#x27;, /A/, &#x27;daW&#x27;, &#x27;foo \tbaz&#x27;);
testEdit(&#x27;diW_mid_punct2&#x27;, &#x27;foo \t,bAr.\t baz&#x27;, /A/, &#x27;diW&#x27;, &#x27;foo \t\t baz&#x27;);
testEdit(&#x27;daW_mid_punct2&#x27;, &#x27;foo \t,bAr.\t baz&#x27;, /A/, &#x27;daW&#x27;, &#x27;foo \tbaz&#x27;);
testEdit(&#x27;diW_start_spc&#x27;, &#x27;bAr\t baz&#x27;, /A/, &#x27;diW&#x27;, &#x27;\t baz&#x27;);
testEdit(&#x27;daW_start_spc&#x27;, &#x27;bAr\t baz&#x27;, /A/, &#x27;daW&#x27;, &#x27;baz&#x27;);
testEdit(&#x27;diW_start_punct&#x27;, &#x27;bAr.\t baz&#x27;, /A/, &#x27;diW&#x27;, &#x27;\t baz&#x27;);
testEdit(&#x27;daW_start_punct&#x27;, &#x27;bAr.\t baz&#x27;, /A/, &#x27;daW&#x27;, &#x27;baz&#x27;);
testEdit(&#x27;diW_end_spc&#x27;, &#x27;foo \tbAr&#x27;, /A/, &#x27;diW&#x27;, &#x27;foo \t&#x27;);
testEdit(&#x27;daW_end_spc&#x27;, &#x27;foo \tbAr&#x27;, /A/, &#x27;daW&#x27;, &#x27;foo&#x27;);
testEdit(&#x27;diW_end_punct&#x27;, &#x27;foo \tbAr.&#x27;, /A/, &#x27;diW&#x27;, &#x27;foo \t&#x27;);
testEdit(&#x27;daW_end_punct&#x27;, &#x27;foo \tbAr.&#x27;, /A/, &#x27;daW&#x27;, &#x27;foo&#x27;);

// Operator-motion tests
testVim(&#x27;D&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;D&#x27;);
  eq(&#x27; wo\nword2\n word3&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;rd1&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 2);
}, { value: &#x27; word1\nword2\n word3&#x27; });
testVim(&#x27;C&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;C&#x27;);
  eq(&#x27; wo\nword2\n word3&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;rd1&#x27;, register.text);
  is(!register.linewise);
  eqPos(curStart, cm.getCursor());
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
}, { value: &#x27; word1\nword2\n word3&#x27; });
testVim(&#x27;Y&#x27;, function(cm, vim, helpers) {
  var curStart = makeCursor(0, 3);
  cm.setCursor(curStart);
  helpers.doKeys(&#x27;Y&#x27;);
  eq(&#x27; word1\nword2\n word3&#x27;, cm.getValue());
  var register = helpers.getRegisterController().getRegister();
  eq(&#x27;rd1&#x27;, register.text);
  is(!register.linewise);
  helpers.assertCursorAt(0, 3);
}, { value: &#x27; word1\nword2\n word3&#x27; });
testVim(&#x27;~&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;3&#x27;, &#x27;~&#x27;);
  eq(&#x27;ABCdefg&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 3);
}, { value: &#x27;abcdefg&#x27; });

// Action tests
testVim(&#x27;ctrl-a&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&lt;C-a&gt;&#x27;);
  eq(&#x27;-9&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
  helpers.doKeys(&#x27;2&#x27;,&#x27;&lt;C-a&gt;&#x27;);
  eq(&#x27;-7&#x27;, cm.getValue());
}, {value: &#x27;-10&#x27;});
testVim(&#x27;ctrl-x&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&lt;C-x&gt;&#x27;);
  eq(&#x27;-1&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
  helpers.doKeys(&#x27;2&#x27;,&#x27;&lt;C-x&gt;&#x27;);
  eq(&#x27;-3&#x27;, cm.getValue());
}, {value: &#x27;0&#x27;});
testVim(&#x27;&lt;C-x&gt;/&lt;C-a&gt; search forward&#x27;, function(cm, vim, helpers) {
  [&#x27;&lt;C-x&gt;&#x27;, &#x27;&lt;C-a&gt;&#x27;].forEach(function(key) {
    cm.setCursor(0, 0);
    helpers.doKeys(key);
    helpers.assertCursorAt(0, 5);
    helpers.doKeys(&#x27;l&#x27;);
    helpers.doKeys(key);
    helpers.assertCursorAt(0, 10);
    cm.setCursor(0, 11);
    helpers.doKeys(key);
    helpers.assertCursorAt(0, 11);
  });
}, {value: &#x27;__jmp1 jmp2 jmp&#x27;});
testVim(&#x27;a&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;a&#x27;);
  helpers.assertCursorAt(0, 2);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;a_eol&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, lines[0].length - 1);
  helpers.doKeys(&#x27;a&#x27;);
  helpers.assertCursorAt(0, lines[0].length);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;i&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;i&#x27;);
  helpers.assertCursorAt(0, 1);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;i_repeat&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;3&#x27;, &#x27;i&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  eq(&#x27;testtesttest&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 11);
}, { value: &#x27;&#x27; });
testVim(&#x27;i_repeat_delete&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;2&#x27;, &#x27;i&#x27;);
  cm.replaceRange(&#x27;z&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Backspace&#x27;, &#x27;Backspace&#x27;, &#x27;Esc&#x27;);
  eq(&#x27;abe&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;abcde&#x27; });
testVim(&#x27;A&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;A&#x27;);
  helpers.assertCursorAt(0, lines[0].length);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;I&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;I&#x27;);
  helpers.assertCursorAt(0, lines[0].textStart);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
});
testVim(&#x27;I_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;3&#x27;, &#x27;I&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  eq(&#x27;testtesttestblah&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 11);
}, { value: &#x27;blah&#x27; });
testVim(&#x27;o&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;o&#x27;);
  eq(&#x27;word1\n\nword2&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 0);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
}, { value: &#x27;word1\nword2&#x27; });
testVim(&#x27;o_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;3&#x27;, &#x27;o&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  eq(&#x27;\ntest\ntest\ntest&#x27;, cm.getValue());
  helpers.assertCursorAt(3, 3);
}, { value: &#x27;&#x27; });
testVim(&#x27;O&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;O&#x27;);
  eq(&#x27;\nword1\nword2&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 0);
  eq(&#x27;vim-insert&#x27;, cm.getOption(&#x27;keyMap&#x27;));
}, { value: &#x27;word1\nword2&#x27; });
testVim(&#x27;J&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;J&#x27;);
  var expectedValue = &#x27;word1  word2\nword3\n word4&#x27;;
  eq(expectedValue, cm.getValue());
  helpers.assertCursorAt(0, expectedValue.indexOf(&#x27;word2&#x27;) - 1);
}, { value: &#x27;word1 \n    word2\nword3\n word4&#x27; });
testVim(&#x27;J_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;3&#x27;, &#x27;J&#x27;);
  var expectedValue = &#x27;word1  word2 word3\n word4&#x27;;
  eq(expectedValue, cm.getValue());
  helpers.assertCursorAt(0, expectedValue.indexOf(&#x27;word3&#x27;) - 1);
}, { value: &#x27;word1 \n    word2\nword3\n word4&#x27; });
testVim(&#x27;p&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().pushText(&#x27;&quot;&#x27;, &#x27;yank&#x27;, &#x27;abc\ndef&#x27;, false);
  helpers.doKeys(&#x27;p&#x27;);
  eq(&#x27;__abc\ndef_&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 2);
}, { value: &#x27;___&#x27; });
testVim(&#x27;p_register&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().getRegister(&#x27;a&#x27;).set(&#x27;abc\ndef&#x27;, false);
  helpers.doKeys(&#x27;&quot;&#x27;, &#x27;a&#x27;, &#x27;p&#x27;);
  eq(&#x27;__abc\ndef_&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 2);
}, { value: &#x27;___&#x27; });
testVim(&#x27;p_wrong_register&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().getRegister(&#x27;a&#x27;).set(&#x27;abc\ndef&#x27;, false);
  helpers.doKeys(&#x27;p&#x27;);
  eq(&#x27;___&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;___&#x27; });
testVim(&#x27;p_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().pushText(&#x27;&quot;&#x27;, &#x27;yank&#x27;, &#x27;  a\nd\n&#x27;, true);
  helpers.doKeys(&#x27;2&#x27;, &#x27;p&#x27;);
  eq(&#x27;___\n  a\nd\n  a\nd&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 2);
}, { value: &#x27;___&#x27; });
testVim(&#x27;p_lastline&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().pushText(&#x27;&quot;&#x27;, &#x27;yank&#x27;, &#x27;  a\nd&#x27;, true);
  helpers.doKeys(&#x27;2&#x27;, &#x27;p&#x27;);
  eq(&#x27;___\n  a\nd\n  a\nd&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 2);
}, { value: &#x27;___&#x27; });
testVim(&#x27;P&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().pushText(&#x27;&quot;&#x27;, &#x27;yank&#x27;, &#x27;abc\ndef&#x27;, false);
  helpers.doKeys(&#x27;P&#x27;);
  eq(&#x27;_abc\ndef__&#x27;, cm.getValue());
  helpers.assertCursorAt(1, 3);
}, { value: &#x27;___&#x27; });
testVim(&#x27;P_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.getRegisterController().pushText(&#x27;&quot;&#x27;, &#x27;yank&#x27;, &#x27;  a\nd\n&#x27;, true);
  helpers.doKeys(&#x27;2&#x27;, &#x27;P&#x27;);
  eq(&#x27;  a\nd\n  a\nd\n___&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 2);
}, { value: &#x27;___&#x27; });
testVim(&#x27;r&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;3&#x27;, &#x27;r&#x27;, &#x27;u&#x27;);
  eq(&#x27;wuuuet\nanother&#x27;, cm.getValue(),&#x27;3r failed&#x27;);
  helpers.assertCursorAt(0, 3);
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;v&#x27;, &#x27;j&#x27;, &#x27;h&#x27;, &#x27;r&#x27;, &#x27;&lt;Space&gt;&#x27;);
  eq(&#x27;wuuu  \n    her&#x27;, cm.getValue(),&#x27;Replacing selection by space-characters failed&#x27;);
}, { value: &#x27;wordet\nanother&#x27; });
testVim(&#x27;R&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;R&#x27;);
  helpers.assertCursorAt(0, 1);
  eq(&#x27;vim-replace&#x27;, cm.getOption(&#x27;keyMap&#x27;));
  is(cm.state.overwrite, &#x27;Setting overwrite state failed&#x27;);
});
testVim(&#x27;mark&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;\&#x27;&#x27;, &#x27;t&#x27;);
  helpers.assertCursorAt(2, 2);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;t&#x27;);
  helpers.assertCursorAt(2, 2);
});
testVim(&#x27;jumpToMark_next&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 2);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_next_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(3, 2);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(3, 1);
});
testVim(&#x27;jumpToMark_next_sameline&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 4);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 4);
});
testVim(&#x27;jumpToMark_next_onlyprev&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(4, 0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(4, 0);
});
testVim(&#x27;jumpToMark_next_nomark&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 2);
  helpers.doKeys(&#x27;]&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_next_linewise_over&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(3, 4);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(2, 1);
  helpers.doKeys(&#x27;]&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(3, 1);
});
testVim(&#x27;jumpToMark_next_action&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;]&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(0, 0);
  var actual = cm.getLine(0);
  var expected = &#x27;pop pop 0 1 2 3 4&#x27;;
  eq(actual, expected, &quot;Deleting while jumping to the next mark failed.&quot;);
});
testVim(&#x27;jumpToMark_next_line_action&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;]&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(0, 1);
  var actual = cm.getLine(0);
  var expected = &#x27; (a) [b] {c} &#x27;
  eq(actual, expected, &quot;Deleting while jumping to the next mark line failed.&quot;);
});
testVim(&#x27;jumpToMark_prev&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  cm.setCursor(4, 0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 2);
  cm.setCursor(4, 0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_prev_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(5, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(3, 2);
  cm.setCursor(5, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(3, 1);
});
testVim(&#x27;jumpToMark_prev_sameline&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 4);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;[&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_prev_onlynext&#x27;, function(cm, vim, helpers) {
  cm.setCursor(4, 4);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_prev_nomark&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;[&#x27;, &#x27;&#x60;&#x27;);
  helpers.assertCursorAt(2, 2);
  helpers.doKeys(&#x27;[&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;jumpToMark_prev_linewise_over&#x27;, function(cm, vim, helpers) {
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(3, 4);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(3, 6);
  helpers.doKeys(&#x27;[&#x27;, &#x27;\&#x27;&#x27;);
  helpers.assertCursorAt(2, 0);
});
testVim(&#x27;delmark_single&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;t&#x27;);
  helpers.doEx(&#x27;delmarks t&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;t&#x27;);
  helpers.assertCursorAt(0, 0);
});
testVim(&#x27;delmark_range&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;d&#x27;);
  cm.setCursor(5, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;e&#x27;);
  helpers.doEx(&#x27;delmarks b-d&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;a&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;b&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;c&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;d&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;e&#x27;);
  helpers.assertCursorAt(5, 2);
});
testVim(&#x27;delmark_multi&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;d&#x27;);
  cm.setCursor(5, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;e&#x27;);
  helpers.doEx(&#x27;delmarks bcd&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;a&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;b&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;c&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;d&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;e&#x27;);
  helpers.assertCursorAt(5, 2);
});
testVim(&#x27;delmark_multi_space&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;d&#x27;);
  cm.setCursor(5, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;e&#x27;);
  helpers.doEx(&#x27;delmarks b c d&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;a&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;b&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;c&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;d&#x27;);
  helpers.assertCursorAt(1, 2);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;e&#x27;);
  helpers.assertCursorAt(5, 2);
});
testVim(&#x27;delmark_all&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;a&#x27;);
  cm.setCursor(2, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;b&#x27;);
  cm.setCursor(3, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;c&#x27;);
  cm.setCursor(4, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;d&#x27;);
  cm.setCursor(5, 2);
  helpers.doKeys(&#x27;m&#x27;, &#x27;e&#x27;);
  helpers.doEx(&#x27;delmarks a b-de&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;a&#x27;);
  helpers.assertCursorAt(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;b&#x27;);
  helpers.assertCursorAt(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;c&#x27;);
  helpers.assertCursorAt(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;d&#x27;);
  helpers.assertCursorAt(0, 0);
  helpers.doKeys(&#x27;&#x60;&#x27;, &#x27;e&#x27;);
  helpers.assertCursorAt(0, 0);
});
testVim(&#x27;visual&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;l&#x27;, &#x27;v&#x27;, &#x27;l&#x27;, &#x27;l&#x27;);
  helpers.assertCursorAt(0, 3);
  eqPos(makeCursor(0, 1), cm.getCursor(&#x27;anchor&#x27;));
  helpers.doKeys(&#x27;d&#x27;);
  eq(&#x27;15&#x27;, cm.getValue());
}, { value: &#x27;12345&#x27; });
testVim(&#x27;visual_line&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;l&#x27;, &#x27;V&#x27;, &#x27;l&#x27;, &#x27;j&#x27;, &#x27;j&#x27;, &#x27;d&#x27;);
  eq(&#x27; 4\n 5&#x27;, cm.getValue());
}, { value: &#x27; 1\n 2\n 3\n 4\n 5&#x27; });
testVim(&#x27;visual_marks&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;l&#x27;, &#x27;v&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;v&#x27;);
  // Test visual mode marks
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;\&#x27;&#x27;, &#x27;&lt;&#x27;);
  helpers.assertCursorAt(0, 1);
  helpers.doKeys(&#x27;\&#x27;&#x27;, &#x27;&gt;&#x27;);
  helpers.assertCursorAt(0, 3);
});
testVim(&#x27;visual_join&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;l&#x27;, &#x27;V&#x27;, &#x27;l&#x27;, &#x27;j&#x27;, &#x27;j&#x27;, &#x27;J&#x27;);
  eq(&#x27; 1 2 3\n 4\n 5&#x27;, cm.getValue());
}, { value: &#x27; 1\n 2\n 3\n 4\n 5&#x27; });
testVim(&#x27;visual_blank&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;v&#x27;, &#x27;k&#x27;);
  eq(vim.visualMode, true);
}, { value: &#x27;\n&#x27; });
testVim(&#x27;s_normal&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;s&#x27;);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;ac&#x27;, cm.getValue());
}, { value: &#x27;abc&#x27;});
testVim(&#x27;s_visual&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;v&#x27;, &#x27;s&#x27;);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;ac&#x27;, cm.getValue());
}, { value: &#x27;abc&#x27;});
testVim(&#x27;S_normal&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;j&#x27;, &#x27;S&#x27;);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.assertCursorAt(1, 0);
  eq(&#x27;aa\n\ncc&#x27;, cm.getValue());
}, { value: &#x27;aa\nbb\ncc&#x27;});
testVim(&#x27;S_visual&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 1);
  helpers.doKeys(&#x27;v&#x27;, &#x27;j&#x27;, &#x27;S&#x27;);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;\ncc&#x27;, cm.getValue());
}, { value: &#x27;aa\nbb\ncc&#x27;});
testVim(&#x27;/ and n/N&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;match&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.assertCursorAt(0, 11);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 6);
  helpers.doKeys(&#x27;N&#x27;);
  helpers.assertCursorAt(0, 11);

  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;/&#x27;);
  helpers.assertCursorAt(1, 6);
}, { value: &#x27;match nope match \n nope Match&#x27; });
testVim(&#x27;/_case&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;Match&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.assertCursorAt(1, 6);
}, { value: &#x27;match nope match \n nope Match&#x27; });
testVim(&#x27;/_nongreedy&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;aa&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa aa \n a aa&#x27;});
testVim(&#x27;?_nongreedy&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;aa&#x27;);
  helpers.doKeys(&#x27;?&#x27;);
  helpers.assertCursorAt(1, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa aa \n a aa&#x27;});
testVim(&#x27;/_greedy&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;a+&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 1);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa aa \n a aa&#x27;});
testVim(&#x27;?_greedy&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;a+&#x27;);
  helpers.doKeys(&#x27;?&#x27;);
  helpers.assertCursorAt(1, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 1);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa aa \n a aa&#x27;});
testVim(&#x27;/_greedy_0_or_more&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;a*&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.assertCursorAt(0, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 5);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 0);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 1);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa  aa\n aa&#x27;});
testVim(&#x27;?_greedy_0_or_more&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;a*&#x27;);
  helpers.doKeys(&#x27;?&#x27;);
  helpers.assertCursorAt(1, 1);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(1, 0);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 5);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 4);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 3);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27;aaa  aa\n aa&#x27;});
testVim(&#x27;? and n/N&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;match&#x27;);
  helpers.doKeys(&#x27;?&#x27;);
  helpers.assertCursorAt(1, 6);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 11);
  helpers.doKeys(&#x27;N&#x27;);
  helpers.assertCursorAt(1, 6);

  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;?&#x27;);
  helpers.assertCursorAt(0, 11);
}, { value: &#x27;match nope match \n nope Match&#x27; });
testVim(&#x27;*&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;*&#x27;);
  helpers.assertCursorAt(0, 22);

  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;2&#x27;, &#x27;*&#x27;);
  helpers.assertCursorAt(1, 8);
}, { value: &#x27;nomatch match nomatch match \nnomatch Match&#x27; });
testVim(&#x27;*_no_word&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;*&#x27;);
  helpers.assertCursorAt(0, 0);
}, { value: &#x27; \n match \n&#x27; });
testVim(&#x27;*_symbol&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;*&#x27;);
  helpers.assertCursorAt(1, 0);
}, { value: &#x27; /}\n/} match \n&#x27; });
testVim(&#x27;#&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;#&#x27;);
  helpers.assertCursorAt(1, 8);

  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;2&#x27;, &#x27;#&#x27;);
  helpers.assertCursorAt(0, 22);
}, { value: &#x27;nomatch match nomatch match \nnomatch Match&#x27; });
testVim(&#x27;*_seek&#x27;, function(cm, vim, helpers) {
  // Should skip over space and symbols.
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;*&#x27;);
  helpers.assertCursorAt(0, 22);
}, { value: &#x27;    :=  match nomatch match \nnomatch Match&#x27; });
testVim(&#x27;#&#x27;, function(cm, vim, helpers) {
  // Should skip over space and symbols.
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;#&#x27;);
  helpers.assertCursorAt(1, 8);
}, { value: &#x27;    :=  match nomatch match \nnomatch Match&#x27; });
testVim(&#x27;.&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;d&#x27;, &#x27;w&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;5 6&#x27;, cm.getValue());
}, { value: &#x27;1 2 3 4 5 6&#x27;});
testVim(&#x27;._repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;d&#x27;, &#x27;w&#x27;);
  helpers.doKeys(&#x27;3&#x27;, &#x27;.&#x27;);
  eq(&#x27;6&#x27;, cm.getValue());
}, { value: &#x27;1 2 3 4 5 6&#x27;});
testVim(&#x27;._insert&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;i&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;testestt&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 6);
}, { value: &#x27;&#x27;});
testVim(&#x27;._insert_repeat&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;i&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  cm.setCursor(0, 4);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;.&#x27;);
  eq(&#x27;testesttestt&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 10);
}, { value: &#x27;&#x27;});
testVim(&#x27;._repeat_insert&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;3&#x27;, &#x27;i&#x27;);
  cm.replaceRange(&#x27;te&#x27;, cm.getCursor());
  cm.setCursor(0, 2);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;tetettetetee&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 10);
}, { value: &#x27;&#x27;});
testVim(&#x27;._insert_o&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;o&#x27;);
  cm.replaceRange(&#x27;z&#x27;, cm.getCursor());
  cm.setCursor(1, 1);
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;\nz\nz&#x27;, cm.getValue());
  helpers.assertCursorAt(2, 0);
}, { value: &#x27;&#x27;});
testVim(&#x27;._insert_o_repeat&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;o&#x27;);
  cm.replaceRange(&#x27;z&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  cm.setCursor(1, 0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;.&#x27;);
  eq(&#x27;\nz\nz\nz&#x27;, cm.getValue());
  helpers.assertCursorAt(3, 0);
}, { value: &#x27;&#x27;});
testVim(&#x27;._insert_o_indent&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;o&#x27;);
  cm.replaceRange(&#x27;z&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  cm.setCursor(1, 2);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;{\n  z\n  z&#x27;, cm.getValue());
  helpers.assertCursorAt(2, 2);
}, { value: &#x27;{&#x27;});
testVim(&#x27;._insert_cw&#x27;, function(cm, vim, helpers) {
  helpers.doKeys(&#x27;c&#x27;, &#x27;w&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;2&#x27;, &#x27;l&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;test test word3&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 8);
}, { value: &#x27;word1 word2 word3&#x27; });
testVim(&#x27;._insert_cw_repeat&#x27;, function(cm, vim, helpers) {
  // For some reason, repeat cw in desktop VIM will does not repeat insert mode
  // changes. Will conform to that behavior.
  helpers.doKeys(&#x27;c&#x27;, &#x27;w&#x27;);
  cm.replaceRange(&#x27;test&#x27;, cm.getCursor());
  helpers.doInsertModeKeys(&#x27;Esc&#x27;);
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;l&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;.&#x27;);
  eq(&#x27;test test&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 8);
}, { value: &#x27;word1 word2 word3&#x27; });
testVim(&#x27;._delete&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 5);
  helpers.doKeys(&#x27;i&#x27;);
  helpers.doInsertModeKeys(&#x27;Backspace&#x27;, &#x27;Esc&#x27;);
  helpers.doKeys(&#x27;.&#x27;);
  eq(&#x27;zace&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;zabcde&#x27;});
testVim(&#x27;._delete_repeat&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 6);
  helpers.doKeys(&#x27;i&#x27;);
  helpers.doInsertModeKeys(&#x27;Backspace&#x27;, &#x27;Esc&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;.&#x27;);
  eq(&#x27;zzce&#x27;, cm.getValue());
  helpers.assertCursorAt(0, 1);
}, { value: &#x27;zzabcde&#x27;});
testVim(&#x27;f;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;f&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;;&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;;&#x27;);
  eq(9, cm.getCursor().ch);
}, { value: &#x27;01x3xx678x&#x27;});
testVim(&#x27;F;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 8);
  helpers.doKeys(&#x27;F&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;;&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;;&#x27;);
  eq(2, cm.getCursor().ch);
}, { value: &#x27;01x3xx6x8x&#x27;});
testVim(&#x27;t;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;t&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;;&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;;&#x27;);
  eq(8, cm.getCursor().ch);
}, { value: &#x27;01x3xx678x&#x27;});
testVim(&#x27;T;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;T&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;;&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;;&#x27;);
  eq(2, cm.getCursor().ch);
}, { value: &#x27;0xx3xx678x&#x27;});
testVim(&#x27;f,&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 6);
  helpers.doKeys(&#x27;f&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;,&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;,&#x27;);
  eq(2, cm.getCursor().ch);
}, { value: &#x27;01x3xx678x&#x27;});
testVim(&#x27;F,&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 3);
  helpers.doKeys(&#x27;F&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;,&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;,&#x27;);
  eq(9, cm.getCursor().ch);
}, { value: &#x27;01x3xx678x&#x27;});
testVim(&#x27;t,&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 6);
  helpers.doKeys(&#x27;t&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;,&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;,&#x27;);
  eq(3, cm.getCursor().ch);
}, { value: &#x27;01x3xx678x&#x27;});
testVim(&#x27;T,&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 4);
  helpers.doKeys(&#x27;T&#x27;, &#x27;x&#x27;);
  helpers.doKeys(&#x27;,&#x27;);
  helpers.doKeys(&#x27;2&#x27;, &#x27;,&#x27;);
  eq(8, cm.getCursor().ch);
}, { value: &#x27;01x3xx67xx&#x27;});
testVim(&#x27;fd,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;f&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;;&#x27;);
  eq(&#x27;56789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;d&#x27;, &#x27;,&#x27;);
  eq(&#x27;01239&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Fd,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;F&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;d&#x27;, &#x27;;&#x27;);
  eq(&#x27;01239&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;,&#x27;);
  eq(&#x27;56789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;td,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;t&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;;&#x27;);
  eq(&#x27;456789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;d&#x27;, &#x27;,&#x27;);
  eq(&#x27;012349&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Td,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;T&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;d&#x27;, &#x27;;&#x27;);
  eq(&#x27;012349&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;d&#x27;, &#x27;,&#x27;);
  eq(&#x27;456789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;fc,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;f&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;;&#x27;, &#x27;Esc&#x27;);
  eq(&#x27;56789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;c&#x27;, &#x27;,&#x27;);
  eq(&#x27;01239&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Fc,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;F&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;c&#x27;, &#x27;;&#x27;, &#x27;Esc&#x27;);
  eq(&#x27;01239&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;,&#x27;);
  eq(&#x27;56789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;tc,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;t&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;;&#x27;, &#x27;Esc&#x27;);
  eq(&#x27;456789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;c&#x27;, &#x27;,&#x27;);
  eq(&#x27;012349&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Tc,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;T&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;c&#x27;, &#x27;;&#x27;, &#x27;Esc&#x27;);
  eq(&#x27;012349&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;c&#x27;, &#x27;,&#x27;);
  eq(&#x27;456789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;fy,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;f&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;y&#x27;, &#x27;;&#x27;, &#x27;P&#x27;);
  eq(&#x27;012340123456789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;y&#x27;, &#x27;,&#x27;, &#x27;P&#x27;);
  eq(&#x27;012345678456789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Fy,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;F&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;y&#x27;, &#x27;;&#x27;, &#x27;p&#x27;);
  eq(&#x27;012345678945678&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;y&#x27;, &#x27;,&#x27;, &#x27;P&#x27;);
  eq(&#x27;012340123456789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;ty,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;t&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;y&#x27;, &#x27;;&#x27;, &#x27;P&#x27;);
  eq(&#x27;01230123456789&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;y&#x27;, &#x27;,&#x27;, &#x27;p&#x27;);
  eq(&#x27;01234567895678&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;Ty,;&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;T&#x27;, &#x27;4&#x27;);
  cm.setCursor(0, 9);
  helpers.doKeys(&#x27;y&#x27;, &#x27;;&#x27;, &#x27;p&#x27;);
  eq(&#x27;01234567895678&#x27;, cm.getValue());
  helpers.doKeys(&#x27;u&#x27;);
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;y&#x27;, &#x27;,&#x27;, &#x27;P&#x27;);
  eq(&#x27;01230123456789&#x27;, cm.getValue());
}, { value: &#x27;0123456789&#x27;});
testVim(&#x27;HML&#x27;, function(cm, vim, helpers) {
  var lines = 35;
  var textHeight = cm.defaultTextHeight();
  cm.setSize(600, lines*textHeight);
  cm.setCursor(120, 0);
  helpers.doKeys(&#x27;H&#x27;);
  helpers.assertCursorAt(86, 2);
  helpers.doKeys(&#x27;L&#x27;);
  helpers.assertCursorAt(120, 4);
  helpers.doKeys(&#x27;M&#x27;);
  helpers.assertCursorAt(103,4);
}, { value: (function(){
  var lines = new Array(100);
  var upper = &#x27;  xx\n&#x27;;
  var lower = &#x27;    xx\n&#x27;;
  upper = lines.join(upper);
  lower = lines.join(lower);
  return upper + lower;
})()});

var zVals = [&#x27;zb&#x27;,&#x27;zz&#x27;,&#x27;zt&#x27;,&#x27;z-&#x27;,&#x27;z.&#x27;,&#x27;z&lt;CR&gt;&#x27;].map(function(e, idx){
  var lineNum = 250;
  var lines = 35;
  testVim(e, function(cm, vim, helpers) {
    var k1 = e[0];
    var k2 = e.substring(1);
    var textHeight = cm.defaultTextHeight();
    cm.setSize(600, lines*textHeight);
    cm.setCursor(lineNum, 0);
    helpers.doKeys(k1, k2);
    zVals[idx] = cm.getScrollInfo().top;
  }, { value: (function(){
    return new Array(500).join(&#x27;\n&#x27;);
  })()});
});
testVim(&#x27;zb&lt;zz&#x27;, function(cm, vim, helpers){
  eq(zVals[0]&lt;zVals[1], true);
});
testVim(&#x27;zz&lt;zt&#x27;, function(cm, vim, helpers){
  eq(zVals[1]&lt;zVals[2], true);
});
testVim(&#x27;zb==z-&#x27;, function(cm, vim, helpers){
  eq(zVals[0], zVals[3]);
});
testVim(&#x27;zz==z.&#x27;, function(cm, vim, helpers){
  eq(zVals[1], zVals[4]);
});
testVim(&#x27;zt==z&lt;CR&gt;&#x27;, function(cm, vim, helpers){
  eq(zVals[2], zVals[5]);
});

var squareBracketMotionSandbox = &#x27;&#x27;+
  &#x27;({\n&#x27;+//0
  &#x27;  ({\n&#x27;+//11
  &#x27;  /*comment {\n&#x27;+//2
  &#x27;            */(\n&#x27;+//3
  &#x27;#else                \n&#x27;+//4
  &#x27;  /*       )\n&#x27;+//5
  &#x27;#if        }\n&#x27;+//6
  &#x27;  )}*/\n&#x27;+//7
  &#x27;)}\n&#x27;+//8
  &#x27;{}\n&#x27;+//9
  &#x27;#else {{\n&#x27;+//10
  &#x27;{}\n&#x27;+//11
  &#x27;}\n&#x27;+//12
  &#x27;{\n&#x27;+//13
  &#x27;#endif\n&#x27;+//14
  &#x27;}\n&#x27;+//15
  &#x27;}\n&#x27;+//16
  &#x27;#else&#x27;;//17
testVim(&#x27;[[, ]]&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(9,0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(13,0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(17,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(13,0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(9,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(0,0);
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[], ][&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(12,0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(16,0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;[&#x27;);
  helpers.assertCursorAt(17,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(16,0);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(12,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;]&#x27;);
  helpers.assertCursorAt(0,0);
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[{, ]}&#x27;, function(cm, vim, helpers) {
  cm.setCursor(4, 10);
  helpers.doKeys(&#x27;[&#x27;, &#x27;{&#x27;);
  helpers.assertCursorAt(2,12);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;{&#x27;);
  helpers.assertCursorAt(0,1);
  cm.setCursor(4, 10);
  helpers.doKeys(&#x27;]&#x27;, &#x27;}&#x27;);
  helpers.assertCursorAt(6,11);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;}&#x27;);
  helpers.assertCursorAt(8,1);
  cm.setCursor(0,1);
  helpers.doKeys(&#x27;]&#x27;, &#x27;}&#x27;);
  helpers.assertCursorAt(8,1);
  helpers.doKeys(&#x27;[&#x27;, &#x27;{&#x27;);
  helpers.assertCursorAt(0,1);
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[(, ])&#x27;, function(cm, vim, helpers) {
  cm.setCursor(4, 10);
  helpers.doKeys(&#x27;[&#x27;, &#x27;(&#x27;);
  helpers.assertCursorAt(3,14);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;(&#x27;);
  helpers.assertCursorAt(0,0);
  cm.setCursor(4, 10);
  helpers.doKeys(&#x27;]&#x27;, &#x27;)&#x27;);
  helpers.assertCursorAt(5,11);
  helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, &#x27;)&#x27;);
  helpers.assertCursorAt(8,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;(&#x27;);
  helpers.assertCursorAt(0,0);
  helpers.doKeys(&#x27;]&#x27;, &#x27;)&#x27;);
  helpers.assertCursorAt(8,0);
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[*, ]*, [/, ]/&#x27;, function(cm, vim, helpers) {
  [&#x27;*&#x27;, &#x27;/&#x27;].forEach(function(key){
    cm.setCursor(7, 0);
    helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, key);
    helpers.assertCursorAt(2,2);
    helpers.doKeys(&#x27;2&#x27;, &#x27;]&#x27;, key);
    helpers.assertCursorAt(7,5);
  });
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[#, ]#&#x27;, function(cm, vim, helpers) {
  cm.setCursor(10, 3);
  helpers.doKeys(&#x27;2&#x27;, &#x27;[&#x27;, &#x27;#&#x27;);
  helpers.assertCursorAt(4,0);
  helpers.doKeys(&#x27;5&#x27;, &#x27;]&#x27;, &#x27;#&#x27;);
  helpers.assertCursorAt(17,0);
  cm.setCursor(10, 3);
  helpers.doKeys(&#x27;]&#x27;, &#x27;#&#x27;);
  helpers.assertCursorAt(14,0);
}, { value: squareBracketMotionSandbox});
testVim(&#x27;[m, ]m, [M, ]M&#x27;, function(cm, vim, helpers) {
  cm.setCursor(11, 0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;m&#x27;);
  helpers.assertCursorAt(10,7);
  helpers.doKeys(&#x27;4&#x27;, &#x27;[&#x27;, &#x27;m&#x27;);
  helpers.assertCursorAt(1,3);
  helpers.doKeys(&#x27;5&#x27;, &#x27;]&#x27;, &#x27;m&#x27;);
  helpers.assertCursorAt(11,0);
  helpers.doKeys(&#x27;[&#x27;, &#x27;M&#x27;);
  helpers.assertCursorAt(9,1);
  helpers.doKeys(&#x27;3&#x27;, &#x27;]&#x27;, &#x27;M&#x27;);
  helpers.assertCursorAt(15,0);
  helpers.doKeys(&#x27;5&#x27;, &#x27;[&#x27;, &#x27;M&#x27;);
  helpers.assertCursorAt(7,3);
}, { value: squareBracketMotionSandbox});

// Ex mode tests
testVim(&#x27;ex_go_to_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(0, 0);
  helpers.doEx(&#x27;4&#x27;);
  helpers.assertCursorAt(3, 0);
}, { value: &#x27;a\nb\nc\nd\ne\n&#x27;});
testVim(&#x27;ex_write&#x27;, function(cm, vim, helpers) {
  var tmp = CodeMirror.commands.save;
  var written;
  var actualCm;
  CodeMirror.commands.save = function(cm) {
    written = true;
    actualCm = cm;
  };
  // Test that w, wr, wri ... write all trigger :write.
  var command = &#x27;write&#x27;;
  for (var i = 1; i &lt; command.length; i++) {
    written = false;
    actualCm = null;
    helpers.doEx(command.substring(0, i));
    eq(written, true);
    eq(actualCm, cm);
  }
  CodeMirror.commands.save = tmp;
});
testVim(&#x27;ex_sort&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort&#x27;);
  eq(&#x27;Z\na\nb\nc\nd&#x27;, cm.getValue());
}, { value: &#x27;b\nZ\nd\nc\na&#x27;});
testVim(&#x27;ex_sort_reverse&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort!&#x27;);
  eq(&#x27;d\nc\nb\na&#x27;, cm.getValue());
}, { value: &#x27;b\nd\nc\na&#x27;});
testVim(&#x27;ex_sort_range&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;2,3sort&#x27;);
  eq(&#x27;b\nc\nd\na&#x27;, cm.getValue());
}, { value: &#x27;b\nd\nc\na&#x27;});
testVim(&#x27;ex_sort_oneline&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;2sort&#x27;);
  // Expect no change.
  eq(&#x27;b\nd\nc\na&#x27;, cm.getValue());
}, { value: &#x27;b\nd\nc\na&#x27;});
testVim(&#x27;ex_sort_ignoreCase&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort i&#x27;);
  eq(&#x27;a\nb\nc\nd\nZ&#x27;, cm.getValue());
}, { value: &#x27;b\nZ\nd\nc\na&#x27;});
testVim(&#x27;ex_sort_unique&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort u&#x27;);
  eq(&#x27;Z\na\nb\nc\nd&#x27;, cm.getValue());
}, { value: &#x27;b\nZ\na\na\nd\na\nc\na&#x27;});
testVim(&#x27;ex_sort_decimal&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort d&#x27;);
  eq(&#x27;d3\n s5\n6\n.9&#x27;, cm.getValue());
}, { value: &#x27;6\nd3\n s5\n.9&#x27;});
testVim(&#x27;ex_sort_decimal_negative&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort d&#x27;);
  eq(&#x27;z-9\nd3\n s5\n6\n.9&#x27;, cm.getValue());
}, { value: &#x27;6\nd3\n s5\n.9\nz-9&#x27;});
testVim(&#x27;ex_sort_decimal_reverse&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort! d&#x27;);
  eq(&#x27;.9\n6\n s5\nd3&#x27;, cm.getValue());
}, { value: &#x27;6\nd3\n s5\n.9&#x27;});
testVim(&#x27;ex_sort_hex&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort x&#x27;);
  eq(&#x27; s5\n6\n.9\n&amp;0xB\nd3&#x27;, cm.getValue());
}, { value: &#x27;6\nd3\n s5\n&amp;0xB\n.9&#x27;});
testVim(&#x27;ex_sort_octal&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort o&#x27;);
  eq(&#x27;.8\n.9\nd3\n s5\n6&#x27;, cm.getValue());
}, { value: &#x27;6\nd3\n s5\n.9\n.8&#x27;});
testVim(&#x27;ex_sort_decimal_mixed&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort d&#x27;);
  eq(&#x27;y\nz\nc1\nb2\na3&#x27;, cm.getValue());
}, { value: &#x27;a3\nz\nc1\ny\nb2&#x27;});
testVim(&#x27;ex_sort_decimal_mixed_reverse&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;sort! d&#x27;);
  eq(&#x27;a3\nb2\nc1\nz\ny&#x27;, cm.getValue());
}, { value: &#x27;a3\nz\nc1\ny\nb2&#x27;});
testVim(&#x27;ex_substitute_same_line&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;s/one/two&#x27;);
  eq(&#x27;one one\n two two&#x27;, cm.getValue());
}, { value: &#x27;one one\n one one&#x27;});
testVim(&#x27;ex_substitute_global&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;%s/one/two&#x27;);
  eq(&#x27;two two\n two two&#x27;, cm.getValue());
}, { value: &#x27;one one\n one one&#x27;});
testVim(&#x27;ex_substitute_input_range&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;1,3s/\\d/0&#x27;);
  eq(&#x27;0\n0\n0\n4&#x27;, cm.getValue());
}, { value: &#x27;1\n2\n3\n4&#x27; });
testVim(&#x27;ex_substitute_visual_range&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  // Set last visual mode selection marks &#x27;&lt; and &#x27;&gt; at lines 2 and 4
  helpers.doKeys(&#x27;V&#x27;, &#x27;2&#x27;, &#x27;j&#x27;, &#x27;v&#x27;);
  helpers.doEx(&#x27;\&#x27;&lt;,\&#x27;&gt;s/\\d/0&#x27;);
  eq(&#x27;1\n0\n0\n0\n5&#x27;, cm.getValue());
}, { value: &#x27;1\n2\n3\n4\n5&#x27; });
testVim(&#x27;ex_substitute_capture&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;s/(\\d+)/$1$1/&#x27;)
  eq(&#x27;a1111 a1212 a1313&#x27;, cm.getValue());
}, { value: &#x27;a11 a12 a13&#x27; });
testVim(&#x27;ex_substitute_empty_query&#x27;, function(cm, vim, helpers) {
  // If the query is empty, use last query.
  cm.setCursor(1, 0);
  cm.openDialog = helpers.fakeOpenDialog(&#x27;1&#x27;);
  helpers.doKeys(&#x27;/&#x27;);
  helpers.doEx(&#x27;s//b&#x27;);
  eq(&#x27;abb ab2 ab3&#x27;, cm.getValue());
}, { value: &#x27;a11 a12 a13&#x27; });
testVim(&#x27;ex_substitute_count&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;s/\\d/0/i 2&#x27;);
  eq(&#x27;1\n0\n0\n4&#x27;, cm.getValue());
}, { value: &#x27;1\n2\n3\n4&#x27; });
testVim(&#x27;ex_substitute_count_with_range&#x27;, function(cm, vim, helpers) {
  cm.setCursor(1, 0);
  helpers.doEx(&#x27;1,3s/\\d/0/ 3&#x27;);
  eq(&#x27;1\n2\n0\n0&#x27;, cm.getValue());
}, { value: &#x27;1\n2\n3\n4&#x27; });
function testSubstituteConfirm(name, command, initialValue, expectedValue, keys, finalPos) {
  testVim(name, function(cm, vim, helpers) {
    var savedOpenDialog = cm.openDialog;
    var savedKeyName = CodeMirror.keyName;
    var onKeyDown;
    var recordedCallback;
    var closed = true; // Start out closed, set false on second openDialog.
    function close() {
      closed = true;
    }
    // First openDialog should save callback.
    cm.openDialog = function(template, callback, options) {
      recordedCallback = callback;
    }
    // Do first openDialog.
    helpers.doKeys(&#x27;:&#x27;);
    // Second openDialog should save keyDown handler.
    cm.openDialog = function(template, callback, options) {
      onKeyDown = options.onKeyDown;
      closed = false;
    };
    // Return the command to Vim and trigger second openDialog.
    recordedCallback(command);
    // The event should really use keyCode, but here just mock it out and use
    // key and replace keyName to just return key.
    CodeMirror.keyName = function (e) { return e.key; }
    keys = keys.toUpperCase();
    for (var i = 0; i &lt; keys.length; i++) {
      is(!closed);
      onKeyDown({ key: keys.charAt(i) }, &#x27;&#x27;, close);
    }
    try {
      eq(expectedValue, cm.getValue());
      helpers.assertCursorAt(finalPos);
      is(closed);
    } catch(e) {
      throw e
    } finally {
      // Restore overriden functions.
      CodeMirror.keyName = savedKeyName;
      cm.openDialog = savedOpenDialog;
    }
  }, { value: initialValue });
};
testSubstituteConfirm(&#x27;ex_substitute_confirm_emptydoc&#x27;,
    &#x27;%s/x/b/c&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, makeCursor(0, 0));
testSubstituteConfirm(&#x27;ex_substitute_confirm_nomatch&#x27;,
    &#x27;%s/x/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;ba a\nbab&#x27;, &#x27;&#x27;, makeCursor(0, 0));
testSubstituteConfirm(&#x27;ex_substitute_confirm_accept&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbbb&#x27;, &#x27;yyy&#x27;, makeCursor(1, 1));
testSubstituteConfirm(&#x27;ex_substitute_confirm_random_keys&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbbb&#x27;, &#x27;ysdkywerty&#x27;, makeCursor(1, 1));
testSubstituteConfirm(&#x27;ex_substitute_confirm_some&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb a\nbbb&#x27;, &#x27;yny&#x27;, makeCursor(1, 1));
testSubstituteConfirm(&#x27;ex_substitute_confirm_all&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbbb&#x27;, &#x27;a&#x27;, makeCursor(1, 1));
testSubstituteConfirm(&#x27;ex_substitute_confirm_accept_then_all&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbbb&#x27;, &#x27;ya&#x27;, makeCursor(1, 1));
testSubstituteConfirm(&#x27;ex_substitute_confirm_quit&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb a\nbab&#x27;, &#x27;yq&#x27;, makeCursor(0, 3));
testSubstituteConfirm(&#x27;ex_substitute_confirm_last&#x27;,
    &#x27;%s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbab&#x27;, &#x27;yl&#x27;, makeCursor(0, 3));
testSubstituteConfirm(&#x27;ex_substitute_confirm_oneline&#x27;,
    &#x27;1s/a/b/c&#x27;, &#x27;ba a\nbab&#x27;, &#x27;bb b\nbab&#x27;, &#x27;yl&#x27;, makeCursor(0, 3));
testSubstituteConfirm(&#x27;ex_substitute_confirm_range_accept&#x27;,
    &#x27;1,2s/a/b/c&#x27;, &#x27;aa\na \na\na&#x27;, &#x27;bb\nb \na\na&#x27;, &#x27;yyy&#x27;, makeCursor(1, 0));
testSubstituteConfirm(&#x27;ex_substitute_confirm_range_some&#x27;,
    &#x27;1,3s/a/b/c&#x27;, &#x27;aa\na \na\na&#x27;, &#x27;ba\nb \nb\na&#x27;, &#x27;ynyy&#x27;, makeCursor(2, 0));
testSubstituteConfirm(&#x27;ex_substitute_confirm_range_all&#x27;,
    &#x27;1,3s/a/b/c&#x27;, &#x27;aa\na \na\na&#x27;, &#x27;bb\nb \nb\na&#x27;, &#x27;a&#x27;, makeCursor(2, 0));
testSubstituteConfirm(&#x27;ex_substitute_confirm_range_last&#x27;,
    &#x27;1,3s/a/b/c&#x27;, &#x27;aa\na \na\na&#x27;, &#x27;bb\nb \na\na&#x27;, &#x27;yyl&#x27;, makeCursor(1, 0));
//:noh should clear highlighting of search-results but allow to resume search through n
testVim(&#x27;ex_noh_clearSearchHighlight&#x27;, function(cm, vim, helpers) {
  cm.openDialog = helpers.fakeOpenDialog(&#x27;match&#x27;);
  helpers.doKeys(&#x27;?&#x27;);
  helpers.doEx(&#x27;noh&#x27;);
  eq(vim.searchState_.getOverlay(),null,&#x27;match-highlighting wasn\&#x27;t cleared&#x27;);
  helpers.doKeys(&#x27;n&#x27;);
  helpers.assertCursorAt(0, 11,&#x27;can\&#x27;t resume search after clearing highlighting&#x27;);
}, { value: &#x27;match nope match \n nope Match&#x27; });
// TODO: Reset key maps after each test.
testVim(&#x27;ex_map_key2key&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map a x&#x27;);
  helpers.doKeys(&#x27;a&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;bc&#x27;, cm.getValue());
}, { value: &#x27;abc&#x27; });
testVim(&#x27;ex_map_key2key_to_colon&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map ; :&#x27;);
  var dialogOpened = false;
  cm.openDialog = function() {
    dialogOpened = true;
  }
  helpers.doKeys(&#x27;;&#x27;);
  eq(dialogOpened, true);
});
testVim(&#x27;ex_map_ex2key:&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map :del x&#x27;);
  helpers.doEx(&#x27;del&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;bc&#x27;, cm.getValue());
}, { value: &#x27;abc&#x27; });
testVim(&#x27;ex_map_ex2ex&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map :del :w&#x27;);
  var tmp = CodeMirror.commands.save;
  var written = false;
  var actualCm;
  CodeMirror.commands.save = function(cm) {
    written = true;
    actualCm = cm;
  };
  helpers.doEx(&#x27;del&#x27;);
  CodeMirror.commands.save = tmp;
  eq(written, true);
  eq(actualCm, cm);
});
testVim(&#x27;ex_map_key2ex&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map a :w&#x27;);
  var tmp = CodeMirror.commands.save;
  var written = false;
  var actualCm;
  CodeMirror.commands.save = function(cm) {
    written = true;
    actualCm = cm;
  };
  helpers.doKeys(&#x27;a&#x27;);
  CodeMirror.commands.save = tmp;
  eq(written, true);
  eq(actualCm, cm);
});
// Testing registration of functions as ex-commands and mapping to &lt;Key&gt;-keys
testVim(&#x27;ex_api_test&#x27;, function(cm, vim, helpers) {
  var res=false;
  var val=&#x27;from&#x27;;
  CodeMirror.Vim.defineEx(&#x27;extest&#x27;,&#x27;ext&#x27;,function(cm,params){
    if(params.args)val=params.args[0];
    else res=true;
  });
  helpers.doEx(&#x27;:ext to&#x27;);
  eq(val,&#x27;to&#x27;,&#x27;Defining ex-command failed&#x27;);
  CodeMirror.Vim.map(&#x27;&lt;C-CR&gt;&lt;Space&gt;&#x27;,&#x27;:ext&#x27;);
  helpers.doKeys(&#x27;&lt;C-CR&gt;&#x27;,&#x27;&lt;Space&gt;&#x27;);
  is(res,&#x27;Mapping to key failed&#x27;);
});
// For now, this test needs to be last because it messes up : for future tests.
testVim(&#x27;ex_map_key2key_from_colon&#x27;, function(cm, vim, helpers) {
  helpers.doEx(&#x27;map : x&#x27;);
  helpers.doKeys(&#x27;:&#x27;);
  helpers.assertCursorAt(0, 0);
  eq(&#x27;bc&#x27;, cm.getValue());
}, { value: &#x27;abc&#x27; });

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
