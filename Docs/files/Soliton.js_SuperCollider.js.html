<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>Soliton.js/SuperCollider.js - Lich.sc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title">Lich.sc</h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for: 0.1
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Functions</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs" style="display: none;">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/allpassC.html">allpassC</a></li>
            
                <li><a href="../classes/allpassL.html">allpassL</a></li>
            
                <li><a href="../classes/allpassN.html">allpassN</a></li>
            
                <li><a href="../classes/auxIn.html">auxIn</a></li>
            
                <li><a href="../classes/bandpass.html">bandpass</a></li>
            
                <li><a href="../classes/blip.html">blip</a></li>
            
                <li><a href="../classes/brown.html">brown</a></li>
            
                <li><a href="../classes/bufAllpassC.html">bufAllpassC</a></li>
            
                <li><a href="../classes/bufAllpassL.html">bufAllpassL</a></li>
            
                <li><a href="../classes/bufAllpassN.html">bufAllpassN</a></li>
            
                <li><a href="../classes/bufCombC.html">bufCombC</a></li>
            
                <li><a href="../classes/bufCombL.html">bufCombL</a></li>
            
                <li><a href="../classes/bufCombN.html">bufCombN</a></li>
            
                <li><a href="../classes/bufDelayC.html">bufDelayC</a></li>
            
                <li><a href="../classes/bufDelayL.html">bufDelayL</a></li>
            
                <li><a href="../classes/bufDelayN.html">bufDelayN</a></li>
            
                <li><a href="../classes/clip.html">clip</a></li>
            
                <li><a href="../classes/clipNoise.html">clipNoise</a></li>
            
                <li><a href="../classes/coingate.html">coingate</a></li>
            
                <li><a href="../classes/combC.html">combC</a></li>
            
                <li><a href="../classes/combL.html">combL</a></li>
            
                <li><a href="../classes/combN.html">combN</a></li>
            
                <li><a href="../classes/compander.html">compander</a></li>
            
                <li><a href="../classes/crackle.html">crackle</a></li>
            
                <li><a href="../classes/crush.html">crush</a></li>
            
                <li><a href="../classes/cuspL.html">cuspL</a></li>
            
                <li><a href="../classes/cuspN.html">cuspN</a></li>
            
                <li><a href="../classes/dc.html">dc</a></li>
            
                <li><a href="../classes/decimate.html">decimate</a></li>
            
                <li><a href="../classes/delayC.html">delayC</a></li>
            
                <li><a href="../classes/delayL.html">delayL</a></li>
            
                <li><a href="../classes/delayN.html">delayN</a></li>
            
                <li><a href="../classes/dfm1.html">dfm1</a></li>
            
                <li><a href="../classes/dup.html">dup</a></li>
            
                <li><a href="../classes/dust.html">dust</a></li>
            
                <li><a href="../classes/dust2.html">dust2</a></li>
            
                <li><a href="../classes/env.html">env</a></li>
            
                <li><a href="../classes/env2.html">env2</a></li>
            
                <li><a href="../classes/fold.html">fold</a></li>
            
                <li><a href="../classes/formant.html">formant</a></li>
            
                <li><a href="../classes/freeverb.html">freeverb</a></li>
            
                <li><a href="../classes/freqshift.html">freqshift</a></li>
            
                <li><a href="../classes/gausstrig.html">gausstrig</a></li>
            
                <li><a href="../classes/gbmanL.html">gbmanL</a></li>
            
                <li><a href="../classes/gbmanN.html">gbmanN</a></li>
            
                <li><a href="../classes/gray.html">gray</a></li>
            
                <li><a href="../classes/gverb.html">gverb</a></li>
            
                <li><a href="../classes/highpass.html">highpass</a></li>
            
                <li><a href="../classes/impulse.html">impulse</a></li>
            
                <li><a href="../classes/lag.html">lag</a></li>
            
                <li><a href="../classes/leakdc.html">leakdc</a></li>
            
                <li><a href="../classes/leakdc1.html">leakdc1</a></li>
            
                <li><a href="../classes/limiter.html">limiter</a></li>
            
                <li><a href="../classes/line.html">line</a></li>
            
                <li><a href="../classes/linexp.html">linexp</a></li>
            
                <li><a href="../classes/linlin.html">linlin</a></li>
            
                <li><a href="../classes/localBuf.html">localBuf</a></li>
            
                <li><a href="../classes/lowpass.html">lowpass</a></li>
            
                <li><a href="../classes/noiseL.html">noiseL</a></li>
            
                <li><a href="../classes/noiseN.html">noiseN</a></li>
            
                <li><a href="../classes/noiseX.html">noiseX</a></li>
            
                <li><a href="../classes/out.html">out</a></li>
            
                <li><a href="../classes/pan.html">pan</a></li>
            
                <li><a href="../classes/perc.html">perc</a></li>
            
                <li><a href="../classes/perc2.html">perc2</a></li>
            
                <li><a href="../classes/pink.html">pink</a></li>
            
                <li><a href="../classes/pitchshift.html">pitchshift</a></li>
            
                <li><a href="../classes/poll.html">poll</a></li>
            
                <li><a href="../classes/pulse.html">pulse</a></li>
            
                <li><a href="../classes/range.html">range</a></li>
            
                <li><a href="../classes/saw.html">saw</a></li>
            
                <li><a href="../classes/scAbs.html">scAbs</a></li>
            
                <li><a href="../classes/scACos.html">scACos</a></li>
            
                <li><a href="../classes/scAmpDb.html">scAmpDb</a></li>
            
                <li><a href="../classes/scASin.html">scASin</a></li>
            
                <li><a href="../classes/scATan.html">scATan</a></li>
            
                <li><a href="../classes/scBitAnd.html">scBitAnd</a></li>
            
                <li><a href="../classes/scBitLeftShift.html">scBitLeftShift</a></li>
            
                <li><a href="../classes/scBitOr.html">scBitOr</a></li>
            
                <li><a href="../classes/scBitRightShift.html">scBitRightShift</a></li>
            
                <li><a href="../classes/scBitXor.html">scBitXor</a></li>
            
                <li><a href="../classes/scCeil.html">scCeil</a></li>
            
                <li><a href="../classes/scClip.html">scClip</a></li>
            
                <li><a href="../classes/scCos.html">scCos</a></li>
            
                <li><a href="../classes/scCosh.html">scCosh</a></li>
            
                <li><a href="../classes/scCpsMidi.html">scCpsMidi</a></li>
            
                <li><a href="../classes/scCubed.html">scCubed</a></li>
            
                <li><a href="../classes/scDbAmp.html">scDbAmp</a></li>
            
                <li><a href="../classes/scDistort.html">scDistort</a></li>
            
                <li><a href="../classes/scExpRand.html">scExpRand</a></li>
            
                <li><a href="../classes/scFloor.html">scFloor</a></li>
            
                <li><a href="../classes/scFold.html">scFold</a></li>
            
                <li><a href="../classes/scIRand.html">scIRand</a></li>
            
                <li><a href="../classes/scLinRand.html">scLinRand</a></li>
            
                <li><a href="../classes/scLog.html">scLog</a></li>
            
                <li><a href="../classes/scLog10.html">scLog10</a></li>
            
                <li><a href="../classes/scLog2.html">scLog2</a></li>
            
                <li><a href="../classes/scMidiCps.html">scMidiCps</a></li>
            
                <li><a href="../classes/scMod.html">scMod</a></li>
            
                <li><a href="../classes/scNeg.html">scNeg</a></li>
            
                <li><a href="../classes/scNRand.html">scNRand</a></li>
            
                <li><a href="../classes/scPow.html">scPow</a></li>
            
                <li><a href="../classes/scRand.html">scRand</a></li>
            
                <li><a href="../classes/scReciprocal.html">scReciprocal</a></li>
            
                <li><a href="../classes/scRound.html">scRound</a></li>
            
                <li><a href="../classes/scSin.html">scSin</a></li>
            
                <li><a href="../classes/scSinh.html">scSinh</a></li>
            
                <li><a href="../classes/scSoftClip.html">scSoftClip</a></li>
            
                <li><a href="../classes/scSqrt.html">scSqrt</a></li>
            
                <li><a href="../classes/scSquared.html">scSquared</a></li>
            
                <li><a href="../classes/scTan.html">scTan</a></li>
            
                <li><a href="../classes/scTanh.html">scTanh</a></li>
            
                <li><a href="../classes/scTExpRand.html">scTExpRand</a></li>
            
                <li><a href="../classes/scTIRand.html">scTIRand</a></li>
            
                <li><a href="../classes/scTRand.html">scTRand</a></li>
            
                <li><a href="../classes/scWrap.html">scWrap</a></li>
            
                <li><a href="../classes/sin.html">sin</a></li>
            
                <li><a href="../classes/sinP.html">sinP</a></li>
            
                <li><a href="../classes/square.html">square</a></li>
            
                <li><a href="../classes/stepper.html">stepper</a></li>
            
                <li><a href="../classes/tri.html">tri</a></li>
            
                <li><a href="../classes/white.html">white</a></li>
            
                <li><a href="../classes/wrap.html">wrap</a></li>
            
                <li><a href="../classes/xline.html">xline</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Bitwise Operators.html">Bitwise Operators</a></li>
            
                <li><a href="../modules/Buffers.html">Buffers</a></li>
            
                <li><a href="../modules/Chaos.html">Chaos</a></li>
            
                <li><a href="../modules/Delays.html">Delays</a></li>
            
                <li><a href="../modules/Distortions.html">Distortions</a></li>
            
                <li><a href="../modules/Envelopes.html">Envelopes</a></li>
            
                <li><a href="../modules/Filters.html">Filters</a></li>
            
                <li><a href="../modules/InputOutput.html">InputOutput</a></li>
            
                <li><a href="../modules/Lich.sc UGens.html">Lich.sc UGens</a></li>
            
                <li><a href="../modules/Noise.html">Noise</a></li>
            
                <li><a href="../modules/Oscillators.html">Oscillators</a></li>
            
                <li><a href="../modules/Panning.html">Panning</a></li>
            
                <li><a href="../modules/Random.html">Random</a></li>
            
                <li><a href="../modules/Signal Math.html">Signal Math</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options" style="visibility:hidden">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: Soliton.js/SuperCollider.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* 
    Lich.js - JavaScript audio framework
    Copyright (C) 2012 Chad McKinney

	http://chadmckinneyaudio.com/
	seppukuzombie@gmail.com

	LICENSE
	=======

	Licensed under the Simplified BSD License:

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met: 

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer. 
	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution. 

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	The views and conclusions contained in the software and documentation are those
	of the authors and should not be interpreted as representing official policies, 
	either expressed or implied, of the FreeBSD Project.
*/



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Server setup
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

var spawn = require(&#x27;child_process&#x27;).spawn;
var exec = require(&#x27;child_process&#x27;).exec;
var osc = require(&quot;osc&quot;);

function _Server(options) {
	this.options = options;
}

_Server.prototype.connect = function() {
	var self = this;

	this.udp = new osc.UDPPort({
		localAddress: &quot;0.0.0.0&quot;,
		localPort: 57121
	});
	
	/*
	this.udp.on(&quot;bundle&quot;, function (oscBundle) {
		console.log(oscBundle);
	});

	this.udp.on(&quot;message&quot;, function (oscMessage) {
		console.log(oscMessage);
	});*/

	this.udp.open();
}

_Server.prototype.disconnect = function() {
	if(typeof this.udp !== &quot;undefined&quot;)
	{
		this.udp.close();
		delete this.udp;
	}
}

_Server.prototype.sendMsg = function(address, args) {
	this.udp.send({
		address: address,
		args: args
	}, this.options.sHost, this.options.sPortNum);
}

// Useful for scheduling events in the future, makes for better timing!
_Server.prototype.scheduleMsg = function(secondsFromNow, address, args) {

	this.udp.send({
		timeTag: osc.timeTag(secondsFromNow),
		packets: [{
			address: address,
			args: args
		}]
	}, this.options.sHost, this.options.sPortNum);
}

function getSCPath()
{
	switch(process.platform)
	{
	case &quot;win32&quot;:
	case &quot;win64&quot;:
		return &quot;C:/Program Files (x86)/SuperCollider-3.6.6/scsynth&quot;;
		break;
		
	case &quot;darwin&quot;:
		return &quot;/Applications/SuperCollider/SuperCollider.app/Contents/Resources/scsynth&quot;;
		break;

	case &quot;linux&quot;:
		process.env[&quot;SC_JACK_DEFAULT_INPUTS&quot;] = &quot;system&quot;;
		process.env[&quot;SC_JACK_DEFAULT_OUTPUTS&quot;] = &quot;system&quot;;
		process.env[&quot;JACK_START_SERVER&quot;] = &quot;true&quot;;
		return &quot;/usr/local/bin/scsynth&quot;;
		break;
	}
}

var _options = { 
	sNumAudioBusChannels: 128,
	sNumControlBusChannels: 4096 * 0.25,
	sMaxLogins: 64,
	sMaxNodes: 1024,
    sNumInputBusChannels: 2,
	sNumOutputBusChannels: 2,
	sNumBuffers: 1024,
	sMaxSynthDefs: 8192,
    sProtocol: &quot;Udp&quot;,
	sBufLength: 64,
	sNumRGens: 64,
	sMaxWireBufs: 64,
	sPreferredSampleRate: 44100,
	sLoadGraphDefs: 0,
	sVerbosity: 0,
	sRendezvous: 0,
	sRemoteControlVolume: 0,
	sMemoryLocking: 0,
	sPreferredHardwareBufferFrameSize: 512,
	sRealTimeMemorySize: 81920, // Increased
    // sBlockSize: 512,
    // sBlockSize: 1024,
    sPortNum: 57110,
	sHost: &quot;127.0.0.1&quot;,
	sNumPrivateAudioBusChannels: 112
}

var _optionsArray = [
	&quot;-u&quot;, _options.sPortNum,
	&quot;-a&quot;, _options.sNumAudioBusChannels,
	&quot;-c&quot;, _options.sNumControlBusChannels,
	&quot;-i&quot;, _options.sNumInputBusChannels,
	&quot;-o&quot;, _options.sNumOutputBusChannels,
	&quot;-z&quot;, _options.sBlockSize,
	&quot;-Z&quot;, _options.sPreferredHardwareBufferFrameSize,
	&quot;-S&quot;, _options.sPreferredSampleRate,
	&quot;-b&quot;, _options.sNumBuffers,
	&quot;-n&quot;, _options.sMaxNodes,
	&quot;-d&quot;, _options.sMaxSynthDefs,
	&quot;-m&quot;, _options.sRealTimeMemorySize,
	&quot;-w&quot;, _options.sMaxWireBufs,
	&quot;-l&quot;, _options.sMaxLogins
];

var fs = require(&#x27;fs&#x27;);

function _startJack()
{
	return spawn(&quot;/usr/bin/jackd&quot;, [&quot;-d&quot;, &quot;alsa&quot;, &quot;-P&quot;, &quot;hw:0,0&quot;, &quot;-r&quot;, 44100], { env: process.env, stdio: [&#x27;pipe&#x27;, process.stdout, process.stderr] });
}

// var _jack = process.platform == &quot;linux&quot; ? _startJack() : null;
var _scsynthpid = spawn(getSCPath(), _optionsArray, { env: process.env, stdio: [&#x27;pipe&#x27;, process.stdout, process.stderr] });
var _currentNodeID = 1000;

var server = new _Server(_options);
var s = server;
var sampleRate = _options.sPreferredSampleRate

server.quit = function()
{
	s.sendMsg(&#x27;/quit&#x27;, []);
}

process.on(&#x27;exit&#x27;, function(code){
	console.log(&quot;quitting scsynth... &quot;);
	_scsynthpid.kill(&#x27;SIGTERM&#x27;);

	/*
	if(_jack != null)
	{
		_jack.kill(&#x27;SIGTERM&#x27;);
		var child = exec(&quot;killall jackd&quot;, function (error, stdout, stderr) {
			console.log(stdout);
			console.log(stderr);
			console.log(error);
		});

		var child2 = exec(&quot;killall jackdbus&quot;, function (error, stdout, stderr) {
			console.log(stdout);
			console.log(stderr);
			console.log(error);
		});
	}*/
});


// Wait for server to boot ... perhaps there&#x27;s a better way here.
setTimeout( // Initial messages
	function()
	{
		s.connect();
		s.sendMsg(&quot;/g_new&quot;, [1, 0, 0]); // default group
		s.sendMsg(&#x27;/notify&#x27;, [1]);
		s.sendMsg(&#x27;/status&#x27;, []);
	},
	2000
);


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nodes
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Function.prototype.inheritsFrom = function(parentClassOrObject) { 
	if(parentClassOrObject.constructor == Function) 
	{ 
		//Normal Inheritance 
		this.prototype = new parentClassOrObject;
		this.prototype.constructor = this;
		this.prototype.parent = parentClassOrObject.prototype;
	}
	
	else 
	{ 
		//Pure Virtual Inheritance 
		this.prototype = parentClassOrObject;
		this.prototype.constructor = this;
		this.prototype.parent = parentClassOrObject;
	}
	
	return this;
}

// Enum for AddAction
var AddToHead  = 0;
var AddToTail  = 1;
var AddBefore  = 2;
var AddAfter   = 3;
var AddReplace = 4;

// Node IDs for various kinds of nodes
var rootNodeID = 0;
var defaultGroupID = 1;
var grainNodeID = -1;
s.nodeID = 1; // default group

function Node()
{	
	this.freeNode = function()
	{
		s.sendMsg(&#x27;/n_free&#x27;, [this.nodeID]);
	}

	this.run = function(bool)
	{
		s.sendMsg(&#x27;/n_run&#x27;, [this.nodeID, bool]);
	}

	this.set = function(arg, val)
	{
		s.sendMsg(&#x27;/n_set&#x27;, [this.nodeID, arg, val]);
	}

	this.setList = function(argValuePairs)
	{
		s.sendMsg(&#x27;/n_set&#x27;, [this.nodeID].concat(argValuePairs));
	}

	this.release = function(releaseTime)
	{
		this.set(&quot;gate&quot;, (-1 - releaseTime));
	}

	this.trace = function()
	{
		s.sendMsg(&quot;/n_trace&quot;, [this.nodeID]);
	}

	this.moveBefore = function(node)
	{
		s.sendMsg(&quot;/n_before&quot;, [this.nodeID, node.nodeID]);
	}

	this.moveAfter = function(node)
	{
		s.sendMsg(&quot;/n_after&quot;, [this.nodeID, node.nodeID]);
	}

	this.moveToHead = function(group)
	{
		s.sendMsg(&quot;/g_head&quot;, [group.nodeID, this.nodeID]);
	}

	this.moveToTail = function(group)
	{
		s.sendMsg(&quot;/g_tail&quot;, [group.nodeID, this.nodeID]);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Group
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function Group(target, action)
{
	target = typeof target === &quot;undefined&quot; ? s : target;
	action = typeof action === &quot;undefined&quot; ? AddToHead : action;
	
	this.moveNodeTohead = function(node)
	{
		s.sendMsg(&quot;/g_head&quot;, [this.nodeID, node.nodeID]);
	}

	this.moveNodeToTail = function(node)
	{
		s.sendMsg(&quot;/g_tail&quot;, [this.nodeID, node.nodeID]);
	}

	this.freeAll = function()
	{
		s.sendMsg(&quot;/g_freeAll&quot;, [this.nodeID]);
	}

	this.deepFree = function()
	{
		s.sendMsg(&quot;/g_deepFree&quot;, [this.nodeID]);
	}

	this.dumpTree = function()
	{
		s.sendMsg(&quot;/g_dumpTree&quot;, [this.nodeID]);
	}

	this.nodeID = _currentNodeID++;
	s.sendMsg(&quot;/g_new&quot;, [this.nodeID, action, target.nodeID]);
}

Group.inheritsFrom(Node);

Group.after = function(target)
{
	return new Group(target, AddAfter);
}

Group.before = function(target)
{
	return new Group(target, AddBefore);
}

Group.head = function(target)
{
	return new Group(target, AddToHead);
}

Group.tail = function(target)
{
	return new Group(target, AddToTail);
}

Group.replace = function(target)
{
	return new Group(target, AddReplace);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Synth
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function Synth(name, args, target, action)
{
	args = typeof args === &quot;undefined&quot; ? [] : args;
	target = typeof target === &quot;undefined&quot; ? s : target;
	action = typeof action === &quot;undefined&quot; ? AddToHead : action;

	this.name = name;
	this.nodeID = _currentNodeID++;
	s.sendMsg(&quot;/s_new&quot;, [name, this.nodeID, action, target.nodeID].concat(args));
}

Synth.inheritsFrom(Node);

Synth.after = function(name, args, target)
{
	return new Synth(name, args, target, AddAfter);
}

Synth.before = function(name, args, target)
{
	return new Synth(name, args, target, AddBefore);
}

Synth.head = function(name, args, target)
{
	return new Synth(name, args, target, AddToHead);
}

Synth.tail = function(name, args, target)
{
	return new Synth(name, args, target, AddToTail);
}

Synth.replace = function(name, args, target)
{
	return new Synth(name, args, target, AddReplace);
}

// Doesn&#x27;t return a synth, just creates an instance on the server
Synth.grain = function(name, args, target, action)
{
	target = typeof target === &quot;undefined&quot; ? s : target;
	action = typeof action === &quot;undefined&quot; ? AddToHead : action;
	s.sendMsg(&quot;/s_new&quot;, [name, -1, action, target.nodeID].concat(args)); 
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// UGen
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Rate constants
var ScalarRate = 0;
var ControlRate = 1;
var AudioRate = 2;
var DemandRate = 3;

function UGen(name, rate, inputs, numOutputs, specialIndex)
{
	var self = this;
	this.name = name;
	this.rate = rate;
	this.inputs = inputs;
	this.numInputs = inputs.length;
	this.numOutputs = numOutputs;
	this.specialIndex = typeof specialIndex === &quot;undefined&quot; ? 0 : specialIndex;
	this.synthIndex = null;
	this.setSynthIndex = function(index) { self.synthIndex = index; }; 
	this.outputIndex = 0;
	this._lichType = AUDIO;
	this._collected = false; // used internally to cull duplicates in the synth graph
	this.addToSynth = true;
	this.isLocalBuf = false;
}

// Don&#x27;t indicate outputs explicity, instead we indicate this with an array of rates.
function MultiOutUGen(name, rates, inputs, specialIndex)
{
	var self = this;
	this.name = name;
	this.rate = rates[0];
	this.inputs = inputs;
	this.numOutputs = rates.length;
	this.numInputs = inputs.length;
	this.specialIndex = typeof specialIndex === &quot;undefined&quot; ? 0 : specialIndex;
	this.channels = [];

	for(var i = 0; i &lt; this.numOutputs; ++i)
	{
		self.channels.push(outputProxy(rates[i], self, i));
	}

	this.synthIndex = null;
	this.setSynthIndex = function(index) {
		self.synthIndex = index;
		for(var i = 0; i &lt; self.numOutputs; ++i)
		{
			self.channels[i].setSynthIndex(index);
		}
	};
	
	this.outputIndex = 0;
	this._lichType = AUDIO;
	this._collected = false; // used internally to cull duplicates in the synth graph
	this.addToSynth = true;
	this.isLocalBuf = false;
}

Number.prototype.setSynthIndex = function(){};

// supports multi-channel expansion
function multiNewUGen(name, rate, inputs, numOutputs, specialIndex)
{
	var size = 0;

	// Find the largest array length
	for(var i = 0; i &lt; inputs.length; ++i)
	{
		var input = inputs[i];
		
		if(input instanceof Array)
		{
			size = size &gt; input.length ? size : input.length;
		}
	}

	if(size == 0)
	{
		return new UGen(name, rate, inputs, numOutputs, specialIndex);
	}

	else
	{
		var res = [];

		for(var i = 0; i &lt; size; ++i)
		{
			var newInputs = inputs.map(function(e) {
				if(e instanceof Array)
					return e[i % e.length];
				else
					return e;
			});

			res.push(new UGen(name, rate, newInputs, numOutputs, specialIndex));
		}

		return res;
	}
}

function outputProxy(rate, sourceUGen, channel)
{
	// var u = new UGen(&quot;OutputProxy&quot;, rate, [rate, sourceUGen, input], 1, 0);
	var u = new UGen(&quot;OutputProxy&quot;, rate, [sourceUGen], 1, 0);
	u.addToSynth = false;
	u.outputIndex = channel;
	return u;
}

// !!! We indicate number of outputs using an array of rates.  !!!
function newMultiOutUGen(name, rates, inputs, specialIndex)
{
	var expandError = false;

	for(var i = 0; i &lt; inputs.length; ++i)
	{
		if(inputs[i] instanceof Array)
			throw new Error(&quot;You can&#x27;t use multi-channel expansion with: &quot; + name);
	}
	
	var mUgen = new MultiOutUGen(name, rates, inputs, specialIndex);

	return mUgen.channels; 
}
							   
////////////////////
// UGen Bindings
////////////////////

/**
 * Lich.sc UGen bindings.
 * @module Lich.sc UGens
 */

var _BIN_PLUS = 0;
var _BIN_MINUS = 1;
var _BIN_MUL = 2;
var _BIN_DIV = 4;
var _BIN_MOD = 5;
var _BIN_EQ = 6;
var _BIN_NE = 7;
var _BIN_LT = 8;
var _BIN_GT = 9;
var _BIN_LE = 10;
var _BIN_GE = 11;
var _BIN_MIN = 12;
var _BIN_MAX = 13;
var _BIN_BITAND = 14;
var _BIN_BITOR = 15;
var _BIN_BITXOR = 16;
var _BIN_LCM = 17;
var _BIN_GCD = 18;
var _BIN_ROUND = 19;
var _BIN_ROUNDUP = 20;
var _BIN_TRUNC = 21;
var _BIN_ATAN2 = 22;
var _BIN_HYPOT = 23;
var _BIN_HYPOTX = 24;
var _BIN_POW = 25;
var _BIN_SHIFTLEFT = 26;
var _BIN_SHIFTRIGHT = 27;
var _BIN_UNSIGNEDSHIFT = 28;
var _BIN_FILL = 29;
var _BIN_RING1 = 30;
var _BIN_RING2 = 31;
var _BIN_RING3 = 32;
var _BIN_RING4 = 33;
var _BIN_DIFSQR = 34;
var _BIN_SUMSQR = 35;
var _BIN_SQRSUM = 36;
var _BIN_SQRDIF = 37;
var _BIN_ABSDIF = 38;

function _binaryOpUGen(selector, a, b)
{
	var rate = ControlRate;
	
	if(a.rate == AudioRate || b.rate == AudioRate)
		rate = AudioRate;
	
	return multiNewUGen(&quot;BinaryOpUGen&quot;, rate, [a, b], 1, selector);
}

function mix2(a, b)
{
	return _binaryOpUGen(_BIN_PLUS, a, b);
}

function _subtractMix(a, b)
{
	return _binaryOpUGen(_BIN_MINUS, a, b);
}

function gain(a, b)
{
	return _binaryOpUGen(_BIN_MUL, a, b);
}

function _audioDivision(a, b)
{
	return _binaryOpUGen(_BIN_DIV, a, b);
}

var _UN_NEG = 0;
var _UN_NOT = 1;
var _UN_ISNIL = 2;
var _UN_NOTNIL = 3;
var _UN_BITNOT = 4;
var _UN_ABS = 5;
var _UN_ASFLOAT = 6;
var _UN_ASINT = 7;
var _UN_CEIL = 8;
var _UN_FLOOR = 9;
var _UN_FRAC = 10;
var _UN_SIGN = 11;
var _UN_SQUARED = 12;
var _UN_CUBED = 13;
var _UN_SQRT = 14;
var _UN_EXP = 15;
var _UN_RECIP = 16;
var _UN_MIDICPS = 17;
var _UN_CPSMIDI = 18;
var _UN_MIDIRATIO = 19;
var _UN_RATIOMIDI = 20;
var _UN_DBAMP = 21;
var _UN_AMPDB = 22;
var _UN_OCTCPS = 23;
var _UN_CPSOCT = 24;
var _UN_LOG = 25;
var _UN_LOG2 = 26;
var _UN_LOG10 = 27;
var _UN_SIN = 28;
var _UN_COS = 29;
var _UN_TAN = 30;
var _UN_ARCSIN = 31;
var _UN_ARCCOS = 32;
var _UN_ARCTAN = 33;
var _UN_SINH = 34;
var _UN_COSH = 35;
var _UN_TANH = 36;
var _UN_RAND = 37;
var _UN_RAND2 = 38;
var _UN_LINRAND = 39;
var _UN_BILINRAND = 40;
var _UN_SUM3RAND = 41;
var _UN_DISTORT = 42;
var _UN_SOFTCLIP = 43;
var _UN_COIN = 44;

function _unaryOpUGen(selector, a)
{
	var rate = ControlRate;
	
	if(a.rate == AudioRate || b.rate == AudioRate)
		rate = AudioRate;
	
	return multiNewUGen(&quot;UnaryOpUGen&quot;, rate, [a], 1, selector);
}

/**
 * Distort a signal. This is the same as using .distort in SuperCollider.
 *
 * @class scDistort
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; distort &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scDistort(a)
{
	return _unaryOpUGen(_UN_DISTORT, a);
}

/**
 * Distortions.
 * @submodule Distortions
 */

/**
 * Distortion with a perfectly linear region from -0.5 to +0.5. This is the same as using .softclip in SuperCollider.
 *
 * @class scSoftClip
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scSoftClip &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scSoftClip(a)
{
	return _unaryOpUGen(_UN_SOFTCLIP, a);
}

/**
 * Foldback distortion.
 * 
 * @class scFold
 * @constructor
 * @param lo Low boundry to fold at
 * @param hi High boundry to fold at
 * @example
 * let test l h =&gt; white 1 &gt;&gt; scFold l h &gt;&gt; out 0&lt;br&gt;
 * let t = test -0.5 0.5&lt;br&gt;
 * stop t
 */
function scFold(lo, hi, input)
{
	return multiNewUGen(&quot;Fold&quot;, AudioRate, [input,lo,hi], 1, 0);
}

/**
 * Foldback distortion.
 * 
 * @class fold
 * @constructor
 * @param level Boundry to fold at
 * @example
 * let test l =&gt; white 1 &gt;&gt; fold l &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.5&lt;br&gt;
 * stop t
 */
function fold(level, input)
{
	return multiNewUGen(&quot;Fold&quot;, AudioRate, [input,-1*level,level], 1, 0);
}

/**
 * Wrap distortion.
 * 
 * @class scWrap
 * @constructor
 * @param lo Low boundry to wrap at
 * @param hi High boundry to wrap at
 * @example
 * let test l h =&gt; white 1 &gt;&gt; scWrap l h &gt;&gt; out 0&lt;br&gt;
 * let t = test -0.5 0.5&lt;br&gt;
 * stop t
 */
function scWrap(lo, hi, input)
{
	return multiNewUGen(&quot;Wrap&quot;, AudioRate, [input,lo,hi], 1, 0);
}

/**
 * Wrap distortion.
 * 
 * @class wrap
 * @constructor
 * @param level Boundry to wrap at
 * @example
 * let test l =&gt; white 1 &gt;&gt; wrap l &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.5&lt;br&gt;
 * stop t
 */
function wrap(level, input)
{
	return multiNewUGen(&quot;Wrap&quot;, AudioRate, [input,-1*level,level], 1, 0);
}

/**
 * Clip distortion.
 * 
 * @class scClip
 * @constructor
 * @param lo Low boundry to clip at
 * @param hi High boundry to clip at
 * @example
 * let test l h =&gt; white 1 &gt;&gt; scClip l h &gt;&gt; out 0&lt;br&gt;
 * let t = test -0.5 0.5&lt;br&gt;
 * stop t
 */
function scClip(lo, hi, input)
{
	return multiNewUGen(&quot;Clip&quot;, AudioRate, [input,lo,hi], 1, 0);
}

/**
 * Clip distortion.
 * 
 * @class clip
 * @constructor
 * @param level Boundry to clip at
 * @example
 * let test l =&gt; white 1 &gt;&gt; clip l &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.5&lt;br&gt;
 * stop t
 */
function clip(level, input)
{
	return multiNewUGen(&quot;Clip&quot;, AudioRate, [input,-1*level,level], 1, 0);
}

/**
 * Return the inverse of a signal.
 *
 * @class scNeg
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scNeg &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scNeg(a)
{
	return _unaryOpUGen(_UN_NEG, a);
}

/**
 * Signal Math. TODO: fix all the examples
 * @submodule Signal Math
 */

/**
 * Return the absolute value of a signal.
 *
 * @class scAbs
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scAbs &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scAbs(a)
{
	return _unaryOpUGen(_UN_ABS, a);
}

/**
 * Return the ceil of a signal.
 *
 * @class scCeil
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scCeil &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scCeil(a)
{
	return _unaryOpUGen(_UN_CEIL, a);
}

/**
 * Return the floor of a signal.
 *
 * @class scFloor
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scFloor &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scFloor(a)
{
	return _unaryOpUGen(_UN_FLOOR, a);
}

/**
 * Return the square of a signal.
 *
 * @class scSquared
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scSquared &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scSquared(a)
{
	return _unaryOpUGen(_UN_SQUARED, a);
}

/**
 * Return the cube of a signal.
 *
 * @class scCubed
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scCubed &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scCubed(a)
{
	return _unaryOpUGen(_UN_CUBED, a);
}

/**
 * Return the square root of a signal.
 *
 * @class scSqrt
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scSqrt &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scSqrt(a)
{
	return _unaryOpUGen(_UN_SQRT, a);
}

/**
 * Return the reciprocal of a signal.
 *
 * @class scReciprocal
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scReciprocal &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scReciprocal(a)
{
	return _unaryOpUGen(_UN_RECIP, a);
}

/**
 * Convert a value from cycles per second to MIDI.
 *
 * @class scCpsMidi
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scCpsMidi &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scCpsMidi(a)
{
	return _unaryOpUGen(_UN_CPSMIDI, a);
}

/**
 * Convert a value from MIDI to cycles per second.
 *
 * @class scMidiCps
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scMidiCps &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scMidiCps(a)
{
	return _unaryOpUGen(_UN_MIDICPS, a);
}

/**
 * Convert a value dB to RMS amplitude.
 *
 * @class scDbAmp
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scDbAmp &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scDbAmp(a)
{
	return _unaryOpUGen(_UN_DBAMP, a);
}

/**
 * Convert a value RMS amplitude to dB.
 *
 * @class scAmpDb
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scAmpDb &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scAmpDb(a)
{
	return _unaryOpUGen(_UN_DBAMP, a);
}

/**
 * Return the log of a signal.
 *
 * @class scLog
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scLog &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scLog(a)
{
	return _unaryOpUGen(_UN_LOG, a);
}

/**
 * Return the log2 of a signal.
 *
 * @class scLog2
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scLog2 &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scLog2(a)
{
	return _unaryOpUGen(_UN_LOG2, a);
}

/**
 * Return the log10 of a signal.
 *
 * @class scLog10
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scLog10 &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scLog10(a)
{
	return _unaryOpUGen(_UN_LOG10, a);
}

/**
 * Return the sin of a signal.
 *
 * @class scSin
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scSin &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scSin(a)
{
	return _unaryOpUGen(_UN_SIN, a);
}

/**
 * Return the cos of a signal.
 *
 * @class scCos
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scCos &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scCos(a)
{
	return _unaryOpUGen(_UN_COS, a);
}

/**
 * Return the tan of a signal.
 *
 * @class scTan
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scTan &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scTan(a)
{
	return _unaryOpUGen(_UN_TAN, a);
}

/**
 * Return the arc sin of a signal.
 *
 * @class scASin
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scASin &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scASin(a)
{
	return _unaryOpUGen(_UN_ARCSIN, a);
}

/**
 * Return the arc cos of a signal.
 *
 * @class scACos
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scACos &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scACos(a)
{
	return _unaryOpUGen(_UN_ARCCOS, a);
}

/**
 * Return the arc tan of a signal.
 *
 * @class scATan
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scATan &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scATan(a)
{
	return _unaryOpUGen(_UN_ARCTAN, a);
}

/**
 * Return the sinh of a signal.
 *
 * @class scSinh
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scSinh &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scSinh(a)
{
	return _unaryOpUGen(_UN_SINH, a);
}

/**
 * Return the cosh of a signal.
 *
 * @class scCosh
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scCosh &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scCosh(a)
{
	return _unaryOpUGen(_UN_COSH, a);
}

/**
 * Return the tanh of a signal.
 *
 * @class scTanh
 * @constructor
 * @example
 * let test amp =&gt; sin 440 &gt;&gt; gain amp &gt;&gt; scTanh &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scTanh(a)
{
	return _unaryOpUGen(_UN_TANH, a);
}

/**
 * Return the modulo of two signals. a % b
 *
 * @class scMod
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scMod(a, b)
{
	return _binaryOpUGen(_BIN_MOD, a, b);
}

/**
 * Return the signal rounded to the nearest value of b.
 *
 * @class scRound
 * @constructor
 * @param a Signal a
 * @param b Value to round to
 * @example
 * TODO
 */
function scRound(a, b)
{
	return _binaryOpUGen(_BIN_ROUND, a, b);
}

/**
 * Return the signal to the power of b.
 *
 * @class scPow
 * @constructor
 * @param a Signal a
 * @param b Value to round to
 * @example
 * TODO
 */
function scPow(a, b)
{
	return _binaryOpUGen(_BIN_POW, a, b);
}

/**
 * Map a UGen&#x27;s output to between lo and hi
 *
 * @class range
 * @constructor
 * @param lo Lowest mapped value
 * @param hi Highest mapped value
 * @param input UGen to be mapped
 * @example
 * let test l h =&gt; sin (sin 1 &gt;&gt; range l h) &gt;&gt; out 0&lt;br&gt; 
 * let t = test 440 880&lt;br&gt;
 * stop t
 */
function range(lo,hi,input)
{
    var mul;
    mul = _binaryOpUGen( _BIN_MUL, _binaryOpUGen( _BIN_MINUS, hi, lo ), 0.5 );

	return _binaryOpUGen( _BIN_PLUS, _binaryOpUGen( _BIN_MUL, input, mul ) ,lo );
}

/**
 * Map a linear range to an other linear range
 *
 * @class linlin
 * @constructor
 * @param inlo Lowest input value
 * @param inhi Highest input value
 * @param outlo Lowest output value
 * @param outhi Highest output value
 * @param input UGen to be mapped
 * @example
 * let test l h =&gt; sin (sin 1 &gt;&gt; linlin -0.1 0.1 l h) &gt;&gt; out 0&lt;br&gt; 
 * let t = test 440 880&lt;br&gt;
 * stop t
 */
function linlin(inlo,inhi,outlo,outhi,input)
{
    var scale, offset;
    scale = _binaryOpUGen(
            _BIN_DIV,
            _binaryOpUGen( _BIN_MINUS, outhi,outlo),
            _binaryOpUGen( _BIN_MINUS, inhi,inlo)
            );

    offset = _binaryOpUGen( _BIN_MINUS, outlo, _binaryOpUGen( _BIN_MUL, scale, inlo ) );

    return _binaryOpUGen( _BIN_PLUS, _binaryOpUGen( _BIN_MUL, input, scale ) ,offset );
}

/**
 * Map a liner range to an exponential range.
 *
 * @class linexp
 * @constructor
 * @param inlo Lowest input value
 * @param inhi Highest input value
 * @param outlo Lowest output value
 * @param outhi Highest output value
 * @param input UGen to be mapped
 * @example
 * let test l h =&gt; sin (sin 1 &gt;&gt; linexp -0.1 0.1 l h) &gt;&gt; out 0&lt;br&gt; 
 * let t = test 440 880&lt;br&gt;
 * stop t
 */
function linexp(inlo,inhi,outlo,outhi,input)
{
	return multiNewUGen(&quot;LinExp&quot;, AudioRate, [input,inlo,inhi,outlo,outhi], 1, 0);
}

/**
 * Bitwise &amp; a signal.
 *
 * @class scBitAnd
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scBitAnd(a, b)
{
	return _binaryOpUGen(_BIN_BITAND, a, b);
}

/**
 * Bitwise Operators. TODO: fix all examples
 * @submodule Bitwise Operators
 */

/**
 * Bitwise | a signal.
 *
 * @class scBitOr
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scBitOr(a, b)
{
	return _binaryOpUGen(_BIN_BITOR, a, b);
}

/**
 * Bitwise xor a signal.
 *
 * @class scBitXor
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scBitXor(a, b)
{
	return _binaryOpUGen(_BIN_BITXOR, a, b);
}

/**
 * Bitwise &lt;&lt; a signal.
 *
 * @class scBitLeftShift
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scBitLeftShift(a, b)
{
	return _binaryOpUGen(_BIN_SHIFTLEFT, a, b);
}

/**
 * Bitwise &gt;&gt; a signal.
 *
 * @class scBitRightShift
 * @constructor
 * @param a Signal a
 * @param b Signal b
 * @example
 * TODO
 */
function scBitRightShift(a, b)
{
	return _binaryOpUGen(_BIN_SHIFTRIGHT, a, b);
}

/**
 * Generate a random number with uniform distribution when synth starts playing.
 *
 * @class scRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @example
 * let test a =&gt; sin (scRand 220 440) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scRand(lo,hi)
{
	return multiNewUGen(&quot;Rand&quot;, ScalarRate, [lo,hi], 1, 0);
}

/**
 * Generate a random number with distribution based on the sum of n random numbers when synth starts playing.
 *
 * @class scNRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @param n Number of random numbers to sum. 1 = uniform distribution, 2 = triangular, etc. Higher numbers approach gaussian
 * @example
 * let test a =&gt; sin (scNRand 220 440 4) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scNRand(lo,hi,n)
{
	return multiNewUGen(&quot;NRand&quot;, ScalarRate, [lo,hi,n], 1, 0);
}

/**
 * Random Number Generators.
 * @submodule Random
 */

/**
 * Generate a random number with linear distribution when synth starts playing.
 *
 * @class scLinRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @example
 * let test a =&gt; sin (scLinRand 220 440) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scLinRand(lo,hi)
{
    return multiNewUGen(&quot;LinRand&quot;, ScalarRate, [lo,hi], 1, 0);
}

/**
 * Generate a random integer with uniform distribution when synth starts playing.
 *
 * @class scIRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @example
 * let test a =&gt; sin (scIRand 220 440) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scIRand(lo,hi)
{
	return multiNewUGen(&quot;IRand&quot;, ScalarRate, [lo,hi], 1, 0);
}


/**
 * Generate a random number with exponential distribution when synth starts playing.
 *
 * @class scExpRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @example
 * let test a =&gt; sin (scExpRand 220 440) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scExpRand(lo,hi)
{
    return multiNewUGen(&quot;ExpRand&quot;, ScalarRate, [lo,hi], 1, 0);
}

/**
 * Generate a random number with uniform distribution on each trigger.
 *
 * @class scTRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @param trigger A trigger happens when the signal changes from non-positive to positive
 * @example
 * let test a =&gt; sin (scTRand 220 440 (impulse 1)) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scTRand(lo,hi,trigger)
{
	return multiNewUGen(&quot;TRand&quot;, AudioRate, [lo,hi,trigger], 1, 0);
}

/**
 * Generate a random integer with uniform distribution on each trigger.
 *
 * @class scTIRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @param trigger A trigger happens when the signal changes from non-positive to positive
 * @example
 * let test a =&gt; sin (scTIRand 220 440 (impulse 1)) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scTIRand(lo,hi,trigger)
{
	return multiNewUGen(&quot;TIRand&quot;, AudioRate, [lo,hi,trigger], 1, 0);
}

/**
 * Generate a random number with exponential distribution on each trigger.
 *
 * @class scTExpRand
 * @constructor
 * @param lo Lowest possible value
 * @param hi Highest possible value
 * @param trigger A trigger happens when the signal changes from non-positive to positive
 * @example
 * let test a =&gt; sin (scTExpRand 220 440 (impulse 1)) &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function scTExpRand(lo,hi,trigger)
{
	return multiNewUGen(&quot;TExpRand&quot;, AudioRate, [lo,hi,trigger], 1, 0);
}

/**
 * Triggerable steps at a given interval between minimum and maximum values.
 *
 * @class stepper
 * @constructor
 * @param min Lowest possible value
 * @param max Highest possible value
 * @param step The range by which each step will jump.
 * @param trigger A trigger happens when the signal changes from non-positive to positive
 * @example
 * let stepSynth stepFreq =&gt; sin freq &gt;&gt; dup &gt;&gt; gain 0.3 &gt;&gt; out 0
 *   where
 *       freq = stepper 220 440 20 (impulse stepFreq)
 *
 * let stSynth = stepSynth 4
 * stop stSynth
 */
function stepper(min, max, step, trig)
{
	return multiNewUGen(&quot;Stepper&quot;, AudioRate, [trig, 0, min, max, step, min], 1, 0); 
}

function _findName(input)
{
	var label = &quot;&quot;;

	if(input instanceof Array)
		label = input.map(function(e) { return _findName(e); });
	else if(input instanceof UGen || input instanceof MultiOutUGen)
		label = input.name;
	else
		label += input;

	if(label instanceof Array)
		return label.join(&quot;, &quot;);
	else
		return label;
}

/**
 * Prints values from a UGen, but passes the input back out. This expensive, so only use for testing.
 *
 * @class poll
 * @constructor
 * @param input The input to poll.
 * @example
 * let pollSynth freq =&gt; sin freq &gt;&gt; poll &gt;&gt; out 0
 * let ps = pollSynth 0.5
 * stop ps
 */
function poll(input)
{
	var label = _findName(input);

	label = label.split(&quot;&quot;).map(function(e){ return e.charCodeAt(0)});

	var pollUGen = multiNewUGen(&quot;Poll&quot;, AudioRate, [impulse(5), input, -1, label.length].concat(label), 1, 0);

	// make pull ugen reachable by using it in a function (pollUGen * 0), but only input will output values.
	return _binaryOpUGen(_BIN_PLUS, _binaryOpUGen(_BIN_MUL, pollUGen, 0), input); 
}

/**
 * Output a constant value
 *
 * @class dc
 * @constructor
 * @param value Value to be output
 * @example
 * let test value =&gt; dc value &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function dc(value)
{
	return multiNewUGen(&quot;DC&quot;, AudioRate, [value], 1, 0);
}

/**
 * Oscillators.
 * @submodule Oscillators
 */

/**
 * A sine wave oscillator.
 *
 * @class sin
 * @constructor
 * @param freq Frequency
 * @example
 * let test f =&gt; sin f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function sin(freq)
{
	return multiNewUGen(&quot;SinOsc&quot;, AudioRate, [freq, 0], 1, 0);
}

/**
 * A sine wave oscillator with phase input.
 *
 * @class sinP
 * @constructor
 * @param freq Frequency
 * @param phase Phase
 * @example
 * TODO
 */
function sinP(freq,phase)
{
	return multiNewUGen(&quot;SinOsc&quot;, AudioRate, [freq, phase], 1, 0);
}

/**
 * A saw wave oscillator.
 *
 * @class saw 
 * @constructor
 * @param freq Frequency
 * @example
 * let test f =&gt; saw f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function saw(freq)
{
	return multiNewUGen(&quot;Saw&quot;, AudioRate, [freq], 1, 0);
}

/**
 * A triangle wave oscillator.
 *
 * @class tri
 * @constructor
 * @param freq Frequency
 * @example
 * let test f =&gt; tri f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function tri(freq)
{
	return multiNewUGen(&quot;LFTri&quot;, AudioRate, [freq,0], 1, 0);
}

/**
 * A square wave oscillator.
 *
 * @class square
 * @constructor
 * @param freq Frequency
 * @example
 * let test f =&gt; square f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function square(freq)
{
	return multiNewUGen(&quot;Pulse&quot;, AudioRate, [freq,0.5], 1, 0);
}

/**
 * A pulse wave oscillator with variable duty cycle.
 *
 * @class pulse
 * @constructor
 * @param freq Frequency
 * @param width Pulse width from 0.0 to 1.0
 * @example
 * let test f w =&gt; pulse f w &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 0.2&lt;br&gt;
 * stop t
 */
function pulse(freq,width)
{
	return multiNewUGen(&quot;Pulse&quot;, AudioRate, [freq,width], 1, 0);
}

/**
 * An oscillator with a variable number of harmonics of equal amplitude.
 *
 * @class blip
 * @constructor
 * @param freq Frequency
 * @param nharm Number of harmonics
 * @example
 * let test f n =&gt; blip f n &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 5&lt;br&gt;
 * stop t
 */
function blip(freq,nharm)
{
	return multiNewUGen(&quot;Blip&quot;, AudioRate, [freq,nharm], 1, 0);
}

/**
 * Generates a set of harmonics around a formant frequency at a given fundamental frequency.
 *
 * @class formant
 * @constructor
 * @param fundf Fundamental frequency
 * @param formf Formant frequency
 * @param bwf Pulse width frequency. Must be &gt;= fundf.
 * @example
 * let test fund form bwf =&gt; blip fund form bwf &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 1760 880&lt;br&gt;
 * stop t
 */
function formant(fundf,formf,bwf)
{
	return multiNewUGen(&quot;Formant&quot;, AudioRate, [fundf,formf,bwf], 1, 0);
}

/**
 * Generates single sample impulses at a frequency.
 *
 * @class impulse
 * @constructor
 * @param freq Frequency
 * @example
 * let test f =&gt; impulse f &gt;&gt; out 0&lt;br&gt;
 * let t = test 5&lt;br&gt;
 * stop t
 */
function impulse(freq)
{
	return multiNewUGen(&quot;Impulse&quot;, AudioRate, [freq,0], 1, 0);
}

/**
 * White noise generator.
 *
 * @class white 
 * @constructor
 * @param amp Amplitude of the noise
 * @example
 * let test a =&gt; white a &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function white(amp)
{
	return _binaryOpUGen(_BIN_MUL, multiNewUGen(&quot;WhiteNoise&quot;, AudioRate, [], 1, 0), amp);
}

/**
 * Noise.
 * @submodule Noise
 */

/**
 * Pink noise generator.
 *
 * @class pink
 * @constructor
 * @param amp Amplitude of the noise
 * @example
 * let test a =&gt; pink a &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function pink(amp)
{
	return _binaryOpUGen(_BIN_MUL, multiNewUGen(&quot;PinkNoise&quot;, AudioRate, [], 1, 0), amp);
}

/**
 * Brownian noise generator.
 *
 * @class brown
 * @constructor
 * @param amp Amplitude of the noise
 * @example
 * let test a =&gt; brown a &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function brown(amp)
{
	return _binaryOpUGen(_BIN_MUL, multiNewUGen(&quot;BrownNoise&quot;, AudioRate, [], 1, 0), amp);
}

/**
 * Gray noise generator.
 *
 * @class gray
 * @constructor
 * @param amp Amplitude of the noise
 * @example
 * let test a =&gt; gray a &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function gray(amp)
{
	return _binaryOpUGen(_BIN_MUL, multiNewUGen(&quot;GrayNoise&quot;, AudioRate, [], 1, 0), amp);
}

/**
 * Generates noise whose values are either -1 or 1.
 *
 * @class clipNoise
 * @constructor
 * @param amp Amplitude of the noise
 * @example
 * let test a =&gt; clipNoise a &gt;&gt; out 0&lt;br&gt;
 * let t = test 1&lt;br&gt;
 * stop t
 */
function clipNoise(amp)
{
	return _binaryOpUGen(_BIN_MUL, multiNewUGen(&quot;ClipNoise&quot;, AudioRate, [], 1, 0), amp);
}

/**
 * A noise generator based on a chaotic function.
 *
 * @class crackle
 * @constructor
 * @param chaos A parameter of the chaotic function with useful values from just below 1.0 to just above 2.0. Towards 2.0 the sound crackles.
 * @example
 * let test c =&gt; crackle c &gt;&gt; out 0&lt;br&gt;
 * let t = test 1.5&lt;br&gt;
 * stop t
 */
function crackle(chaos)
{
	return multiNewUGen(&quot;Crackle&quot;, AudioRate, [chaos], 1, 0);
}

/**
 * When CoinGate receives a trigger, it tosses a coin and either passes the trigger or doesn&#x27;t.
 *
 * @class coingate
 * @constructor
 * @param probability Value between 0.0 and 1.0 for chance of passing the trigger
 * @param input The trigger
 * @example
 * let test p =&gt; sin (scTRand 440 880 (coingate p (impulse 2))) &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.5&lt;br&gt;
 * stop t
 */
function coingate(probability,input)
{
	return multiNewUGen(&quot;CoinGate&quot;, AudioRate, [probability,input], 1, 0);
}

/**
 * Generates random impulses from 0 to +1.
 *
 * @class dust
 * @constructor
 * @param density Average number of impulses per second.
 * @example
 * let test d =&gt; dust d &gt;&gt; out 0&lt;br&gt;
 * let t = test 1.5&lt;br&gt;
 * stop t
 */
function dust(density)
{
	return multiNewUGen(&quot;Dust&quot;, AudioRate, [density], 1, 0);
}

/**
 * Generates random impulses from -1 to +1.
 *
 * @class dust2
 * @constructor
 * @param density Average number of impulses per second.
 * @example
 * let test d =&gt; dust2 d &gt;&gt; out 0&lt;br&gt;
 * let t = test 1.5&lt;br&gt;
 * stop t
 */
function dust2(density)
{
	return multiNewUGen(&quot;Dust2&quot;, AudioRate, [density], 1, 0);
}

/**
 * Generates impulses centered around a frequency with gaussian distribution.
 *
 * @class gausstrig
 * @constructor
 * @param freq Mean frequency
 * @param dev Random deviation from mean (0 &lt;= dev &lt; 1)
 * @example
 * let test d =&gt; sin (scTRand 440 880 (gausstrig 2 d)) &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.2&lt;br&gt;
 * stop t
 */
function gausstrig(freq,dev)
{
	return multiNewUGen(&quot;GaussTrig&quot;, AudioRate, [freq,dev], 1, 0);
}

/**
 * A stepped random number generator
 *
 * @class noiseN
 * @constructor
 * @param freq Frequency of random number generation
 * @example
 * let test f =&gt; noiseN f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function noiseN(freq)
{
	return multiNewUGen(&quot;LFNoise0&quot;, AudioRate, [freq], 1, 0);
}

/**
 * A linearly interpolated random number generator
 *
 * @class noiseL
 * @constructor
 * @param freq Frequency of random number generation
 * @example
 * let test f =&gt; noiseL f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function noiseL(freq)
{
	return multiNewUGen(&quot;LFNoise1&quot;, AudioRate, [freq], 1, 0);
}

/**
 * A cubic interpolated random number generator
 *
 * @class noiseX
 * @constructor
 * @param freq Frequency of random number generation
 * @example
 * let test f =&gt; noiseX f &gt;&gt; out 0&lt;br&gt;
 * let t = test 440&lt;br&gt;
 * stop t
 */
function noiseX(freq)
{
	return multiNewUGen(&quot;LFNoise2&quot;, AudioRate, [freq], 1, 0);
}

/**
 * A non-interpolating sound generator based on the difference equation: x[n+1] = a - b * sqrt(abs(x[n]))
 *
 * @class cuspN 
 * @constructor
 * @param freq Frequency
 * @param a Equation variable
 * @param b Equation variable
 * @param xi Initial value of x
 * @example
 * let test f a b xi =&gt; cuspN f a b xi &gt;&gt; out 0&lt;br&gt;
 * let t = test 22050 1 1.9 0&lt;br&gt;
 * stop t
 */
function cuspN(freq,a,b,xi)
{
	return multiNewUGen(&quot;CuspN&quot;, AudioRate, [freq,a,b,xi], 1, 0);
}

/**
 * Chaotic Oscillators.
 * @submodule Chaos
 */

/**
 * A linearly interpolating sound generator based on the difference equation: x[n+1] = a - b * sqrt(abs(x[n]))
 *
 * @class cuspL 
 * @constructor
 * @param freq Frequency
 * @param a Equation variable
 * @param b Equation variable
 * @param xi Initial value of x
 * @example
 * let test f a b xi =&gt; cuspL f a b xi &gt;&gt; out 0&lt;br&gt;
 * let t = test 22050 1 1.9 0&lt;br&gt;
 * stop t
 */
function cuspL(freq,a,b,xi)
{
	return multiNewUGen(&quot;CuspL&quot;, AudioRate, [freq,a,b,xi], 1, 0);
}

/**
 * A non-interpolating sound generator based on the difference equation: x[n+1] = 1 - y[n] + abs(x[n]); y[n+1] = x[n];
 *
 * @class gbmanN
 * @constructor
 * @param freq Frequency
 * @param xi Initial value of x
 * @param yi Initial value of y
 * @example
 * let test f xi yi =&gt; gbmanN f xi yi &gt;&gt; out 0&lt;br&gt;
 * let t = test 22050 1.2 2.1&lt;br&gt;
 * stop t
 */
function gbmanN(freq,xi,yi)
{
	return multiNewUGen(&quot;GbmanN&quot;, AudioRate, [freq,xi,yi], 1, 0);
}

/**
 * A linearly interpolating sound generator based on the difference equation: x[n+1] = 1 - y[n] + abs(x[n]); y[n+1] = x[n];
 *
 * @class gbmanL
 * @constructor
 * @param freq Frequency
 * @param xi Initial value of x
 * @param yi Initial value of y
 * @example
 * let test f xi yi =&gt; gbmanL f xi yi &gt;&gt; out 0&lt;br&gt;
 * let t = test 22050 1.2 2.1&lt;br&gt;
 * stop t
 */
function gbmanL(freq,xi,yi)
{
	return multiNewUGen(&quot;GbmanL&quot;, AudioRate, [freq,xi,yi], 1, 0);
}

/**
 * A low pass filter.
 * 
 * @class lowpass
 * @constructor
 * @param freq Cutoff frequency for the filter
 * @param q Quality of the filter
 * @example
 * let test f q =&gt; white 1 &gt;&gt; lowpass f q &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 10&lt;br&gt;
 * stop t
 */
function lowpass(freq, q, input)
{
	return multiNewUGen(&quot;RLPF&quot;, AudioRate, [input,freq,1/q], 1, 0);
}

/**
 * Filters.
 * @submodule Filters
 */

/**
 * Removes DC offset from a signal.
 * 
 * @class leakdc
 * @constructor
 * @param coef Leak coefficient
 * @param input Input signal
 * @example
 * let test c =&gt; white 1 &gt;&gt; leakdc c &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.995&lt;br&gt;
 * stop t
 */
function leakdc(coef, input)
{
	return multiNewUGen(&quot;LeakDC&quot;, AudioRate, [input,coef], 1, 0);
}

/**
 * Removes DC offset from a signal with a default coefficient.
 * 
 * @class leakdc1
 * @constructor
 * @param input Input signal
 * @example
 * let test a =&gt; white a &gt;&gt; leakdc &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.5&lt;br&gt;
 * stop t
 */
function leakdc1(input)
{
	return multiNewUGen(&quot;LeakDC&quot;, AudioRate, [input,0.995], 1, 0);
}

/**
 * A high pass filter.
 * 
 * @class highpass
 * @constructor
 * @param freq Cutoff frequency for the filter
 * @param q Quality of the filter
 * @example
 * let test f q =&gt; white 1 &gt;&gt; highpass f q &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 10&lt;br&gt;
 * stop t
 */
function highpass(freq, q, input)
{
	return multiNewUGen(&quot;RHPF&quot;, AudioRate, [input,freq,1/q], 1, 0);
}

/**
 * A band pass filter.
 * 
 * @class bandpass 
 * @constructor
 * @param freq Cutoff frequency for the filter
 * @param q Quality of the filter
 * @example
 * let test f q =&gt; white 1 &gt;&gt; bandpass f q &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 10&lt;br&gt;
 * stop t
 */
function bandpass(freq, q, input)
{
	return multiNewUGen(&quot;BPF&quot;, AudioRate, [input,freq,1/q], 1, 0);
}

/**
 * Digitally modeled analog filter.
 * 
 * @class dfm1
 * @constructor
 * @param freq Cutoff frequency for the filter
 * @param q Quality of the filter
 * @param inputgain Gain on the input signal
 * @param type 0 for lowpass, 1 for highpass
 * @param noiselevel Amplitude of noise added to the model
 * @param input Signal to be filtered
 * @example
 * TODO
 */
function dfm1(freq, q, inputgain, type, noiselevel, input)
{
	return multiNewUGen(&quot;DFM1&quot;, AudioRate, [input,freq,1/q,inputgain,type,noiselevel], 1, 0);
}

/**
 * Ramp a signal between two values over time.
 *
 * @class lag
 * @constructor
 * @param lagtime Ramp time in seconds
 * @example
 * let test lagtime =&gt; noiseN 100 &gt;&gt; lag lagtime &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.001&lt;br&gt;
 * stop t
 */
function lag(lagtime, input)
{
	return multiNewUGen(&quot;Lag&quot;, AudioRate, [input,lagtime], 1, 0);
}

/**
 * Bit crush a signal.
 *
 * @class crush
 * @constructor
 * @param bits Bitdepth of resulting signal (1-64)
 * @example
 * let test b =&gt; sin 440 &gt;&gt; crush b &gt;&gt; out 0&lt;br&gt;
 * let t = test 4&lt;br&gt;
 * stop t
 */
function crush(bits, input)
{
	return multiNewUGen(&quot;Decimator&quot;, AudioRate, [input,44100,bits], 1, 0);
}

/**
 * Sample rate reduction on a signal.
 *
 * @class decimate
 * @constructor
 * @param rate Sample rate of resulting signel (1-44100)
 * @example
 * let test r =&gt; sin 440 &gt;&gt; decimate r &gt;&gt; out 0&lt;br&gt;
 * let t = test 11000&lt;br&gt;
 * stop t
 */
function decimate(rate, input)
{
	return multiNewUGen(&quot;Decimator&quot;, AudioRate, [input,rate,64], 1, 0);
}

/**
 * General purpose (hard-knee) dynamics processor.
 *
 * @class compander
 * @constructor
 * @param control Control signal. Same as input for compression, different for ducking.
 * @param thresh Control signal amplitude threshold.
 * @param slopeBelow Compression slope below the threshold
 * @param slopeAbove Compression slope above the threshold
 * @param clampTime Time until compression fully active
 * @param relaxTime Time until compression fully inactive
 * @param input The signal to be compressed
 * @example
 * TODO
 */
 function compander(control,thresh,slopeBelow,slopeAbove,clampTime,relaxTime,input)
{
	return multiNewUGen(&quot;Compander&quot;, AudioRate, [control,thresh,slopeBelow,slopeAbove,clampTime,relaxTime,input], 1, 0);
}

/**
 * Limits the amplitude of the the input to a given level.
 *
 * @class limiter 
 * @constructor
 * @param level Amplitude level to limit input to
 * @param dur Lookahead time
 * @param input Signal to be limited
 * @example
 * TODO
 */
function limiter(level,dur,input)
{
	return multiNewUGen(&quot;Limiter&quot;, AudioRate, [input,level,dur], 1, 0);
}

/**
 * A time domain granular pitch shifter. Grains have a triangular amplitude envelope and an overlap of 4:1.
 *
 * @class pitchshift
 * @constructor
 * @param windowSize Grain window size
 * @param pitchRatio Ratio of the pitch shift. Between 0 and 4
 * @param pitchDispersion Maximum random deviation from the pitchRatio
 * @param timeDispersion Random time offset of each grain
 * @param input Signal to be pitch shifted
 * @example
 * TODO
 */
function pitchshift(windowSize,pitchRatio,pitchDispersion,timeDispersion,input)
{
	return multiNewUGen(&quot;PitchShift&quot;, AudioRate, [windowSize,pitchRatio,pitchDispersion,timeDispersion,input], 1, 0);
}

/**
 * Single sideband amplitude modulation based frequency shifting.
 *
 * @class freqshift
 * @constructor
 * @param freq Shift amount in Hz
 * @param phase Amount of phase
 * @param input Signal to be limited
 * @example
 * TODO
 */
function freqshift(freq,phase,input)
{
	return multiNewUGen(&quot;FreqShift&quot;, AudioRate, [input,freq,phase], 1, 0);
}

/**
 * Simple single channel reverb.
 *
 * @class freeverb
 * @constructor
 * @param mix Dry/wet balanece from 0-1
 * @param room Room size from 0-1
 * @param damp High frequency damping from 0-1
 * @param input Input signal
 * @example
 * TODO
 */
function freeverb(mix,room,damp,input)
{
	return multiNewUGen(&quot;FreeVerb&quot;, AudioRate, [input,mix,room,damp], 1, 0);
}
/**
 * Two channel reverb.
 *
 * @class gverb
 * @constructor
 * @param roomsize In squared meters
 * @param revtime In seconds
 * @param damping 0 to 1, high frequency rolloff, 0 damps the reverb signal completely, 1 not at all
 * @param inputbw 0 to 1, same as damping control, but on the input signal
 * @param spread A control on the stereo spread and diffusion of the reverb signal
 * @param drylevel Amount of dry signal
 * @param earlyreflevel Amount of early reflection level
 * @param taillevel Amount of tail level
 * @param maxroomsize To set the size of the delay lines
 * @param input
 * @example
 * let test f =&gt; impulse f &gt;&gt; gverb 10 3 0.5 0.5 15 1 0.7 0.5 11 &gt;&gt; out 0
 * let t = test 1
 * stop t
 */

function gverb(roomsize, revtime, damping, inputbw, spread, drylevel, earlyreflevel, taillevel, maxroomsize, input)
{
	return newMultiOutUGen(&quot;GVerb&quot;, [AudioRate, AudioRate], [input, roomsize, revtime, damping, inputbw, spread, drylevel, earlyreflevel, taillevel, maxroomsize], 0);
}

/**
 * An allpass delay line with no interpolation.
 * 
 * @class allpassN
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; allpassN del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */

function allpassN(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;AllpassN&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * Delays.
 * @submodule Delays
 */

/**
 * An allpass delay line with no interpolation. This version uses a localBuf.
 *
 * @class bufAllpassN 
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufAllpassN (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufAllpassN(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufAllpassN&quot;, AudioRate, [input,buf,del,decay], 1, 0);
}

/**
 * An allpass delay line with linear interpolation.
 *
 * @class allpassL
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; allpassL del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function allpassL(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;AllpassL&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * An allpass delay line with linear interpolation. This version uses a localBuf.
 *
 * @class bufAllpassL 
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufAllpassL (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufAllpassL(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufAllpassL&quot;, AudioRate, [input,buf,del,decay], 1, 0);
}

/**
 * An allpass delay line with cubic interpolation.
 *
 * @class allpassC 
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; allpassC del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function allpassC(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;AllpassC&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * An allpass delay line with cubic interpolation. This version uses a localBuf.
 *
 * @class bufAllpassC 
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufAllpassC (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufAllpassC(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufAllpassC&quot;, AudioRate, [input,buf,del,decay], 1, 0);
}

/**
 * A comb delay line with no interpolation.
 *
 * @class combN
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; combN del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function combN(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;CombN&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * A comb delay line with no interpolation. This version uses a localBuf.
 *
 * @class bufCombN
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time in seconds for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufCombN (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufCombN(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufCombN&quot;, AudioRate, [buf, input, del, decay], 1, 0);
}

/**
 * A comb delay line with linear interpolation.
 *
 * @class combL
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; combL del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function combL(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;CombL&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * A comb delay line with cubic linear interpolation. This version uses a localBuf.
 *
 * @class bufCombL
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time in seconds for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufCombL (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufCombL(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufCombL&quot;, AudioRate, [buf, input, del, decay], 1, 0);
}

/**
 * A comb delay line with cubic interpolation.
 *
 * @class combC
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @param decay Time in seconds for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; combC del del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function combC(maxDel, del, decay, input)
{
	return multiNewUGen(&quot;CombC&quot;, AudioRate, [input,maxDel,del,decay], 1, 0);
}

/**
 * A comb delay line with cubic interpolation. This version uses a localBuf.
 *
 * @class bufCombC
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @param decay Time in seconds for the echoes to decay by 60 decibels.
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufCombC (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufCombC(buf, del, decay, input)
{
	return multiNewUGen(&quot;BufCombC&quot;, AudioRate, [buf, input, del, decay], 1, 0);
}

/**
 * A simple delay with no interpolation.
 *
 * @class delayN
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; delayN del del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function delayN(maxDel, del, input)
{
	return multiNewUGen(&quot;DelayN&quot;, AudioRate, [input,maxDel,del], 1, 0);
}

/**
 * A simple delay with no interpolation. This version uses a localBuf.
 *
 * @class bufDelayN
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufDelayN (localBuf 44100 1) del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufDelayN(buf, del, input)
{
	return multiNewUGen(&quot;BufDelayN&quot;, AudioRate, [input,buf,del], 1, 0);
}

/**
 * A simple delay with linear interpolation.
 *
 * @class delayL
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; delayL del del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function delayL(maxDel, del, input)
{
	return multiNewUGen(&quot;DelayL&quot;, AudioRate, [input,maxDel,del], 1, 0);
}

/**
 * A simple delay with linear interpolation. This version uses a localBuf.
 *
 * @class bufDelayL
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufDelayL (localBuf 44100 1) del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufDelayL(buf, del, input)
{
	return multiNewUGen(&quot;BufDelayL&quot;, AudioRate, [input,buf,del], 1, 0);
}

/**
 * A simple delay with cubic interpolation.
 *
 * @class delayC
 * @constructor
 * @param maxDel Max delay time in seconds
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; delayC del del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function delayC(maxDel, del, input)
{
	return multiNewUGen(&quot;DelayC&quot;, AudioRate, [input,maxDel,del], 1, 0);
}

/**
 * A simple delay with cubic interpolation. This version uses a localBuf.
 *
 * @class bufDelayC
 * @constructor
 * @param buf LocalBuf to use for the delay
 * @param del Delay time in seconds
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufDelayC (localBuf 44100 1) del &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function bufDelayC(buf, del, input)
{
	return multiNewUGen(&quot;BufDelayC&quot;, AudioRate, [input,buf,del], 1, 0);
}

var _shapeNames = {
	step: 0,
	lin: 1,
	linear: 1,
	exp: 2,
	exponential: 2,
	sin: 3,
	sine: 3,
	wel: 4,
	welch: 4,
	sqr: 6,
	squared: 6,
	cub: 7,
	cubed: 7
}

function _prEnv(levels, times, shape, input, doneAction)
{
	if(!(levels instanceof Array &amp;&amp; times instanceof Array))
		throw new Error(&quot;env levels and times must be arrays&quot;);

	var size = times.length;
	var contents = [];
	contents.push(levels[0]);
	contents.push(size);
	contents.push(-99); // -99 = no releaseNode
	contents.push(-99); // -99 = no loopNode
	var shapeNum = _shapeNames.hasOwnProperty(shape) ? _shapeNames[shape] : 5; // 5 = custom shape
	var curveNum = typeof shape === &quot;string&quot; ? 0 : shape; // 0 default shape

	for(var i = 0; i &lt; size; ++i)
	{
		contents.push(levels[i+1]);
		contents.push(times[i]);
		contents.push(shapeNum);
		contents.push(curveNum);
	}
	
	return multiNewUGen(
		&quot;EnvGen&quot;,
		AudioRate,
		[1/*gate*/, 1/*levelScale*/, 0/*levelBias*/, 1/*timeScale*/, doneAction].concat(contents),
		1,
		0
	);
}

/**
 * Envelope generator. Used for amplitude envelopes, will automatically free the synth when finished.
 * @class env
 * @constructor
 * @param levels The levels that the envelope will move through
 * @param times The times it takes for the env to move between levels. Should be 1 item less than levels
 * @param shape Either a shape number or string. Some examples: -4, 0, 1, &quot;linear&quot;, &quot;squared&quot;
 * @param input Either a ugen or 1
 * @example 
 * let test amp =&gt; white amp &gt;&gt; env [0,1,0] [1,1] &quot;linear&quot; &gt;&gt; out 0&lt;br&gt;
 * test $ random 0.1 1.0
 */
function env(levels, times, shape, input)
{	
	// doneAction 2 kills the synth
	return _binaryOpUGen(_BIN_MUL, _prEnv(levels, times, shape, input, 2), input);
}

/**
 * Envelopes.
 * @submodule Envelopes
 */

/**
 * Envelope generator. Used for amplitude envelopes, will NOT automatically free the synth when finished.
 * @class env2
 * @constructor
 * @param levels The levels that the envelope will move through
 * @param times The times it takes for the env to move between levels. Should be 1 item less than levels
 * @param shape Either a shape number or string. Some examples: -4, 0, 1, &quot;linear&quot;, &quot;squared&quot;
 * @param input Either a ugen or 1
 * @example
 * let test f =&gt; sin (env2[f,f*2,f] [1,1] &quot;linear&quot; 1) &gt;&gt; env [0,0.3,0] [2,2] &quot;linear&quot; &gt;&gt; out 0&lt;br&gt;
 * test $ random 440 880
 */
function env2(levels, times, shape, input)
{	
	// doneAction 0 doesn&#x27;t kill the synth
	return _binaryOpUGen(_BIN_MUL, _prEnv(levels, times, shape, input, 0), input);
}

/**
 * Envelope generator. Used for amplitude envelopes, will automatically free the synth when finished.
 * @class perc
 * @constructor
 * @param attackTime Time for the envelope to go from 0 to the peak
 * @param peak The highest level the envelope with reach
 * @param decayTime Time for the envelope to go from the peak to 0
 * @example
 * let test amp =&gt; white amp &gt;&gt; perc 0 1 1 &gt;&gt; out 0&lt;br&gt;
 * test $ random 0.1 1.0
 */
function perc(attackTime, peak, decayTime, input)
{
	return env([0,peak,0], [attackTime, decayTime], -4, input);
}

/**
 * Envelope generator. Used for amplitude envelopes, will NOT automatically free the synth when finished.
 * @class perc2
 * @constructor
 * @param attackTime Time for the envelope to go from 0 to the peak
 * @param peak The highest level the envelope with reach
 * @param decayTime Time for the envelope to go from the peak to 0
 */
function perc2(attackTime, peak, decayTime, input)
{
	return env2([0,peak,0], [attackTime, decayTime], -4, input);
}

/**
 * A linear envelope between two values
 *
 * @class line
 * @constructor
 * @param start Starting value
 * @param end Ending value
 * @param dur Duration in seconds
 * @example
 * let test dur =&gt; impulse (line 1 10 dur) &gt;&gt; out 0&lt;br&gt;
 * let t = test 10&lt;br&gt;
 * stop t
 */
function line(start,end,dur)
{
	return multiNewUGen(&quot;Line&quot;, AudioRate, [start,end,dur,0], 1, 0);
}

/**
 * An exponential envelope between two values
 *
 * @class xline
 * @constructor
 * @param start Starting value
 * @param end Ending value
 * @param dur Duration in seconds
 * @example
 * let test dur =&gt; impulse (xline 1 10 dur) &gt;&gt; out 0&lt;br&gt;
 * let t = test 10&lt;br&gt;
 * stop t
 */
function line(start,end,dur)
{
	return multiNewUGen(&quot;Line&quot;, AudioRate, [start,end,dur,0], 1, 0);
}

/**
 * Send a signal to an output bus.
 *
 * @class out
 * @constructor
 * @param busNum The bus index to send to
 * @example
 * let test bus =&gt; white 1 &gt;&gt; out bus&lt;br&gt;
 * let t = test 0&lt;br&gt;
 * stop t
 */
function out(busNum, value)
{
	var outGen = multiNewUGen(&quot;Out&quot;, AudioRate, [busNum, value], 0, 0); // Out has not outputs

	if(outGen instanceof Array)
	{
		for(var i = 0; i &lt; outGen.length; ++i) // expand the output bus to account for multichannel expansion
		{
			outGen[i].inputs[0] = busNum + i;
		}
	}

	return outGen;
}

/**
 * Inputs and Outputs
 * @submodule InputOutput
 */

/**
 * Reads audio from a range of audio buses.
 *
 * @class auxIn
 * @constructor
 * @param busNum The bus index to start reading from.
 * @param numChannels The number of channels to read from.
 * @example
 * let simpleSynth freq =&gt; sin freq \* square (2\*tempoSeconds) * 0.25 &gt;&gt; out 20&lt;br&gt;
 * let sSynth = simpleSynth 440&lt;br&gt;
 * let fxSynth =&gt; auxIn 20 1 &gt;&gt; combC tempoSeconds [tempoSeconds/1, tempoSeconds/2] 10 &gt;&gt; out 0&lt;br&gt;
 * let fx = Synth::after &quot;fxSynth&quot; [] server&lt;br&gt;
 * stop sSynth&lt;br&gt;
 * stop fx
 */
function auxIn(busNum, numChannels)
{
	var rates = [];

	for(var i = 0; i &lt; numChannels; ++i)
	{
		rates.push(AudioRate);
	}

	// !!! We indicate number of outputs using an array of rates. !!!
	return newMultiOutUGen(&quot;In&quot;, rates, [busNum], 0);
}

/**
 * Pans a single channel input across a stereo field using equal power panning.
 *
 * @class pan
 * @constructor
 * @param position The position in the stereo field where the input will be panned. Range of -1 (left) to 1 (right).
 * @param input The audio input to be panned.
 * @example
 * let test pos =&gt; white 1 &gt;&gt; pan pos &gt;&gt; out 0&lt;br&gt;
 * let t = test-0.3 &lt;br&gt;
 * stop t
 */

function pan(position, input)
{
	// !!! We indicate number of outputs using an array of rates. This is 2 audio rate outputs !!!
	return newMultiOutUGen(&quot;Pan2&quot;, [AudioRate, AudioRate], [input, position, 1], 0);
}

/**
 * Panning UGens
 * @submodule Panning
 */

/**
 * Duplicates an input across a 2 index array.
 *
 * @class dup
 * @constructor
 * @param input The audio input to be expanded.
 * @example
 * let test freq =&gt; sin freq &gt;&gt; dup &gt;&gt; out 0&lt;br&gt;
 * let t = test 440 &lt;br&gt;
 * stop t
 */
function dup(input)
{
	return [input, input];
}

// Control is used internally for SynthDef arguments/controls
function _ControlName(name, controlIndex)
{
	this._lichType = AUDIO;
	this.name = name;
	this.controlIndex = controlIndex;
	this.rate = ControlRate;
}

function _Control(numControls)
{
	var values = [];

	for(var i = 0; i &lt; numControls; ++i)
	{
		values.push(0);
	}
	
	return multiNewUGen(&quot;Control&quot;, ControlRate, values, numControls, 0);
}

// Used internally to keep track of local bufs
function _MaxLocalBufs()
{
	return new UGen(&quot;MaxLocalBufs&quot;, ScalarRate, [0], 1, 0);
}

/**
 * A buffer local to a synth.
 *
 * @class localBuf
 * @constructor
 * @param frames Size of the buffer in samples
 * @param channels Number of channels for the buffer
 * @example
 * let test del =&gt; impulse 1 &gt;&gt; bufCombC (localBuf 44100 1) del 1 &gt;&gt; out 0&lt;br&gt;
 * let t = test 0.1&lt;br&gt;
 * stop t
 */
function localBuf(frames, channels)
{
	var lb = multiNewUGen(&quot;LocalBuf&quot;, ScalarRate, [channels, frames], 1, 0);

	if(lb instanceof Array)
		return lb.map(function(e) { e.isLocalBuf = true; return e; });

	lb.isLocalBuf = true;
	return lb;
}

/**
 * Buffers.
 * @submodule Buffers
 */

//////////////////////////////////////////////
//// Write input spec protoype inheritance
//////////////////////////////////////////////

Number.prototype.writeInputSpec = function(buf, offset, constants, controls)
{
	buf.writeInt32BE(-1, offset);
	offset += 4;
	buf.writeInt32BE(constants[this.valueOf()], offset);
	return offset + 4;
}

_ControlName.prototype.writeInputSpec = function(buf, offset, constants, controls)
{
	buf.writeInt32BE(0, offset); // The control ugen is always in the 0 index
	offset += 4;
	buf.writeInt32BE(controls[this.name], offset);
	return offset + 4;
}

UGen.prototype.writeInputSpec = function(buf, offset, constants, controls)
{
	buf.writeInt32BE(this.synthIndex, offset);
	offset += 4;
	buf.writeInt32BE(this.outputIndex, offset);
	return offset + 4;
}

MultiOutUGen.prototype.writeInputSpec = function(buf, offset, constants, controls)
{
	buf.writeInt32BE(this.synthIndex, offset);
	offset += 4;
	buf.writeInt32BE(this.outputIndex, offset);
	return offset + 4;
}

function _writeInputSpec(buf, ugen, offset, constants, controls)
{
	/*
	var isNum = typeof ugen === &quot;number&quot;;
	
	if(isNum)
	{
		buf.writeInt32BE(-1, offset);
		offset += 4;
		buf.writeInt32BE(constants[ugen], offset);
	}

	else if(ugen instanceof _ControlName)
	{
		buf.writeInt32BE(0, offset); // The control ugen is always in the 0 index
		offset += 4;
		buf.writeInt32BE(controls[ugen.name], offset);
	}

	else
	{
		buf.writeInt32BE(ugen.synthIndex, offset);
		offset += 4;
		buf.writeInt32BE(ugen.outputIndex, offset);
	}

	return offset + 4;*/

	return ugen.writeInputSpec(buf, offset, constants, controls);
}

//////////////////////////////////////////////
//// Write output spec protoype inheritance
//////////////////////////////////////////////


UGen.prototype.writeOutputSpec = function(buf, offset, constants, controls)
{
	for(var i = 0; i &lt; this.numOutputs; ++i)
	{
		buf.writeInt8(this.rate, offset);
		++offset;
	}

	return offset;
}

MultiOutUGen.prototype.writeOutputSpec = function(buf, offset, constants, controls)
{
	for(var i = 0; i &lt; this.numOutputs; ++i)
	{
		offset = this.channels[i].writeOutputSpec(buf, offset, constants, controls);
	}

	return offset;
}

function _writeUGenBytes(buf, ugen, offset, constants, controls)
{
	if(!ugen.addToSynth) // don&#x27;t write proxies
		return offset;
	
	offset = _pstring(buf, ugen.name, offset);
	buf.writeInt8(ugen.rate, offset);
	offset += 1;
	buf.writeInt32BE(ugen.numInputs, offset);
	offset += 4;
	buf.writeInt32BE(ugen.numOutputs, offset);
	offset += 4;
	buf.writeInt16BE(ugen.specialIndex, offset);
	offset += 2;
	
	for(var i = 0; i &lt; ugen.inputs.length; ++i)
	{
		offset = _writeInputSpec(buf, ugen.inputs[i], offset, constants, controls);
	}

	/*
	for(var i = 0; i &lt; ugen.numOutputs; ++i)
	{
		buf.writeInt8(ugen.rate, offset);
		++offset;
	}

	return offset;*/
	
	return ugen.writeOutputSpec(buf, offset, constants, controls);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SynthDef
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function _pstring(buf, string, offset)
{
	buf.writeInt8(string.length, offset);
	offset += 1;
	buf.write(string, offset, string.length);

	return offset + string.length;
}

function _ugenToDefList(ugen, constants, controls)
{
	if(ugen instanceof Array) // Multichannel support
	{
		var defList = [];

		for(var i = 0; i &lt; ugen.length; ++i)
		{
			defList = defList.concat(_ugenToDefList(ugen[i], constants, controls));
		}

		return defList;
	}
	
	else if(typeof ugen === &quot;number&quot;)
	{
		if(!constants.hasOwnProperty(ugen))
		{
			constants[ugen] = constants.numConstants;
			constants.arr.push(ugen);
			constants.numConstants += 1;
		}

		return [];
	}

	else if(ugen instanceof _ControlName)
	{
		if(!controls.hasOwnProperty(ugen.name))
		{
			controls[ugen.name] = ugen.controlIndex;
			controls.arr.push(ugen);
			controls.numControls += 1;
		}

		return [];
	}
	   
	var defList = [ugen];
	
	for(var i = ugen.inputs.length - 1; i &gt;= 0; --i)
	{
		defList = defList.concat(_ugenToDefList(ugen.inputs[i], constants, controls));
	}

	if(ugen.isLocalBuf) // LocalBuf support
	{
		if(!constants.hasOwnProperty(&quot;maxLocalBufs&quot;))
		   constants[&quot;maxLocalBufs&quot;] = _MaxLocalBufs();

		constants[&quot;maxLocalBufs&quot;].inputs[0] += 1; // increment maxLocalBufs
		ugen.inputs = ugen.inputs.concat([constants[&quot;maxLocalBufs&quot;]]);
		ugen.numInputs += 1;
	}
	
	return defList;
}

function _writeDef(buf, children, offset, constants, controls)
{
	for(var i = 0; i &lt; children.length; ++i)
	{
		offset = _writeUGenBytes(buf, children[i], offset, constants, controls);
	}

	return offset;
}

function _removeDuplicateChildren(children)
{
	for(var i = 0; i &lt; children.length; ++i)
	{
		var child = children[i];

		if(child._collected)
			children[i] = null;
		else
			child._collected = true;
	}

	return children.filter(function(e){ return e != null });
}

// Compile a Lich synth to a SuperCollider synth definition. This requires a very specific binary format.
function _synthDef(name, def)
{
	var offset = 4; // default offset to for becase we always start with the same header
	var numBytes = 11 + name.length;
	var buf = new Buffer(1024); // NEED TO FIGURE OUT A WAY TO DYNAMICALLY SET THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Initialize controls, constants, and children
	
	var controls = { numControls: 0, arr: [] };
	var constants = { numConstants: 1, arr: [0], 0:0 }; // We always need the zero constant for controls
	var children = _ugenToDefList(def, constants, controls).reverse();
	var numChildren = 0;
	
	children = _removeDuplicateChildren(children);

	if(constants.hasOwnProperty(&quot;maxLocalBufs&quot;)) // LocalBuf support
	{
		var maxLocalBufs = constants[&quot;maxLocalBufs&quot;];
		var numMaxLocalBufs = maxLocalBufs.inputs[0];
		
		children = [maxLocalBufs].concat(children);

		if(!constants.hasOwnProperty(numMaxLocalBufs))
		{
			constants[numMaxLocalBufs] = constants.numConstants;
			constants.arr.push(numMaxLocalBufs);
			constants.numConstants += 1;
		}
	}
	
	if(controls.numControls &gt; 0)
		children = [_Control(controls.numControls)].concat(children);

	for(var i = 0; i &lt; children.length; ++i)
	{
		if(children[i].synthIndex == null)
		{
			children[i].setSynthIndex(numChildren++);
		}
	}
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Header
	
	buf.write(&quot;SCgf&quot;, 0, 4); // SuperCollider synth definition file header
	buf.writeInt32BE(2, offset); // SC synthdef version number
	offset += 4;
	buf.writeInt16BE(1, offset); // Number of SynthDefinitions
	offset += 2;
	offset = _pstring(buf, name, offset); // Name of the SynthDef

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Constants
	
	buf.writeInt32BE(constants.numConstants, offset);
	offset += 4;
	
	for(var i = 0; i &lt; constants.arr.length; ++i) // Write the constant values
	{
		buf.writeFloatBE(constants.arr[i], offset);
		offset += 4;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Controls

	buf.writeInt32BE(controls.numControls, offset); // NUMBER OF Arguments/Parameters/Controls.
	offset += 4;

	for(var i = 0; i &lt; controls.numControls; ++i) // Write the default values for all the controls. In Lich they&#x27;re always just 0.
	{
		buf.writeFloatBE(0, offset);
		offset += 4;
	}
	
	buf.writeInt32BE(controls.numControls, offset); // NUMBER OF Arguments/Parameters/Controls NAMES. This will always be the same in Lich
	offset += 4;

	for(var i = 0; i &lt; controls.numControls; ++i) // Write the names of all the controls
	{
		offset = _pstring(buf, controls.arr[i].name, offset); // name of the controls
 		buf.writeInt32BE(i, offset); // index of the control value, in Lich this will be the same for the name as the initial value above
		offset += 4;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// UGens
	
	buf.writeInt32BE(numChildren, offset); // Number of UGens
	offset += 4;
	
	offset = _writeDef(buf, children, offset, constants, controls); // Compile the ugen list

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Variants
	
	buf.writeInt16BE(0, offset); // number of variants. ZERO until variants are supported
	offset += 2;

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// File and OSC
	
	// buf = buf.slice(0, offset);
	s.sendMsg(&#x27;/d_recv&#x27;, [buf.slice(0, offset)]);

    	/*
    	var path = &quot;/tmp/&quot;+name+&quot;.scsyndef&quot;;
	
	fs.writeFile(
		path,
		buf,
		function(err) {
			if(err) {
				console.log(err);
			} else {
				s.sendMsg(&#x27;/d_load&#x27;, [path]);
			}
		}
	);*/
	
	return Lich.VM.Void;
}

function stop(object)
{
	if(object instanceof Synth)
	{
		object.freeNode();
	}

	else if(object._lichType == IMPSTREAM || object._lichType == SOLOSTREAM)
	{
		object.stop();
	}
	
	else
	   throw new Error(&quot;stop can only be called on Synths and Patterns&quot;);
	
	return Lich.VM.Void;
}

function freeAll()
{
	s.sendMsg(&#x27;/clearSched&#x27;, []);
    s.sendMsg(&#x27;/g_freeAll&#x27;, [0]);
	Lich.scheduler.freeScheduledEvents();
	s.sendMsg(&quot;/g_new&quot;, [1, 0, 0]); // default group
}

// Redefine Lich.compileSynthDef to use SuperCollider behavior instead of web audio
Lich.compileSynthDef = function(ast)
{
	//ast.astType = &quot;decl-fun&quot;;
	//ast.noCollapse = true;
	// var res = Lich.compileAST(ast)+&quot;;Soliton.synthDefs[\&quot;&quot;+ast.ident.id+&quot;\&quot;]=&quot;+ast.ident.id;
	var def = Lich.compileAST(ast.rhs);
	var localArgNames = [];
	var localArgs = [];
	var numArgs = 0;

	for(var i = 0; i &lt; ast.args.length; ++i)
	{
		if(ast.args[i].astType == &quot;varname&quot;)
		{
			var argName = ast.args[i].id;
			
			if(localArgNames.indexOf(argName) != -1)
			{
				throw new Error(&quot;Duplicate definition for argument: &quot; + argName + &quot; in synth definition &quot; + ast.ident.id);
			}

			else
			{
				localArgNames.push(&quot;var &quot; + argName + &quot; = new _ControlName(\&quot;&quot;+argName+&quot;\&quot;,&quot;+numArgs+&quot;);&quot;);
				localArgs.push(argName);
				numArgs++;
			}
		}
	}

	var res;
	
	if(numArgs == 0)
		res = &quot;_synthDef(\&quot;&quot;+ast.ident.id+&quot;\&quot;,&quot;+def+&quot;);&quot;;
	else
		res = &quot;_synthDef(\&quot;&quot;+ast.ident.id+&quot;\&quot;,(function(){&quot;+localArgNames.join(&quot;&quot;)+&quot;return &quot;+def+&quot;})());&quot;;

	var argsAndIndexes = [];

	for(var i = 0; i &lt; localArgs.length; ++i)
	{
		argsAndIndexes.push(i);
		argsAndIndexes.push(localArgs[i]);
	}
	
	res += ast.ident.id + &quot;=function(&quot;+localArgs.join(&quot;,&quot;)+&quot;){return new Synth(\&quot;&quot;+ast.ident.id+&quot;\&quot;,[&quot;+argsAndIndexes.join(&quot;,&quot;)+&quot;]);};&quot;;
	res += &quot;Soliton.synthDefs[\&quot;&quot;+ast.ident.id+&quot;\&quot;]=&quot;+ast.ident.id;
	
	if(Lich.parseType !== &quot;library&quot;)
		res += &quot;;Lich.VM.Print(&quot;+ast.ident.id+&quot;);&quot;;

	return res;
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
<script type="text/javascript" src="../assets/../../third-party/ace/ace.js"></script>
<!--
<script>
    var editor = ace.edit("editor");
    editor.setTheme("ace/lich3");
    editor.getSession().setMode("haskell");
</script>
-->
</body>
</html>
