//////////////////////////////
// Dev Notes
//////////////////////////////

// Dictionaries have no been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the :: operator.
doom :: "Doom"

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

doom2 :: "Doom" -- returns 3
doom2 :: "Doom3" -- returns 2
doom2 :: "Liar" -- returns "Face"

/////////////////////////////////////////
// Parsing modes: Module and Interactive

Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.


// NEED TO IMPLEMENT
Algabraeic Data types or someother kind of basic Struct (record syntax?)
foldl, foldr, zip, zipWith, filter, other various prelude functions
Case statements
Pattern matching?
Guards?


Implement Dictionaries like in SuperCollider because Tuples are useless for us. Might as well steal the syntax. Example:

("key" -> value, "key2" -> value)

or

"String" -> 1 : "String2" -> 3
"MyKey" -> 2 : "key" -> 4

/////////////////////////
// List creation syntax
// Dec 14, 2013

Need to add the nice haskell list creation syntax. Examples:
[1,2,3,4]
[1..7]
[2,5..99]

This works currently but it uses the SuperCollider version of the syntax:
(1..9)
(3,6..99)

//////////////////
// Guard Patterns
// Dec 14, 2013

Need to add syntax for guard patterns, for example:

myGuard x
	| x > 4 -> 99
	| otherwise -> 100

///////////////////////////////
// Curried operator expression
// Dec 14, 2013

Partial operator expressions don't parser. For example:
map (+2) [1,2,3]

//////////////////////////////
// Known Bugs
//////////////////////////////


//////////////////////////////
// Mapping curried functions
// Dec 19, 2013

Mapping of curried functions appears to only use the last result. Example:

let adds = map (add) (1..9)
map (\x -> x 1) adds

This should return:
[2,3,4,5,6,7,8,9,10]

But instead returns:
[10,10,10,10,10,10,10,10,10]

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2


//////////////////////////////
// Let In Statements
// Dec 17, 2013

Let In statements don't parse. Example:

let x = 20 in x + y


//////////////////////////////
// Strings in where statement
// Dec 17, 2013

Strings in a where statement don't parse correctly. This is because of the formatting fix I made to allow for spaces in a string, such as "Hello, world."
The solution needs to allow for both spaces in strings and string in where statements and likely any other kind of indented syntax.