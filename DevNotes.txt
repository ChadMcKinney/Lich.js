//////////////////////////////
// Dev Notes
//////////////////////////////

(/=Nothing) Not working in filter? At least with Filter it's not!

send walkFunc madnessLoop


What should networking and input look like?

What if we had a declarative tree for all IO? No mutable state (everything happens under the hood). Similar but much more simple than FRP. What would it look like?


IO ::  
    KeyDown k                  -> someIOAction k
    KeyUp k                    -> someIOAction k
    MouseMove x y              -> someMouseAction x y
    MousePress x y             -> someMouseAction x y
    Draw t <> Player p         -> someDrawFunction p t -- combine draw and player events



IO :: Player { position = [x,y] }


Game = 

Madness
    main of
        KeyDown k           -> someIOAction k
        KeyUp k             -> someIOAction k
        MouseMove x y       -> someMouseAction x y
        MousePress x y      -> someMouseAction x y
        Game                -> gameLoop game




//////////////////////////////////////////
// Pattern matching is beginning to work


need to get unions and == /= comparisons working!!!!!!!!!!!!!!!!!!!!!!


data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


h == Hydra -- THIS SHOULD WORK BUT DOESN'T!!!





let whereFunc x = z x
    where
       z x:xs = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching


let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error


let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head


-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster


2 + 3


case 3 of
    3 > 2 -> 1


-- REQUIRES TAIL RECURSION!
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Queue for compiling
Will need to implement a queue for compiling commands. Once this becomes networked it's possible commands may try to be compiled in tandem, and espcially if an error is thrown during one of them it could create very bad problems. Using a queue, commands are added to it and the compiler runs on one command at a time in the queue until it's worked through the entire queue. 


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]


// let in functions now work.
let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1





make (:: exp) useful for partial application
? existential argument

cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

--Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.

arrows:
func1 >>> func2 >>> func3 >>> func4
func1 <<< func2 <<< func3 << func4
where statements in data constructors?


/////////////////////////////////////////
POST 1.0 FEATURES
Pattern matching
Guards
/////////////////////////////////////////



//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2










-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\y -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 2
