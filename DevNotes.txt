//////////////////////////////
// Dev Notes
//////////////////////////////


// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.


// NEED TO IMPLEMENT
foldl, foldr, zip, zipWith, filter, other various prelude functions
function composition?:
func1 <<< func2 <<< func3 << func4
func1 . func2 . func3 $ func4

arrows:
func1 >>> func2 >>> func3 >>> func4
Pattern matching?
Guards?
list comprehension

where statements in data constructors
enums or true algebraic data types such as:
	data Cordinal = North | East | South | West

//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
	thisThing = 1,
	two = 2,
	three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


/////////////////////////
// List creation syntax
// Dec 14, 2013

Need to add the nice haskell list creation syntax. Examples:
[1,2,3,4]
[1..7]
[2,5..99]

This works currently but it uses the SuperCollider version of the syntax:
(1..9)
(3,6..99)

//////////////////
// Guard Patterns
// Dec 14, 2013

Need to add syntax for guard patterns, for example:

myGuard x
	| x > 4 = 99
	| otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2


//////////////////////////////
// Let In Statements
// Dec 17, 2013

Let In statements don't parse. Example:

let x = 20 in x + y