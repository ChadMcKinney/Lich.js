//////////////////////////////
// Dev Notes
//////////////////////////////


//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


add 2 $ 3


//////////////////////////////////////////
// Pattern matching 

data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching

let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error

let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head

-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster



-- Won't work, requires TCO.
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1



cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" = 555)
(someVar = 555, "A String" = [1,2,3], 1.5 = "Three")
let doom = ("Doom" = 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" = "doom") : doom
let doom2 = ("Doom3" = 2, "Liar" = "Face") : doom

// You can also use the insert function
insert ("frogs" = [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"


//////////////////////////////////////////
// Case Statements

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"


//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100



-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 



data MyType { d = 4 }

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" => "kj", "Doom2" => 2, "Doom3" => 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r


let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793


-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let combo = add 3 . div 4
combo 6
add 3 . div 4 $ 6


let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add 1) [1..9]
(adds !! 2)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" => add 3, "ADD12" => add 1 2)
(addDict !! "ADD3") 1

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3


-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add) [1..9]
(adds !! 2) (-1)

let double x = x * 2
double
double 10
add
add 2
lookup 1


North /= West
zipFlat [1..9] [27,53..1000]
flip subtract 2 3
clientName
even 10
odd (-4)
[[x,y] | x <- [1..50], y <- [1..90]]
[x | x <- [1..10], even x]


[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..25]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

(3<=) 

2 - (-1)
2 : [3]
add (-1) 2
subtract
map (subtract) [1..9]
minus
minus 3 1
subtract 3 1
add x y = x + y

(+1) . (3/) . (subtract 1) . (1-) $ 5

let x = 11
let y = 22
4 << 3
add 2 3 >> div 2
3 >> add 2
add 2 $ 3

add 2 << 3

let one = 6
2 + (-one)

(5 >>) (div 3)


map (subtract 2) [1..9]

5 >> div 3 >> add 2 >> mul 6
5 >> (/3) >> (+2) >> (*6) >> (3+) >> (66-)

((3 / 5) + 2) * 6

mul 6 << add 2 << div 3 << 5
5 >> (div 3) >> (add 2) >> mul 6 >> (/3) >> (*2) >> (3/)
add 2 . div 3 $ 5
map (5 >>) $ map (div) [1..9]
map (5 >>) $ map (/) [1..9]

add 2 << (div 3 << 5)
5 >> div 3 >> add 2
(5 >>) (div 3)
5 >> div 3

spawn add [2,3]
spawn (add 2) [3]
spawn (\x y -> x / y * 666) [1,2]

data MyType{d = 4}

let myLoop m =
   receive
       "test"        -> myLoop $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn #Test2 myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let newLoop = spawn #Test myLoop [MyType 5]

"test" :>> #Test
"finished" :>> #Test

let makeData x = MyType x
makeData 1
let m = MyType
let n = m { d = m::d + 1 }
m
n

data Monster { size = 6 }
let makeMonster x = Monster x
let monsterFactory maker =
    receive
        [x] -> maker x

let monsterActor = spawn #Monster (monsterFactory) [makeMonster]
[666] :>> monsterActor

map (map (/3)) [[x,y] | x <- [1..9], y <- [1..9], odd x, even y]
map (map (/3)) ("Doom" => [1..9], "Three" => [1..3])
replicate 3 $ replicate 3 $ replicate 3 0
deepMap (2+) $ replicateN [2,3,1,2] [1..9]
deepMap (2+) [1,2,[3],4,[[5]]]

print 1
2 + 2

spawn #print (\x -> x myName) [print]

let double x = x * 2

let printAndDouble x = do 
    print x
    double x

let printAndTriple x = do print x; print( x * 2); x * 3

printAndDouble 20

printAndTriple 10


-- Mountains of Madness testing
compile "MountainsOfMadness"
let actor = spawn #Madness madnessLoop [demoGame]

(Walk north "casiosk1") :>> actor
(Look north "casiosk1") :>> actor
Finish :>> actor

(Walk north "casiosk1") :>> #Madness
(Look north "casiosk1") :>> #Madness
Finish :>> #Madness

(findSomethingWithName "casiosk1") demoGame


chat ";lkwedlkwwf;lwkewe;ldkwd;lwkfwf;lkwef;lwkf"

clientName
1 + 1
random 1 7

spawn #ChatActor (chat) ["Hello, world."]
spawn #ChatActor (actorChat) ["Hello, world." + (random 0 1)]

importjs "../Pieces/MountainsOfMadnessPanel.js"
updateNarration "Yo!"
spawn #ChatActor (updateNarration) ["Hello, world."]
updateNarration


-- Guards are in
let myGuard (x:xs) 
    | x > 4 = 99
    | _ = 100

myGuard [1..9]



let whereGuard (x:xs) = y x
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard [1..99]
whereGuard [11..99]

let whereGuard2 = y
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard2 1
whereGuard2 11

let fib n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib (n - 1) + fib (n - 2)

fib 8

setTempo 60
setTempo 300

let tempoSetter x = do setTempo x; sleep 0.1; tempoSetter $ random 60 1000
tempoSetter 60



{-
    Sequencing Ideas!!!!!
-}


-- Percussion sequencing is similar to tidal, but _ represents a rest, space seperates identifiers. We use | like in list comprehensions, but here they're for tempo multipliers and offsets
pattern     +> bass _
pattern2    +> _ snare
pattern3    +> _ hi
pattern4    +> down down down _ down [_ _ down] | (*4)
pattern     +> a | (*2) (\x -> 1 / x) (*3) (/4)

-- We can predefine percussive patterns without assignment using lambda style syntax (+>). This will create a new pattern without autoplaying for storage.
(+> a b c)
(+> a b [hi hi [_ low low hi]] | (+4))
-- Melodies use a similar scheme. Spaces separate numbers. Wild cards are rests. We use | like list comprehension but for offsets/multipliers which themselves can be sequenced with _ being default
octoSynth ~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-) (sqrt) _ _ _

-- Lambda style melody pattern
(~> synth1 1 2 3)
(~> synth2 1 2 3 44 2 4 _ _ _ 1 _ (-4) 9 1 23 | (* 3) (/4) _ (+1) )
(~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-))
-- We can pass any function expecting one argument, including lambdas
(~> bass 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (sqrt) _ (\x -> if odd x then x + 1 else x))
-- We can also use lists like in Perc Sequencing to get tuples
(~> noise 1 2 [3 4 5] 1 [[1 2] 3])


let s = (sin 440) >> gain 0.5 >> play
stop s

let s = sin 3 >> gain 33 >> sin >> gain 666 >> sin >> gain 0.3 >> play
s >> stop

let s2 = sin 0.5 >> gain 66 >> sin >> gain 600 >> sin >> gain 0.3 >> play
s2 >> stop

let s3 = square 7 >> gain 66 >> square >> gain 33 >> square >> gain 0.2 >> play
s3 >> stop


let s4 = tri 2 >> gain 4 >> tri >> gain 99 >> square >> gain 0.2 >> play
s4 >> stop


let s5 = tri 66 >> gain 3 >> tri >> gain 14 >> square >> gain 0.3 >> play
s5 >> stop


let s = play (tri 440 >> gain 0.2)
stop s


let table = waveTable 33 (map (random 0) $ cycle 15 [(-1), 1]) >> play
stop table

let table = waveTable 33 (map (sin) [1..99]) >> play
stop table


-- Filters

let allpasser =  (dry * 0.5) + (wet * 0.5) >> play
    where
        dry = (square 88) * ((saw 60) * 0.1)
        wet = dry >> allpass (100) (sin 0.5)

stop allpasser



-- Function Composition Styles for Synth Definitions

let testFunc = play . sin . gain 440 $ sin 33
stop testFunc

let testFunc = sin 33 >> gain 440 >> sin >> play
stop testFunc

let testFunc = play(sin (gain 440 (sin 33)))
stop testFunc


let p = (playBuf (choose sampleList) 2 0 2) >> play
stop p

let convolver = square 2 >> convolve "cluster" >> play
stop convolver

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> notch 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> lowshelf 33 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> highshelf 3333 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> peaking 3333 16 30 >> gain 0.3 >> play
stop filterer


-- range and exprange work!
let filterer = square 5 >> lowpass ((tri 1 >> range 1 100) * (sin 0.1 >> range 1 100)) 3 >> play
stop filterer

let filterer2 = square 13 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> play
stop filterer2


let glitter = (sin (sin 0.3 >> exprange 1 66)) * (sin 666) * (sin 3) >> delay (1/13) 0.9 >> gain 0.1 >> play

let glitter2 = (sin (sin 0.2 >> exprange 1 33)) * (sin (999)) * (sin 3) >> delay (4/13) 0.9 >> gain 0.1 >> play

let glitter3 = (sin (sin 0.5 >> exprange 1 66)) * (sin (666*2)) * (sin 2) >> delay (3/13) 0.5 >> gain 0.1 >> play

let glitter4 = (sin (sin 0.1 >> exprange 1 33)) * (sin (333*5)) * (sin 6.5) >> delay (1/13) 0.9 >> gain 0.1 >> play


let guitar = (saw 80) * (square 3) >> lowpass (sin 0.1 >> exprange 20 2000) 10 >> delay (1/3) 0.9 >> gain 0.3 >> play
stop guitar



let kick => square 80 >> perc 0.0 0.7 0.05
kicker +> kick _

let snare => square (80 * 16) >> perc 0.0 0.7 0.05
snarer +> _ snare

let hihate => tri (mul 80 $ randomI 1 32) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _ _
hater2 +> _ _ hihate _ _ _
hater2 +> _ hihate _ _ _ _ _
hater3 +> hihate _ _
hater4 +> hihate _ _ _ _ _ _ _ _

setTempo 500
setTempo 1000

-- Metric Onset Test, should produce consistent quarter notes no matter the timing of the starts
let hihate => tri (mul 80 $ randomI 1 24) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _
hater2 +> hihate _ _ _
hater2 +> _ _ hihate _
hater3 +> _ _ _ hihate



-- Just Intonation Fun

let glitter4 => (sin (saw 0.1 >> exprange 1 40)) * (sin (160*10)) * (tri 6.5) >> delay (1/3) 0.3 >> gain 0.1 >> play

let k => tri 40 >> lowpass 320 1 >> perc 0.0001 1 0.3
kicker +> k _ _ k _ _ k _ | (/2)

let hh => sin (mul 80 12) >> perc 0.0 0.4 0.05
hate5 +> _ hh | (/2)

let hh2 => sin (160 * 10) >> perc 0 0.3 0.1
hate2 +> hh2 hh2 _

let hh3 => white >> gain 10 >> bandpass (80 * 17) 455 >> gain 10 >> perc 0.0001 1 0.1
hihate3 +> hh3 _ _ | (/2)
hihate4 +> hh3 _ _ _ _ | (/2)

let snare => white >> perc 0.0 0.7 0.5
let lkick => square 40 >> perc 0.001 0.7 0.4
lkicker +> lkick snare [_ lkick] snare | (*2)


let guitar => (saw (40 * (randomI 1 10))) * (sin 3) >> lowpass (80*17) 10 >> delay (1/5) 0.4 >> perc 0.1 0.3 3
guitarer +> guitar _ guitar _ _ guitar _ _

let filterer2 => square 80 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> gain 0.3 >> play
stop guitarer
stop filterer2
stop glitter4



setTempo 300

let cluster => square 20 >> waveShape (map (nsin) [1..99]) >> lowshelf 40 12 >> perc 0 1 0.1
clusterz +> cluster _ cluster cluster | (/2)
let cluster2 => square 20 >> waveShape (map (nsin) [1..179]) >> perc 0 1 0.1
clusterz2 +> _ cluster2 _ | (/2)
let cluster3 => square 20 >> waveShape (map (nsin) [1..199]) >> perc 0 1 0.05
clusterz3 +> _ cluster3 | (/2)
clusterz4 +> cluster3 _  _ cluster3 | (/2)
let cluster0 => white >> perc 0 0.4 0.5
clusterz0 +> _ cluster0 | (*2)



-- Melody sequencing is beginning to work!
let hh => white >> bandpass (100 * 32) 50 >> perc 0 3 0.1
hhh +> hh [_ hh] [_ hh] hh

let hh2 => white >> bandpass (100 * 16) 100 >> gain 20 >> perc 0 0.5 0.05
hhh4 +> hh2 hh2 | (/2)

let snare => white >> perc 0.0 0.7 0.3
let ss => white >> bandpass (340 * 8) 100 >> gain 30 >> perc 0.0 1 0.1
let lkick => square 80 >> add (tri 40) >> perc 0 0.6 0.1
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let bass freq => (sin freq) + white >> lowpass (freq * (pow 2 $ randomI 1 3)) 40 >> perc 0.01 0.3 (random 0.05 3)
bassSeq ~> bass 20 42.5 _ 80 160 _ 190 | (*2) (/2) (*1.75) _ _ (*1.5) (*2) _

let bass2 freq => (square freq) + white >> lowpass (freq * (pow 2 $ randomI 2 3)) 40 >> perc 0.0 0.6 0.1
bassSeq2 ~> bass2 [20 42.5] [42.5 80] [160 160] [190 190] | (*2) _ (*1.75) _ _ (*1.5) (*2) _ (*1.5)

let plunk freq => (sin freq * 16) >> perc 0.0 0.1 0.05
plunkSeq ~> plunk [80 170] [40 42.5] [42.5 80] [160 160] [190 _ 190 20] | (*2) (*2) (*1.75) (*6) (*8) (*6) (*4) (*2) (*1.5)

stop lkicker2
stop hhh4
stop hhh
stop plunkSeq
stop bassSeq2

-- chill for a minute
stop bassSeq

-- spliceOsc is back!
spliceOsc "someString!" 5



///////////////////////////////////
// GRAPHICS TEST CODE
///////////////////////////////////

initGraphics -- MUST DO THIS FIRST!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
setBackground (random 0 255) (random 0 255) (random 0 255)
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -100 100] [25, 25, 25] [random 0 (2*pi), random 0 (2*pi), random 0 (2*pi)] [0,200,150] 

setShader $ choose shaders
deleteMesh s
deleteMesh c

deleteScene
shaders
setShaders $ map (choose) $ replicate 3 shaders
clearShaders
wireframe true s
wireframe true c
wireframe false s
wireframe false c


wireframeAll (choose [true, false])

move [-1, -10, -2] s
move [-1, 1, -1] c
moveAll [random -1 1, random -1 1, random -1 1]

setColor [random 0 255, random 0 255, random 0 255] c
setColor [random 0 255, random 0 255, random 0 255] s
setColorAll [random 0 255, random 0 255, random 0 255]

rotate [random -1 1, random -1 1, random -1 1] c
rotateAll [random -1 1, random -1 1, random -1 1]

linear [0, 0, 1] c
linearAll [random -1 1, random -1 1, random -1 1]

angular [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1] c
angularAll [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1]

setPosition [random -50 50, random -50 50, random -50 50] s
setPositionAll [random -50 50, random -50 50, random -50 50]

scale [random 0.1 1, random 0.1 1, random 0.1 1] s
scaleAll [random 0.1 1, random 0.1 1, random 0.1 10]

-- supports streaming style syntax
s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]

cloudMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
gaussianMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
sinMesh (random 10 100) [random 0 255, random 0 255, random 0 255]

sinMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scaleAll [4, 4, 4]

let n = noiseMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] n
angular [0.01, 0.01, 0.03] n

deleteMesh n

let g = gaussianMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] g
angular [0.01, 0.01, 0.03] g

deleteMesh g


let s = squareMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [6,6,6] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let s = sawMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let t = triMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [10, 10, 10] t
angular [0.01, 0.01, 0.03] t

deleteMesh t

-- Won't be able to initially see it because of culling, set the angular!
let f = flatMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] f
angular [0.01, 0.01, 0.03] f

deleteMesh f
deleteScene
initGraphics

let s = sawMapMesh 20 20 [random 0 255, random 0 255, random 0 255]
scale [7, 7, 7] s
angular [0.01, 0.01, 0.03] s

spliceShader $ randomString $ random 1 5

-- Patterns are supported as well!
initGraphics
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -10 10] [50,50,50] [0.1,0,0] [random 0 255, random 0 255, random 0 255]
let meshSynth => s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]
let meshSynth2 => c >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1] >> angular [random 0 0.1, random 0 0.1, random 0 0.1]
meshSeq +> meshSynth meshSynth2 meshSynth [meshSynth2 meshSynth]

-- Shader sequencing, yay!
let shaderSynth => spliceShader $ randomString $ random 1 5
shaderSeq +> shaderSynth _ _ _



-- Bus tests

let s = square 33 >> auxOut 0 >> play
let s2 = saw 13 >> gain 0.1 >> auxOut 0 >> play
let v = auxIn 0 >> convolve "cluster" >> gain 0.03 >> delay 1 0 >> auxThrough 0 >> play

stop s
stop s2
stop v

fade 1 v

-- We can use aux buses for feedback
let s3 = auxIn 1 >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough 1 >> gain 2 >> play
stop s3

-- We can also use a localBus so as to not collide with anything else that might use a particular auxillary bus
let s4 = feed >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough feed >> gain 2 >> play
    where feed = localBus


-- Graphics Notes
Make Graphics API more like Audio API
you should use stop instead of delete
and envelopes should give a mesh a lifetime?
New graphics functionality:
2D Drawing
Mesh Morphing/Animation between meshes
Sphere/Rect Height Maps (heights wrap around surface)
Mesh loading from file, similar to sample loading
More shader generating code -- Compile Lich.js directly to a shader?

-- Language to do
Enforce purity: Done?!
    Prevent redefinition of variables at global scope in library compilation
    Prevent multiple declaration of variables in and let statements


-- Audio to do
Fix Node leaks with custom UGens
SpliceFilter? -> Adds poles according to splice string characters
Implement Limiter, writeBuf, and any other loose ends. Put in Master limiter?
Buses and Effects routing
Panning!