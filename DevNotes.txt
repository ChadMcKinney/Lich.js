//////////////////////////////
// Dev Notes
//////////////////////////////



NEED TO ADD DO STATEMENTS AND SLEEP!!!!!



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


add 2 $ 3


//////////////////////////////////////////
// Pattern matching is beginning to work


need to get unions and == /= comparisons working!!!!!!!!!!!!!!!!!!!!!!


data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


h == Hydra -- THIS SHOULD WORK BUT DOESN'T!!!





let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching


let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error


let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head


-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster


2 + 3


case 3 of
    3 > 2 -> 1


-- REQUIRES TAIL RECURSION!
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Queue for compiling
Will need to implement a queue for compiling commands. Once this becomes networked it's possible commands may try to be compiled in tandem, and espcially if an error is thrown during one of them it could create very bad problems. Using a queue, commands are added to it and the compiler runs on one command at a time in the queue until it's worked through the entire queue. 


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]


// let in functions now work.
let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1





make (:: exp) useful for partial application
? existential argument

cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

--Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.

arrows:
func1 >>> func2 >>> func3 >>> func4
func1 <<< func2 <<< func3 << func4
where statements in data constructors?


/////////////////////////////////////////
POST 1.0 FEATURES
Pattern matching
Guards
/////////////////////////////////////////



//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2










-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 2






-- Misc test code

let actors = mapSpawn (\x -> last $ ) [1..6]


// SCOPING PROBLEMS WITH RECURSION :(
let fib n = case n of
    0        -> 0
    1        -> 1
    _        -> (fib (n - 1)) + (fib (n - 1))

fib 3

let recur x = if x > 50 then x else recur (x + 1)

recur 1

let factorial n = case n of
    0    -> 1
    _    -> n * (factorial (n - 1))


factorial 5
4 * 3 * 2 * 1 * 5
factorial 0 = 1  
factorial n = n * factorial (n - 1)  


data MyType{d = 4}

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" => "kj", "Doom2" => 2, "Doom3" => 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r


let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793




-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let combo = add 3 . div 4
combo 6
add 3 . div 4 $ 6


let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add 1) [1..9]
(adds !! 2)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" => add 3, "ADD12" => add 1 2)
(addDict !! "ADD3") 1

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3


add 2
//////////////////////////////
// Dev Notes
//////////////////////////////


Broken things: 
    Lambda matching doesn't work with curried functions...not sure how to fix this :/
    Need to make list matching recursively collapse.
    --List comprehensions example [1..4] with functions. Need to make CPS?

NEED TO ADD DO STATEMENTS AND SLEEP!!!!!



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000





//////////////////////////////////////////
// Pattern matching is beginning to work


need to get unions and == /= comparisons working!!!!!!!!!!!!!!!!!!!!!!


data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


h == Hydra -- THIS SHOULD WORK BUT DOESN'T!!!





let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching


let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error


let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head


-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster


2 + 3


case 3 of
    3 > 2 -> 1


-- REQUIRES TAIL RECURSION!
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Queue for compiling
Will need to implement a queue for compiling commands. Once this becomes networked it's possible commands may try to be compiled in tandem, and espcially if an error is thrown during one of them it could create very bad problems. Using a queue, commands are added to it and the compiler runs on one command at a time in the queue until it's worked through the entire queue. 


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]


// let in functions now work.
let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1





make (:: exp) useful for partial application
? existential argument

cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

--Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.

arrows:
func1 >>> func2 >>> func3 >>> func4
func1 <<< func2 <<< func3 << func4
where statements in data constructors?


/////////////////////////////////////////
POST 1.0 FEATURES
Pattern matching
Guards
/////////////////////////////////////////



//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2










-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 2






-- Misc test code

let actors = mapSpawn (\x -> last $ ) [1..6]


// SCOPING PROBLEMS WITH RECURSION :(
let fib n = case n of
    0        -> 0
    1        -> 1
    _        -> (fib (n - 1)) + (fib (n - 1))

fib 7

let recur x = if x > 50 then x else recur (x + 1)

recur 1

let factorial n = case n of
    0    -> 1
    _    -> n * (factorial (n - 1))


factorial 5
4 * 3 * 2 * 1 * 5
factorial 0 = 1  
factorial n = n * factorial (n - 1)  


data MyType{d = 4}

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" => "kj", "Doom2" => 2, "Doom3" => 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r

let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793




-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add) [1..9]
(adds !! 2) (-1)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" => add 3, "ADD12" => add 1 2)
(addDict !! "ADD3") 1
(addDict !! "ADD12")

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3
let double x = x * 2
double
double 10
add
add 2
lookup 1

-- This shit is brokorzed
let combo = add 3 . div 4
combo 6
map (add 3 . mul 0.1) [1..9]
div 3 . add 2 $ 5

3 / 7

North /= West
zipFlat [1..9] [27,53..1000]
flip subtract 2 3
clientName
even 10
odd (-4)
[[x,y] | x <- [1..50], y <- [1..90]]
[x | x <- [1..10], even x]


[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..25]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

(3<=) 

2 - (-1)
2 : [3]
add (-1) 2
subtract
map (subtract) [1..9]
minus
minus 3 1
subtract 3 1
add x y = x + y

(+1) . (3/) . (subtract 1) . (1-) $ 5

let x = 11
let y = 22
4 << 3
add 2 3 >> div 2
3 >> add 2
add 2 $ 3

add 2 << 3

let one = 6
2 + (-one)

(5 >>) (div 3)


map (subtract 2) [1..9]

5 >> div 3 >> add 2 >> mul 6
5 >> (/3) >> (+2) >> (*6) >> (3+) >> (66-)

((3 / 5) + 2) * 6

mul 6 << add 2 << div 3 << 5
5 >> (div 3) >> (add 2) >> mul 6 >> (/3) >> (*2) >> (3/)
add 2 . div 3 $ 5
map (5 >>) $ map (div) [1..9]
map (5 >>) $ map (3/) [1..9]

add 2 << (div 3 << 5)
5 >> div 3 >> add 2
(5 >>) (div 3)
5 >> div 3
