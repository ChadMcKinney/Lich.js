//////////////////////////////
// Dev Notes
//////////////////////////////



NEED TO ADD DO STATEMENTS AND SLEEP!!!!!



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


add 2 $ 3


//////////////////////////////////////////
// Pattern matching is beginning to work


need to get unions and == /= comparisons working!!!!!!!!!!!!!!!!!!!!!!


data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


h == Hydra -- THIS SHOULD WORK BUT DOESN'T!!!





let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching


let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error


let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head


-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster


2 + 3


case 3 of
    3 > 2 -> 1


-- REQUIRES TAIL RECURSION!
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Queue for compiling
Will need to implement a queue for compiling commands. Once this becomes networked it's possible commands may try to be compiled in tandem, and espcially if an error is thrown during one of them it could create very bad problems. Using a queue, commands are added to it and the compiler runs on one command at a time in the queue until it's worked through the entire queue. 


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]


// let in functions now work.
let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1





make (:: exp) useful for partial application
? existential argument

cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

--Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.

arrows:
func1 >>> func2 >>> func3 >>> func4
func1 <<< func2 <<< func3 << func4
where statements in data constructors?


/////////////////////////////////////////
POST 1.0 FEATURES
Pattern matching
Guards
/////////////////////////////////////////



//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2










-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 2






-- Misc test code

let actors = mapSpawn (\x -> last $ ) [1..6]


// SCOPING PROBLEMS WITH RECURSION :(
let fib n = case n of
    0        -> 0
    1        -> 1
    _        -> (fib (n - 1)) + (fib (n - 1))

fib 3

let recur x = if x > 50 then x else recur (x + 1)

recur 1

let factorial n = case n of
    0    -> 1
    _    -> n * (factorial (n - 1))


factorial 5
4 * 3 * 2 * 1 * 5
factorial 0 = 1  
factorial n = n * factorial (n - 1)  


data MyType{d = 4}

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" => "kj", "Doom2" => 2, "Doom3" => 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r


let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793




-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let combo = add 3 . div 4
combo 6
add 3 . div 4 $ 6


let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add 1) [1..9]
(adds !! 2)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" => add 3, "ADD12" => add 1 2)
(addDict !! "ADD3") 1

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3


add 2
//////////////////////////////
// Dev Notes
//////////////////////////////


Broken things: 
    Lambda matching doesn't work with curried functions...not sure how to fix this :/
    Need to make list matching recursively collapse.
    --List comprehensions example [1..4] with functions. Need to make CPS?

NEED TO ADD DO STATEMENTS AND SLEEP!!!!!



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000





//////////////////////////////////////////
// Pattern matching is beginning to work


need to get unions and == /= comparisons working!!!!!!!!!!!!!!!!!!!!!!


data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


h == Hydra -- THIS SHOULD WORK BUT DOESN'T!!!





let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching


let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error


let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head


-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster


2 + 3


case 3 of
    3 > 2 -> 1


-- REQUIRES TAIL RECURSION!
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Queue for compiling
Will need to implement a queue for compiling commands. Once this becomes networked it's possible commands may try to be compiled in tandem, and espcially if an error is thrown during one of them it could create very bad problems. Using a queue, commands are added to it and the compiler runs on one command at a time in the queue until it's worked through the entire queue. 


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]


// let in functions now work.
let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1





make (:: exp) useful for partial application
? existential argument

cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" => 555)
(someVar => 555, "A String" => [1,2,3], 1.5 => "Three")
let doom = ("Doom" => 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" => "doom") : doom
let doom2 = ("Doom3" => 2, "Liar" => "Face") : doom

// You can also use the insert function
insert ("frogs" => [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"

//////////////////////////////////////////
// Case Statements Now Work

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"



/////////////////////////////////////////
// Parsing modes: Module and Interactive

--Have two parsing modes. One for library code and one for interactive mode. Lib code is like .hs files, with modules and imports at the top and normal, but interactive mode requiring the use of 'let' for global scope variable declaration.

arrows:
func1 >>> func2 >>> func3 >>> func4
func1 <<< func2 <<< func3 << func4
where statements in data constructors?


/////////////////////////////////////////
POST 1.0 FEATURES
Pattern matching
Guards
/////////////////////////////////////////



//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100

//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2










-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 2






-- Misc test code

let actors = mapSpawn (\x -> last $ ) [1..6]


// SCOPING PROBLEMS WITH RECURSION :(
let fib n = case n of
    0        -> 0
    1        -> 1
    _        -> (fib (n - 1)) + (fib (n - 1))

fib 7

let recur x = if x > 50 then x else recur (x + 1)

recur 1

let factorial n = case n of
    0    -> 1
    _    -> n * (factorial (n - 1))


factorial 5
4 * 3 * 2 * 1 * 5
factorial 0 = 1  
factorial n = n * factorial (n - 1)  


data MyType{d = 4}

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" => "kj", "Doom2" => 2, "Doom3" => 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r

let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793




-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add) [1..9]
(adds !! 2) (-1)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" => add 3, "ADD12" => add 1 2)
(addDict !! "ADD3") 1
(addDict !! "ADD12")

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3
let double x = x * 2
double
double 10
add
add 2
lookup 1

-- This shit is brokorzed
let combo = add 3 . div 4
combo 6
map (add 3 . mul 0.1) [1..9]
div 3 . add 2 $ 5

3 / 7

North /= West
zipFlat [1..9] [27,53..1000]
flip subtract 2 3
clientName
even 10
odd (-4)
[[x,y] | x <- [1..50], y <- [1..90]]
[x | x <- [1..10], even x]


[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..25]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

(3<=) 

2 - (-1)
2 : [3]
add (-1) 2
subtract
map (subtract) [1..9]
minus
minus 3 1
subtract 3 1
add x y = x + y

(+1) . (3/) . (subtract 1) . (1-) $ 5

let x = 11
let y = 22
4 << 3
add 2 3 >> div 2
3 >> add 2
add 2 $ 3

add 2 << 3

let one = 6
2 + (-one)

(5 >>) (div 3)


map (subtract 2) [1..9]

5 >> div 3 >> add 2 >> mul 6
5 >> (/3) >> (+2) >> (*6) >> (3+) >> (66-)

((3 / 5) + 2) * 6

mul 6 << add 2 << div 3 << 5
5 >> (div 3) >> (add 2) >> mul 6 >> (/3) >> (*2) >> (3/)
add 2 . div 3 $ 5
map (5 >>) $ map (div) [1..9]
map (5 >>) $ map (/) [1..9]

add 2 << (div 3 << 5)
5 >> div 3 >> add 2
(5 >>) (div 3)
5 >> div 3

spawn add [2,3]
spawn (add 2) [3]
spawn (\x y -> x / y * 666) [1,2]

data MyType{d = 4}

let myLoop m =
   receive
       "test"        -> myLoop $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn #Test2 myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let newLoop = spawn #Test myLoop [MyType 5]

"test" :>> #Test
"finished" :>> #Test

let makeData x = MyType x
makeData 1
let m = MyType
let n = m { d = m::d + 1 }
m
n

data Monster { size = 6 }
let makeMonster x = Monster x
let monsterFactory maker =
    receive
        [x] -> maker x

let monsterActor = spawn #Monster (monsterFactory) [makeMonster]
[666] :>> monsterActor

map (map (/3)) [[x,y] | x <- [1..9], y <- [1..9], odd x, even y]
map (map (/3)) ("Doom" => [1..9], "Three" => [1..3])
replicate 3 $ replicate 3 $ replicate 3 0
deepMap (2+) $ replicateN [2,3,1,2] [1..9]
deepMap (2+) [1,2,[3],4,[[5]]]

print 1
2 + 2

spawn #print (\x -> x myName) [print]

let double x = x * 2

let printAndDouble x = do 
    print x
    double x

let printAndTriple x = do print x; print( x * 2); x * 3

printAndDouble 20

printAndTriple 10


-- Mountains of Madness testing
compile "MountainsOfMadness"
let actor = spawn #Madness madnessLoop [demoGame]

(Walk north "casiosk1") :>> actor
(Look north "casiosk1") :>> actor
Finish :>> actor

(Walk north "casiosk1") :>> #Madness
(Look north "casiosk1") :>> #Madness
Finish :>> #Madness

(findSomethingWithName "casiosk1") demoGame


chat ";lkwedlkwwf;lwkewe;ldkwd;lwkfwf;lkwef;lwkf"

clientName
1 + 1
random 1 7

spawn #ChatActor (chat) ["Hello, world."]
spawn #ChatActor (actorChat) ["Hello, world." + (random 0 1)]

importjs "../Pieces/MountainsOfMadnessPanel.js"
updateNarration "Yo!"
spawn #ChatActor (updateNarration) ["Hello, world."]
updateNarration


-- Guards are in
let myGuard (x:xs) 
    | x > 4 = 99
    | _ = 100

myGuard [1..9]



let whereGuard (x:xs) = y x
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard [1..99]
whereGuard [11..99]

let whereGuard2 = y
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard2 1
whereGuard2 11

let fib n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib (n - 1) + fib (n - 2)

fib 8

setTempo 60
setTempo 300

let tempoSetter x = do setTempo x; sleep 0.1; tempoSetter $ random 60 1000
tempoSetter 60



{-
    Sequencing Ideas!!!!!
-}


-- Percussion sequencing is similar to tidal, but _ represents a rest, space seperates identifiers. We use | like in list comprehensions, but here they're for tempo multipliers and offsets
pattern     +> bass _
pattern2    +> _ snare
pattern3    +> _ hi
pattern4    +> down down down _ down [_ _ down] | (*4)
pattern     +> a | (*2) (\x -> 1 / x) (*3) (/4)

-- We can predefine percussive patterns without assignment using lambda style syntax (+>). This will create a new pattern without autoplaying for storage.
(+> a b c)
(+> a b [hi hi [_ low low hi]] | (+4))
-- Melodies use a similar scheme. Spaces separate numbers. Wild cards are rests. We use | like list comprehension but for offsets/multipliers which themselves can be sequenced with _ being default
octoSynth ~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-) (sqrt) _ _ _

-- Lambda style melody pattern
(~> synth1 1 2 3)
(~> synth2 1 2 3 44 2 4 _ _ _ 1 _ (-4) 9 1 23 | (* 3) (/4) _ (+1) )
(~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-))
-- We can pass any function expecting one argument, including lambdas
(~> bass 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (sqrt) _ (\x -> if odd x then x + 1 else x))
-- We can also use lists like in Perc Sequencing to get tuples
(~> noise 1 2 [3 4 5] 1 [[1 2] 3])


let s = (sine 440) >> gain 0.5 >> play
stop s

let s = sine 3 >> gain 33 >> sine >> gain 666 >> sine >> gain 0.3 >> play
s >> stop

let s2 = sine 0.5 >> gain 66 >> sine >> gain 600 >> sine >> gain 0.3 >> play
s2 >> stop

let s3 = pulse 7 >> gain 66 >> pulse >> gain 33 >> pulse >> gain 0.2 >> play
s3 >> stop


let s4 = tri 2 >> gain 4 >> tri >> gain 99 >> pulse >> gain 0.2 >> play
s4 >> stop


let s5 = tri 66 >> gain 3 >> tri >> gain 14 >> pulse >> gain 0.3 >> play
s5 >> stop


let s = play (tri 440 >> gain 0.2)
stop s


let table = waveTable 33 (map (random 0) $ cycle 15 [(-1), 1]) >> play
stop table

let table = waveTable 33 (map (sin) [1..99]) >> play
stop table


-- Filters

let allpasser =  (dry * 0.5) + (wet * 0.5) >> play
    where
        dry = (pulse 88) * ((saw 60) * 0.1)
        wet = dry >> allpass (100) (sinOsc 0.5)

stop allpasser



-- Function Composition Styles for Synth Definitions

let testFunc = play . sinOsc . gain 440 $ sinOsc 33
stop testFunc

let testFunc = sinOsc 33 >> gain 440 >> sinOsc >> play
stop testFunc

let testFunc = play(sinOsc (gain 440 (sinOsc 33)))
stop testFunc


let p = (playBuf (choose sampleList) 2 0 2) >> play
stop p

let convolver = pulse 2 >> convolve "cluster" >> play
stop convolver

let filterer = pulse 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> notch 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = pulse 33 >> lowshelf 33 16 >> gain 0.3 >> play
stop filterer

let filterer = pulse 33 >> highshelf 3333 16 >> gain 0.3 >> play
stop filterer

let filterer = pulse 33 >> peaking 3333 16 30 >> gain 0.3 >> play
stop filterer