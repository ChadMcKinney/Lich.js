//////////////////////////////
// Dev Notes
//////////////////////////////


//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000

//////////////////////
// Patterns
//////////////////////

"p" functions are pattern functions. These functions return lambdas that when given a beat will return a value.

let s = pseq [pseq [0,pseq [0.5, 666]], pseq [1,10], pseq [2,20]]
foldl (\acc t -> print $ s::p t) 0 [0..12]

let sh = prand [pseq [555,666,777], 1, 2]
foldl (\acc t -> print $ sh::p t) 0 [0..12]

let ws = pwrand [0.5, 0.25, 0.25] [pseq [555,666,777], 1, 2]
foldl (\acc t -> print $ ws::p t) 0 [0..12]

let ps = pshuf [0..4]
foldl (\acc t -> print $ ps::p t) 0 [0..12]

let st = pstutter 3 $ pseq [0..5]
foldl (\acc t -> print $ st::p t) 0 [0..12]

let pw = pwrap 3 6 (pseq [0..7])
foldl (\acc t -> print $ pw::p t) 0 [0..12]

let ps = pseries 2 5
foldl (\acc t -> print $ ps::p t) 0 [0..12]

let ps = pwrap 0 13 $ pseries 0 2
foldl (\acc t -> print $ ps::p t) 0 [0..12]

let pg = pgeom 1 2
foldl (\acc t -> print $ pg::p t) 0 [0..12]

let pg = pwrap 0 13 $ pgeom 1 2
foldl (\acc t -> print $ pg::p t) 0 [0..12]

let pr = preverse $ pseq [0..4]
foldl (\acc t -> print $ pr::p t) 0 [0..12]
treverse pr

-- nested patterns
let pgs = pseq [pgeom 1 2, 0.666]
foldl (\acc t -> print $ pgs t) 0 [0..12]

-- pwarp and bwarp
let si freq => sin freq >> perc 0 0.3 0.15
siner ~> si (pwarp -1 $ pseq [444,555,666,777]) -- acts like reverse
stop siner

let si freq => sin freq >> perc 0 0.3 0.15
siner ~> si (pwarp (1/3) $ pseq [444,555,666,777]) -- acts like pstutter 3
stop siner

let si freq => sin freq >> perc 0 0.3 0.15
siner ~> si (pwarp (pseq [13.5,pseq [-5.3, 1]]) $ pseq [444,555,666,777]) -- you can use patterns for the warp amount
stop siner

let si2 => sin (twarp (1/3) (pseq [444,555,666,777])) >> perc 0 0.3 0.2 -- used as a "t" pattern in a synthdef
siner2 +> si2 si2 [si2 si2] si2 -- interlocking pattern between rhythmand t pattern

let s => sin 440 >> perc 0 0.3 0.3
let s2 => sin 666 >> perc 0 0.3 0.3
let s3 => sin 777 >> perc 0 0.3 0.3
siner2 +> (pseq [s2,s3,s]) (pwarp (pseq [(1/3),(1/4)]) $ pseq [s,s3,s2]) | (/2)
stop siner2


context::currentTime -- get the current time of the audio context
currentBeat 0 -- get the current beat, given the global tempo

-- "b" functions are mirrored after their "p" pattern counter parts, but are based on the current global beat
bseq [pseq [666,777,888],1,2] -- evaluate multiple times to see the different values
bshuf [0..5]
bstutter 3 (pseq [0..4])
bwrap 1 7 $ pseries 1 5

-- This is really useful for synths, especially if you want to use a synth in an impulse stream
sin (bstutter 2 $ pshuf [555, 666, 777]) >> perc 0 0.3 0.3 >> play
sin (twrap 440 777 $ pseries 440 88) >> perc 0 0.3 0.3 >> play

-- we want to declare the shuffled pattern ahead of time otherwise it will get generated anew each time. You can re-evaluate to generate a new seq.
let shuffled = pseq [preverse ps, ps] where ps = pshuf [3..8]  
let si => degree2Freq slendro (mul (bseq [1,2,3,2]) $ bstutter 2 shuffled) >> sin >> perc 0 0.2 0.25
siner +> si
siner2 +> si [_ si] [_ si] si | (*3)
stop siner
stop siner2


let si freq => sin freq >> perc 0 0.3 0.3
siner ~> si (pseq [444,555,666,777]) 999
stop siner

let s => sin 440 >> perc 0 0.3 0.3
let s2 => sin 666 >> perc 0 0.3 0.3
let s3 => sin 777 >> perc 0 0.3 0.3
siner2 +> (pseq [s2,s3,s]) (pseq [s,s3,s2,s]) | (/2)
stop siner2


-- pbind is similar to the SuperCollider Pbind. 
-- It takes a pattern name (used to store in a global dict), a func (can be a pattern), an array of arguments (each can be a pattern), and a duration (can be pattern)
-- pbind name func arguments duration
let t f q => sin (f / q) >> pan -1 >> perc 0 0.5 0.3
let u f q => sin (f * q) >> pan 1 >> perc 0 0.5 0.3
let testp = pbind "test" (pseq [t,u,t,t,u,u,u]) [pshuf [666,777,888,999], pseq [1,1/2,2]] (pshuf [1/2,1/2,1,1/2,1/2])


-- You can get the current value of a pbind pattern using myPbind::value.
testp::value -- updates with the pattern. Be careful, this is a mutating value!! IMPURE!


-- Solo Streams can now have modifiers for rhythm.
let sa freq => saw (freq + (sin 3 >> gain 5)) >> add (saw (freq/2)) >> lowpass (freq * 2) 5 >> perc 0.0 0.2 (tseq [0.3,1])
sawer ~> sa 1 [2 2] 3 4 [3 3] | (*444) (*555) (*333) | _ _ (*2) (*2)


-- | UGen like patterns!

-- EXECUTE THIS FIRST
let s freq => sin freq >> perc 0 0.3 0.3

-- psin
siner ~> s (psin 0.05) | (\x -> degree2Freq bartok (x * 5 + 10))

let s freq => sin freq >> perc 0 0.3 0.3
siner ~> s (psin $ pseq [0.2,0.05]) | (\x -> degree2Freq bartok (x * 5 + 10))

-- psaw
siner ~> s (psaw 0.2) | (\x -> degree2Freq bartok (x * 5 + 10))

-- ptri
siner ~> s (ptri 0.2) | (\x -> degree2Freq bartok (x * 5 + 10))

-- psquare
siner ~> s (psquare 0.2) | (\x -> degree2Freq bartok (x * 5 + 10))

-- pselect
siner ~> s (pselect (prand [0,1]) [pseq [444,555,666],pseq [888,777,666]])

-- pclip
siner ~> s (pclip 500 600 (pseq [300,325..800]))

-- pfold
siner ~> s (pfold 500 600 (pseq [300,325..800]))

-- pmul
siner ~> s (pmul (pseq [440,666,777]) (pseq [1..4]))

-- pdiv
siner ~> s (pdiv (pseq [440,666,777]) (pseq [1..4]))

-- padd
siner ~> s (padd (pseq [440,666,777]) (pseq [0,111]))

-- pminus
siner ~> s (pminus (pseq [440,666,777]) (pseq [0,111]))

-- pmod
siner ~> s (pmod (pseq [3440,3666,3777]) (pseq [777,888]))

-- ppow
siner ~> s (ppow (pseq [2,3]) (pseq [5..9]))

-- pdelay, delay times can be negative!
siner ~> s (pdelay (pmul 50 $ psin (1/6)) $ pseq [444,555,666,777])

-- pcomb, delay times can be negative!
siner ~> s (pcomb (pmul 50 $ psin (1/6)) $ pseq [444,555,666,777])

-- pcrush, bit crush a pattern
siner ~> s (pcrush (psaw (1/3)) $ psin (1/5)) | (\x -> degree2Freq bartok (x * 5 + 10))

-- ptcrush, bit crush the time sequence of a pattern
siner ~> s (ptcrush 0.05 $ psin (1/5)) | (\x -> degree2Freq bartok (x * 5 + 10))

-- pdust
siner ~> s (pdust 0.5) | (\x -> degree2Freq bartok (x * 5 + 10))

-- pfir
siner ~> s (pfir [1,-0.651,1.7] $ psaw 0.2) | (\x -> degree2Freq bartok (x * 5 + 10))

-- prange, to be used with -1 to 1 patterns, namely psin, psaw, ptri, psquare, and pdust
siner ~> s (psaw 0.1 >> prange 400 4000)

-- pexprange, to be used with -1 to 1 patterns, namely psin, psaw, ptri, psquare, and pdust
siner ~> s (psaw 0.1 >> pexprange 400 4000)

-- Binary operators and patterns
let si freq => sin freq >> perc 0 0.3 0.15
siner ~> si (pseq [444,555,666,777] + pseq [111,222,333])
siner ~> si (pseq [444,555,666,777] - pseq [111,222,333])
siner ~> si (pseq [444,555,666,777] * pseq [1,2,3])
siner ~> si (pseq [444,555,666,777] / pseq [1,2,3])
siner ~> si (pseq [444,555,666,777] % pseq [555,666,777])
siner ~> si (pseq [15,16,17] ^ pseq [2,3])
siner ~> si (pseq [444,555,666,777] .>> pseq [1,2,3])
siner ~> si (pseq [444,555,666,777] .<< pseq [1,2,3])
siner ~> si (pseq [444,555,666,777] .| pseq [200,500,1000])
siner ~> si (pseq [444,555,666,777] .& pseq [11111,22222,33333])
siner ~> si (pseq [444,555,666,777] .^ pseq [200,512,1000])


-- Patterns as modifiers (Play these together as a mini piece) ---------------------------------------------------------------
let bd => square 78.487 >> perc 0 0.3 0.1
let sn => white 1 >> perc 0 0.3 0.1
let hh => violet 1 >> bandpass 1569.75339 100 >> perc 0 15 0.125
hat +> hh | (*2)
drums +> bd sn bd [sn sn] | (pwarp (ptri 0.1) $ pseq [(*1),(*1),(/2),(/2)])


let m freq => saw freq + saw (freq/(choose [2,4,8])) >> perc 0 0.2 (exprandom 0.075 1)
mel ~> m 1 2 3 4 5 6 | (degree2Freq kumoi) | (pwarp (ptri 0.1) $ pseq [(*1),(*1),(/2),(/2)])

let m2 freq => saw (freq/2) + saw (freq/(choose [1,8])) >> perc 0 0.2 (exprandom 0.1 0.5)
mel2 ~> m2 (pseq [7,7,5,6,6] >> pstutter 14) | (degree2Freq kumoi) | (pwarp (ptri 0.1) $ pseq [(*1),(*1),(*1.5),(/2),(/2)])
------------------------------------------------------------------------------------------------------------------------------



/////////////////////
// State Monad
/////////////////////

let testdo = do
    x <- get
    mprint x -- mprint is a monadic print that allows for easy printing with do syntax
    put (x + 1)
    y <- get
    mprint y
    mprint "Hello, world."
    result (y + 1)

runState testdo 0
evalState testdo 8
execState testdo 0
runState (result 5 >>= \x -> mprint x >>= \_ -> mprint "Hello, world.") 0
let m = (result 5 >>= \x -> mprint x >>= \x -> result x)
runState m 99
runState (m >>= \_ -> result 10) 0
runState (mprint 5 >>= \x -> result x) 0


-- lift
let testdo = do
    x <- get
    lift play (sin x >> perc 0 0.7 2)
    put (x + 13)
    y <- get
    lift play (sin y >> perc 0 0.7 2)
    result (y + 1)

let m = 440
let m = evalState testdo m -- Continually rises on execution


-- Stack example (borrowed from Learn You a Haskell)
let pop = State (\(x:xs) -> Result x xs)
let push a = State (\xs -> Result Nothing (a:xs))

let stackManip = do
    push 3
    pop
    pop
    
    
runState stackManip [5,8,2,1]

let stackStuff = do
    a <- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8
            
runState stackStuff [9,0,2,1,0]



//////////////////////////////////////////
// Pattern matching 

data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching

let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error

let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head

-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster



-- Won't work, requires TCO.
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1



cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" = 555)
(someVar = 555, "A String" = [1,2,3], 1.5 = "Three")
let doom = ("Doom" = 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" = "doom") : doom
let doom2 = ("Doom3" = 2, "Liar" = "Face") : doom

// You can also use the insert function
insert ("frogs" = [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"


//////////////////////////////////////////
// Case Statements

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"


//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100



-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" = [1,2], "Satan" = [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 



data MyType { d = 4 }

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" = "kj", "Doom2" = 2, "Doom3" = 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r


let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793


-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let combo = add 3 . div 4
combo 6
add 3 . div 4 $ 6


let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add 1) [1..9]
(adds !! 2)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" = add 3, "ADD12" = add 1 2)
(addDict !! "ADD3") 1

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3


-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add) [1..9]
(adds !! 2) (-1)

let double x = x * 2
double
double 10
add
add 2
lookup 1


North /= West
zipFlat [1..9] [27,53..1000]
flip subtract 2 3
clientName
even 10
odd (-4)
[[x,y] | x <- [1..50], y <- [1..90]]
[x | x <- [1..10], even x]


[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..25]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

(3<=) 

2 - (-1)
2 : [3]
add (-1) 2
subtract
map (subtract) [1..9]
minus
minus 3 1
subtract 3 1
add x y = x + y

(+1) . (3/) . (subtract 1) . (1-) $ 5

let x = 11
let y = 22
4 << 3
add 2 3 >> div 2
3 >> add 2
add 2 $ 3

add 2 << 3

let one = 6
2 + (-one)

(5 >>) (div 3)


map (subtract 2) [1..9]

5 >> div 3 >> add 2 >> mul 6
5 >> (/3) >> (+2) >> (*6) >> (3+) >> (66-)

((3 / 5) + 2) * 6

mul 6 << add 2 << div 3 << 5
5 >> (div 3) >> (add 2) >> mul 6 >> (/3) >> (*2) >> (3/)
add 2 . div 3 $ 5
map (5 >>) $ map (div) [1..9]
map (5 >>) $ map (/) [1..9]

add 2 << (div 3 << 5)
5 >> div 3 >> add 2
(5 >>) (div 3)
5 >> div 3

spawn add [2,3]
spawn (add 2) [3]
spawn (\x y -> x / y * 666) [1,2]

data MyType{d = 4}

let myLoop m =
   receive
       "test"        -> myLoop $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn #Test2 myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let newLoop = spawn #Test myLoop [MyType 5]

"test" :>> #Test
"finished" :>> #Test

let makeData x = MyType x
makeData 1
let m = MyType
let n = m { d = m::d + 1 }
m
n

data Monster { size = 6 }
let makeMonster x = Monster x
let monsterFactory maker =
    receive
        [x] -> maker x

let monsterActor = spawn #Monster (monsterFactory) [makeMonster]
[666] :>> monsterActor

map (map (/3)) [[x,y] | x <- [1..9], y <- [1..9], odd x, even y]
map (map (/3)) ("Doom" => [1..9], "Three" => [1..3])
replicate 3 $ replicate 3 $ replicate 3 0
deepMap (2+) $ replicateN [2,3,1,2] [1..9]
deepMap (2+) [1,2,[3],4,[[5]]]

print 1
2 + 2

spawn #print (\x -> x myName) [print]

let double x = x * 2

let printAndDouble x = do 
    print x
    double x

let printAndTriple x = do print x; print( x * 2); x * 3

printAndDouble 20

printAndTriple 10


-- Mountains of Madness testing
compile "MountainsOfMadness"
let actor = spawn #Madness madnessLoop [demoGame]

(Walk north "casiosk1") :>> actor
(Look north "casiosk1") :>> actor
Finish :>> actor

(Walk north "casiosk1") :>> #Madness
(Look north "casiosk1") :>> #Madness
Finish :>> #Madness

(findSomethingWithName "casiosk1") demoGame


chat ";lkwedlkwwf;lwkewe;ldkwd;lwkfwf;lkwef;lwkf"

clientName
1 + 1
random 1 7

spawn #ChatActor (chat) ["Hello, world."]
spawn #ChatActor (actorChat) ["Hello, world." + (random 0 1)]

importjs "../Pieces/MountainsOfMadnessPanel.js"
updateNarration "Yo!"
spawn #ChatActor (updateNarration) ["Hello, world."]
updateNarration


-- Guards are in
let myGuard (x:xs) 
    | x > 4 = 99
    | _ = 100

myGuard [1..9]



let whereGuard (x:xs) = y x
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard [1..99]
whereGuard [11..99]

let whereGuard2 = y
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard2 1
whereGuard2 11

let fib n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib (n - 1) + fib (n - 2)

fib 8

let fib n = case n of
    0 -> 0
    1 -> 1
    _ -> fib (n - 1) + fib (n - 2)


setTempo 60
setTempo 300

let tempoSetter x = do setTempo x; sleep 0.1; tempoSetter $ random 60 1000
tempoSetter 60



{-
    Sequencing Ideas!!!!!
-}


-- Percussion sequencing is similar to tidal, but _ represents a rest, space seperates identifiers. We use | like in list comprehensions, but here they're for tempo multipliers and offsets
pattern     +> bass _
pattern2    +> _ snare
pattern3    +> _ hi
pattern4    +> down down down _ down [_ _ down] | (*4)
pattern     +> a | (*2) (\x -> 1 / x) (*3) (/4)

-- We can predefine percussive patterns without assignment using lambda style syntax (+>). This will create a new pattern without autoplaying for storage.
(+> a b c)
(+> a b [hi hi [_ low low hi]] | (+4))
-- Melodies use a similar scheme. Spaces separate numbers. Wild cards are rests. We use | like list comprehension but for offsets/multipliers which themselves can be sequenced with _ being default
octoSynth ~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-) (sqrt) _ _ _

-- Lambda style melody pattern
(~> synth1 1 2 3)
(~> synth2 1 2 3 44 2 4 _ _ _ 1 _ (-4) 9 1 23 | (* 3) (/4) _ (+1) )
(~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-))
-- We can pass any function expecting one argument, including lambdas
(~> bass 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (sqrt) _ (\x -> if odd x then x + 1 else x))
-- We can also use lists like in Perc Sequencing to get tuples
(~> noise 1 2 [3 4 5] 1 [[1 2] 3])


let s = (sin 440) >> gain 0.5 >> play
stop s

let s = sin 3 >> gain 33 >> sin >> gain 666 >> sin >> gain 0.3 >> play
s >> stop

let s2 = sin 0.5 >> gain 66 >> sin >> gain 600 >> sin >> gain 0.3 >> play
s2 >> stop

let s3 = square 7 >> gain 66 >> square >> gain 33 >> square >> gain 0.2 >> play
s3 >> stop


let s4 = tri 2 >> gain 4 >> tri >> gain 99 >> square >> gain 0.2 >> play
s4 >> stop


let s5 = tri 66 >> gain 3 >> tri >> gain 14 >> square >> gain 0.3 >> play
s5 >> stop


let s = play (tri 440 >> gain 0.2)
stop s


let table = waveTable 33 (map (random 0) $ cycle 15 [(-1), 1]) >> play
stop table

let table = waveTable 33 (map (sin) [1..99]) >> play
stop table


-- Filters

let allpasser =  (dry * 0.5) + (wet * 0.5) >> play
    where
        dry = (square 88) * ((saw 60) * 0.1)
        wet = dry >> allpass (100) (sin 0.5)

stop allpasser



-- Function Composition Styles for Synth Definitions

let testFunc = play . sin . gain 440 $ sin 33
stop testFunc

let testFunc = sin 33 >> gain 440 >> sin >> play
stop testFunc

let testFunc = play(sin (gain 440 (sin 33)))
stop testFunc


let p = (playSample (choose sampleList) 2 0 2) >> play
stop p

let convolver = square 2 >> convolve "cluster" >> play
stop convolver

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> notch 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> lowshelf 33 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> highshelf 3333 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> peaking 3333 16 30 >> gain 0.3 >> play
stop filterer


-- range and exprange work!
let filterer = square 5 >> lowpass ((tri 1 >> range 1 100) * (sin 0.1 >> range 1 100)) 3 >> play
stop filterer

let filterer2 = square 13 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> play
stop filterer2


let glitter = (sin (sin 0.3 >> exprange 1 66)) * (sin 666) * (sin 3) >> delay (1/13) 0.9 >> gain 0.1 >> play

let glitter2 = (sin (sin 0.2 >> exprange 1 33)) * (sin (999)) * (sin 3) >> delay (4/13) 0.9 >> gain 0.1 >> play

let glitter3 = (sin (sin 0.5 >> exprange 1 66)) * (sin (666*2)) * (sin 2) >> delay (3/13) 0.5 >> gain 0.1 >> play

let glitter4 = (sin (sin 0.1 >> exprange 1 33)) * (sin (333*5)) * (sin 6.5) >> delay (1/13) 0.9 >> gain 0.1 >> play


let guitar = (saw 80) * (square 3) >> lowpass (sin 0.1 >> exprange 20 2000) 10 >> delay (1/3) 0.9 >> gain 0.3 >> play
stop guitar



let kick => square 80 >> perc 0.0 0.7 0.05
kicker +> kick _

let snare => square (80 * 16) >> perc 0.0 0.7 0.05
snarer +> _ snare

let hihate => tri (mul 80 $ randomI 1 32) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _ _
hater2 +> _ _ hihate _ _ _
hater2 +> _ hihate _ _ _ _ _
hater3 +> hihate _ _
hater4 +> hihate _ _ _ _ _ _ _ _

setTempo 500
setTempo 1000

-- Metric Onset Test, should produce consistent quarter notes no matter the timing of the starts
let hihate => tri (mul 80 $ randomI 1 24) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _
hater2 +> hihate _ _ _
hater2 +> _ _ hihate _
hater3 +> _ _ _ hihate



-- Just Intonation Fun

let glitter4 = (sin (saw 0.1 >> exprange 1 40)) * (sin (160*10)) * (tri 6.5) >> delay (1/3) 0.3 >> gain 0.1 >> play

let k => tri 40 >> lowpass 320 1 >> perc 0.0001 1 0.3
kicker +> k _ _ k _ _ k _ | (/2)

let hh => sin (mul 80 12) >> perc 0.0 0.4 0.05
hate5 +> _ hh | (/2)

let hh2 => sin (160 * 10) >> perc 0 0.3 0.1
hate2 +> hh2 hh2 _

let hh3 => white 10 >> bandpass (80 * 17) 455 >> gain 10 >> perc 0.0001 1 0.1
hihate3 +> hh3 _ _ | (/2)
hihate4 +> hh3 _ _ _ _ | (/2)

let snare => white >> perc 0.0 0.7 0.5
let lkick => square 40 >> perc 0.001 0.7 0.4
lkicker +> lkick snare [_ lkick] snare | (*2)


let guitar => (saw (40 * (randomI 1 10))) * (sin 3) >> lowpass (80*17) 10 >> delay (1/5) 0.4 >> perc 0.1 0.3 3
guitarer +> guitar _ guitar _ _ guitar _ _

let filterer2 = square 80 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> gain 0.3 >> play
stop guitarer
stop filterer2
stop glitter4



setTempo 300

let cluster => square 20 >> waveShape (map (nsin) [1..99]) >> lowshelf 40 12 >> perc 0 1 0.1
clusterz +> cluster _ cluster cluster | (/2)
let cluster2 => square 20 >> waveShape (map (nsin) [1..179]) >> perc 0 1 0.1
clusterz2 +> _ cluster2 _ | (/2)
let cluster3 => square 20 >> waveShape (map (nsin) [1..199]) >> perc 0 1 0.05
clusterz3 +> _ cluster3 | (/2)
clusterz4 +> cluster3 _  _ cluster3 | (/2)
let cluster0 => white 1 >> perc 0 0.4 0.5
clusterz0 +> _ cluster0 | (*2)



-- Melody sequencing is beginning to work!
let hh => white >> bandpass (100 * 32) 50 >> perc 0 3 0.1
hhh +> hh [_ hh] [_ hh] hh

let hh2 => white >> bandpass (100 * 16) 100 >> gain 20 >> perc 0 0.5 0.05
hhh4 +> hh2 hh2 | (/2)

let snare => white >> perc 0.0 0.7 0.3
let ss => white >> bandpass (340 * 8) 100 >> gain 30 >> perc 0.0 1 0.1
let lkick => square 80 >> add (tri 40) >> perc 0 0.6 0.1
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let bass freq => (sin freq) + white >> lowpass (freq * (pow 2 $ randomI 1 3)) 40 >> perc 0.01 0.3 (random 0.05 3)
bassSeq ~> bass 20 42.5 _ 80 160 _ 190 | (*2) (/2) (*1.75) _ _ (*1.5) (*2) _

let bass2 freq => (square freq) + white >> lowpass (freq * (pow 2 $ randomI 2 3)) 40 >> perc 0.0 0.6 0.1
bassSeq2 ~> bass2 [20 42.5] [42.5 80] [160 160] [190 190] | (*2) _ (*1.75) _ _ (*1.5) (*2) _ (*1.5)

let plunk freq => (sin freq * 16) >> perc 0.0 0.1 0.05
plunkSeq ~> plunk [80 170] [40 42.5] [42.5 80] [160 160] [190 _ 190 20] | (*2) (*2) (*1.75) (*6) (*8) (*6) (*4) (*2) (*1.5)

stop lkicker2
stop hhh4
stop hhh
stop plunkSeq
stop bassSeq2

-- chill for a minute
stop bassSeq

-- spliceOsc is back!
spliceOsc "someString!" 5



///////////////////////////////////
// GRAPHICS TEST CODE
///////////////////////////////////

initGraphics 0 -- MUST DO THIS FIRST!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
setBackground (random 0 255) (random 0 255) (random 0 255)
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -100 100] [25, 25, 25] [random 0 (2*pi), random 0 (2*pi), random 0 (2*pi)] [0,200,150] 

setShader $ choose shaders
deleteMesh s
deleteMesh c

deleteScene
shaders
setShaders $ map (choose) $ replicate 3 shaders
clearShaders
wireframe true s
wireframe true c
wireframe false s
wireframe false c


wireframeAll (choose [true, false])

move [-1, -10, -2] s
move [-1, 1, -1] c
moveAll [random -1 1, random -1 1, random -1 1]

setColor [random 0 255, random 0 255, random 0 255] c
setColor [random 0 255, random 0 255, random 0 255] s
setColorAll [random 0 255, random 0 255, random 0 255]

rotate [random -1 1, random -1 1, random -1 1] c
rotateAll [random -1 1, random -1 1, random -1 1]

linear [0, 0, 1] c
linearAll [random -1 1, random -1 1, random -1 1]

angular [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1] c
angularAll [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1]

setPosition [random -50 50, random -50 50, random -50 50] s
setPositionAll [random -50 50, random -50 50, random -50 50]

scale [random 0.1 1, random 0.1 1, random 0.1 1] s
scaleAll [random 0.1 1, random 0.1 1, random 0.1 10]

-- supports streaming style syntax
s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]

cloudMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
gaussianMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
sinMesh (random 10 100) [random 0 255, random 0 255, random 0 255]

sinMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scaleAll [4, 4, 4]

let n = noiseMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] n
angular [0.01, 0.01, 0.03] n

deleteMesh n

let g = gaussianMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] g
angular [0.01, 0.01, 0.03] g

deleteMesh g


let s = squareMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [6,6,6] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let s = sawMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let t = triMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [10, 10, 10] t
angular [0.01, 0.01, 0.03] t

deleteMesh t

-- Won't be able to initially see it because of culling, set the angular!
let f = flatMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] f
angular [0.01, 0.01, 0.03] f

deleteMesh f
deleteScene
initGraphics

let s = sawMapMesh 20 20 [random 0 255, random 0 255, random 0 255]
scale [7, 7, 7] s
angular [0.01, 0.01, 0.03] s

spliceShader $ randomString $ random 1 5

-- Patterns are supported as well!
initGraphics
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -10 10] [50,50,50] [0.1,0,0] [random 0 255, random 0 255, random 0 255]
let meshSynth => s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]
let meshSynth2 => c >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1] >> angular [random 0 0.1, random 0 0.1, random 0 0.1]
meshSeq +> meshSynth meshSynth2 meshSynth [meshSynth2 meshSynth]

-- Shader sequencing, yay!
let shaderSynth => spliceShader $ randomString $ random 1 5
shaderSeq +> shaderSynth _ _ _



-- Bus and Feed Back tests

let s = square 1 >> auxOut 0 >> play
let s2 = saw 3 >> gain 0.1 >> auxOut 0 >> play
let v = auxIn 0 >> convolve "cluster" >> gain 0.5 >> play

stop s
stop s2
stop v

fade 1 v

-- We can use aux buses for feedback
let s3 = auxIn 1 >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough 1 >> gain 2 >> play
stop s3

-- We can also use a localBus so as to not collide with anything else that might use a particular auxillary bus
let s4 = feed >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough feed >> gain 2 >> play
    where feed = localBus 1

-- splice filters and feed back is cool, but they blow easily. Remember children, ctr-. is your friend!
square (saw 1 >> exprange 1 20000) >> add (auxIn 0 >> delay (1/3) 0 >> gain 0.9) >> spliceFilter (randomString 16) >> limiter -6 >> auxThrough 0 >> play

-- We can implement something similar with an fir and it will be much more stable
square (saw 1 >> exprange 1 20000) >> add (auxIn 0 >> delay (1/6) 0) >> fir [random -0.4 0.4 | x <- [1..10]] >> limiter -3 >> auxThrough 0 >> play


-- Scale testing code
let s freq => saw (freq) >> perc 0 0.4 0.75
sSeq ~> s 0 1 2 3 4 5 6 7 8 9 10 11 12 14 15 | (degree2Freq koto)s


-- Noises
white >> gain 0.4 >> play
clipNoise >> gain 0.4 >> play
pink >> gain 0.4 >> play
brown >> gain 0.4 >> play
violet >> gain 0.4 >> play

simplex 440 >> gain 0.4 >> play -- Not great for high frequencies
simplex 1 >> exprange 20 20000 >> sin >> gain 0.4 >> play -- cool lfo though
simplex 13 >> exprange 20 20000 >> sin >> gain 0.4 >> play
(square 40) * (saw 3 >> range 0 1) >> lowpass (simplex 0.3 >> exprange 20 20000) 20 >> gain 0.4 >> play

-- Simple averaging filters
square 440 >> gain 0.4 >> play -- For comparison
square 440 >> lpz1 >> gain 0.4 >> play
square 440 >> lpz2 >> gain 0.4 >> play
square 440 >> hpz1 >> gain 0.4 >> play
square 440 >> hpz2 >> gain 0.4 >> play
square 440 >> bpz2 >> gain 0.4 >> play
square 440 >> brz2 >> gain 0.4 >> play


-- Clip 
sin 440 >> clip 0.05 >> gain 4 >> play
sin 440 >> clip (tri 1 >> range 0 1) >> gain 0.4 >> play
-- Feedback clip modulation, use headhones!
square 40 >> clip (delay (1.6) 0 (auxIn 0) >> range 0.01 1) >> auxThrough 0 >> gain 0.4 >> play


-- Audio division works, yay!
sin (simplex 1 >> exprange 1 20000) >> delay (1/(simplex 0.79 >> exprange 2 100)) 0.9 >> gain 0.2 >> play

-- Bit Crunching and Decimation
sin 440 >> crush (sin 0.3 >> range 0.01 4) >> gain 0.25 >> play
sin 440 >> decimate (sin 0.3 >> range 100 8000) >>  gain 0.3 >> play
sin (simplex 1 >> range 20 20000) >> decimate (sin 0.3 >> range 100 8000) >>  gain 0.3 >> play

-- Wrapping and Folding
sin (simplex 1 >> exprange 1 2000) >> wrap 0.1 >> gain 3 >> play
sin (simplex 1 >> exprange 1 2000) >> fold 0.1 >> gain 3 >> play


-- Env takes a list of levels, and times (with times being a length of 1 less), and a shape value, 0 is linear 1 is exponential
let s = sin (env [20, 20000, 1000, 1] times 1 1) >> env [0, 0.5, 0.125, 0] times 0 >> play
    where times = [1, 2, 3]


let s freq => brown 1 >> perc2 0 1 0.01 >> pluck freq 1 0.9 >> perc 0 1 2
sSeq ~> s 0 1 2 3 4 5 6 7 8 9 10 11 12 14 15 | ((/2) . (degree2Freq justMajor))

-- phaser
white 1 >> phaser 0.333 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> phaser 0.333 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> phaser 2 >> gain 0.3 >> play

-- flanger
white 1 >> flanger 0.333 0.3 0.3 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> flanger 0.333 0.3 0.3 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> flanger 2 0.3 0.3 >> gain 0.3 >> play

-- chorus
white 1 >> chorus 4 0.1 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> chorus 0.333 0.5 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> chorus 2 0.5 >> gain 0.3 >> play

-- Mouse UGens
mouseX 400 20000 1 >> lag 0.1 >> sin >> add (sin (lag 0.1 $ mouseY 400 20000 1)) >> gain 0.3 >> play

-- First Order and Second Order filters
saw 200 >> fos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) >> gain 0.3 >> play
impulse 4 >> decay 0.5 >> fos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) >> gain 0.3 >> play

saw 200 >> sos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) (mouseX -0.5 0.5 0) (mouseY -0.5 0.5 0) >> gain 0.3 >> play
impulse 4 >> decay 0.5 >> sos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) (mouseX -0.5 0.5 0) (mouseY -0.5 0.5 0) >> gain 0.3 >> play

-- Simple Reverb
impulse 1 >> decay 0.5 >> gain (white 1) >> reverb 0.5 40 2 0.3 >> gain 0.3 >> play
saw (noiseX 1 >> exprange 20 20000) >> reverb 0.5 100 5 0.5 >> gain 0.3 >> play
playSample "Ra1" 1 2 3 >> reverb 0.5 50 2 0.2 >> play


-- Graphics Notes
Make Graphics API more like Audio API
you should use stop instead of delete
and envelopes should give a mesh a lifetime?
New graphics functionality:
2D Drawing
Mesh Morphing/Animation between meshes
Sphere/Rect Height Maps (heights wrap around surface)
Mesh loading from file, similar to sample loading
More shader generating code -- Compile Lich.js directly to a shader?

-- Language to do
Enforce purity: Done?!
    Prevent redefinition of variables at global scope in library compilation
    Prevent multiple declaration of variables in and let statements


-- Audio to do
Fix Node leaks with custom UGens -- Fixed? Need to implement disconnect via setTimeout for all inputs like in exprange
spliceFilter? -> Adds poles according to splice string characters -- Done, may take out though because it's so much code to load
Implement Limiter, writeBuf, and any other loose ends. Put in Master limiter? Done
Buses and Effects routing -- Done!?
Panning! -- Done, but can't modulate



square 440 >> gain 0.4 >> play
square 440 >> lpz1 >> gain 0.4 >> play
square 440 >> lpz2 >> gain 0.4 >> play
square 440 >> hpz1 >> gain 0.4 >> play
square 440 >> hpz2 >> gain 0.4 >> play
square 440 >> bpz2 >> gain 0.4 >> play
square 440 >> brz2 >> gain 0.4 >> play

simplex 440 >> gain 0.4 >> play -- Not great for high frequencies
simplex 1 >> exprange 20 20000 >> sin >> gain 0.4 >> play -- cool lfo though
simplex 13 >> exprange 20 20000 >> sin >> gain 0.4 >> play
(square 40) * (saw 3 >> range 0 1) >> lowpass (simplex 0.3 >> exprange 20 20000) 20 >> gain 0.4 >> play

simplex
sin 440 >> clip (tri 1 >> range 0 1) >> gain 0.4 >> play
square 40 >> clip (delay (1.6) 0 (auxIn 0) >> range 0.01 1) >> auxThrough 0 >> gain 0.4 >> play   

sin 440 >> clip 0.05 >> gain 4 >> play


setTempo 100

let bass2 freq => osc >> dist >> filt >> env
   where
       osc     = (square freq) + (square (freq*0.5) ) + (white 1)
       dist    = peaking (freq * 0.25 * (pow 2 $ randomI 2 3)) 40 20
       filt    = lowpass (freq * 0.25 * (pow 2 $ randomI 2 3)) 30
       env     = perc 0.0 0.6 1
       

bassSeq2 ~> bass2 [20 42.5] [42.5 80] [160 160 160 160] [190 _ 190] | (*2) _ (*1.75) _ _ (*1.5) (*2) _ (*1.5)


-- Gamelan improv stuff
let sinSynth freq => saw freq >> gain (sin 4 >> range 0 1) >> lowpass (freq * 2 * (sin 4 >> range 0 1)) 1 >> perc (random 0 0.5) 0.3 (random 1 5)
sinSeqer ~> sinSynth 1 _ _ 1 | (\x -> degree2Freq slendro (randomI -5 10))
sinSeqer3 ~> sinSynth _ 1 1 _ | (\x -> degree2Freq slendro (randomI -5 10))

stop sinSeqer

let sinSynth3 freq => saw freq >> gain (sin 4 >> range 0 1) >> lowpass (freq * 2 * (sin 4 >> range 0 1)) 1 >> perc 0 0.2 0.2
sinSeqer4 ~> sinSynth3 _ _ 1 _ | (\x -> degree2Freq slendro (randomI -5 10))
sinSeqer5 ~> sinSynth3 1 _ _ _ | (\x -> degree2Freq slendro (randomI -5 10))
stop sinSeqer5
let sinSynth2 freq => square freq >> gain 4 >> clip 0.1 >> gain 10 >> perc 0 0.4 4
sinSeqer2 ~> sinSynth2 1 _ _ _ | (\x -> degree2Freq slendro (randomI -15 -10))
let sinSynth3 freq => tri freq >> gain (sin 4 >> range 0 1) >> lowpass (sin 4 >> range 80 (freq * 2)) 0.0001 >> perc 0.0001 0.2 2
sinSeqer4 ~> sinSynth3 1 4 2 4 | (\x -> (/8) $ (*x) $ degree2Freq slendro (randomI -5 10))
stop sinSeqer4
let bd => tri (degree2Freq slendro -10) >> add (brown >> gain 1) >> lowpass 100 1 >> perc 0 3 0.25
let sd2 => sin (freq + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> bandpass freq 50 >> env [0, 1, 0.035, 0] [0, 0.05, 1] 0 >> auxThrough 0
    where freq = (degree2Freq slendro 5)
    
drumsD2 +> bd [_ bd] [_ sd2] sd2 | (*2)

let delayFX = auxIn 0 >> gain 1 >> lowpass 500 1 >> delay 0.5 0.6 >> play
stop delayFX


let bd => square (degree2Freq slendro (randomI -10 -5)) >> lowpass 300 1 >> perc 0 0.5 0.1
let sd2 => sin (degree2Freq slendro 10) >> perc 0 0.2 0.05
let sd2 => white 1 >> perc 0 0.2 0.1
drumsD2 +> bd _ [bd sd2] sd2 | (*2)

pink 1 >> gain 0.2 >> play


-- More ugen test code

noiseL (sin 1 >> range 1 13) >> exprange 400 4000 >> sin >> gain 0.3 >> play
noiseX (sin 1 >> range 1 30) >> exprange 400 4000 >> sin >> gain 0.3 >> play

linexp 10 0 20 1 2000


pink >> perc 0 1 0.06 >> play

slopeX 2000 1000 20 >> sin >> gain 0.3 >> play
slopeX 1000 2000 20 >> sin >> gain 0.3 >> play


impulse 13 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play


tri 0.1 >> exprange 400 2000 >> latch (impulse 7) >> sin >> gain 0.3 >> play

sin 1 >> exprange 400 2000 >> divider (noiseN 5 >> exprange 1000 40000) >> sin >> gain 0.3 >> play

square 80 >> divider (random 1 500) >> perc 0 0.5 2 >> play

noiseN 40 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play

square 5 >> gate (sin 440) >> gain 0.3 >> play

dust 10 >> play

dust 20 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play

sin (noiseN 3 >> exprange 1 30) >> range 0 3 >> select [sin (slopeX 1000 4000 20), sin 2000, sin (slopeX 4000 1000 20)] >> gain 0.3 >> play 
dust 30 >> stepper 1000 400 -100 >> sin >> gain 0.3 >> play

dust 10 >> sweep (sin 0.3 >> gain 1000) >> add 1000 >> sin >> gain 0.3 >> play
phasor 200 10000 (sin 0.3 >> gain 2) >> sin >> gain 0.3 >> play

sin 666 >> poll >> gain 0.3 >> play

crackle 1.95 >> sin >> gain 0.3 >> play

dust 5 >> trand 400 2000 >> sin >> gain 0.3 >> play
dust 5 >> trandX 400 2000 >> sin >> gain 0.3 >> play

impulse 10 >> coinGate 0.5 >> stepper 1000 400 -100 >> sin >> gain 0.2 >> play

-- Buffer UGens
playBuf (sin 440 >> recordBuf (newBuffer 1024) 1) 1 >> play
playBuf (fillBuffer $ map (nsin) [1..1024]) (noiseX 10 >> exprange 0.001 sampleRate) >> play
sin 440 >> recPlayBuf (newBuffer sampleRate) (noiseX 1) (noiseX 1 >> gain 2) >> gain 0.5 >> play
sin (noiseL 2 >> exprange 200 2000) >> recPlayBuf (newBuffer sampleRate) (noiseL 7) (sin (noiseX 1 >> exprange 1 40) >> gain (noiseL 3 >> range 0 4)) >> gain 0.5 >> play

-- Filters
square 2 >> range 400 1600 >> lag 0.1 >> sin >> gain 0.3 >> play
square 1 >> range 400 1600 >> lag (sin 0.1 >> range 0.001 1) >> sin >> gain 0.3 >> play
impulse 2 >> decay2 (sin 0.25 >> exprange 0.001 1) 2 >> gain (pink * 0.1) >> play
impulse 2 >> reson 1000 1 >> gain 0.5 >> play
impulse 2 >> reson (sin 0.3 >> exprange 400 4000) (tri 0.1 >> range 0.001 2) >> gain 0.05 >> play

-- Pluck
let kd = degree2Freq koto -- Compile this first!
white 1 >> perc2 0 1 0.05 >> pluck (kd (random -5 10)) 3 0.3 >> perc 0.01 0.15 1 >> play
pink 1 >> perc2 0.5 1 0.05 >> pluck (kd (random -5 10)) 3 0.3 >> perc 0.1 0.1 2 >> play
brown 1 >> perc2 1 0.3 3 >> pluck (kd (random -5 10)) 6 0.7 >> perc 1 0.5 3 >> play

let kSynth freq => white 1 >> perc2 0 1 0.05 >> pluck freq 6 0.3 >> perc 0.01 0.15 1
kMelody ~> kSynth (kd -12) _ (kd -8) _ (kd -4) (kd (choose [1, -1, -5])) (kd -9) (kd -5) | (*2) _ _ _ _ _ (*2) _
kMelody2 ~> kSynth (kd -12) _ (kd -8) (kd -4) _ (kd (choose [1, -1, -5])) _ (kd -9) _ (kd -5) | (*4) (*4) (*2)
stop kMelody
stop kMelody2

--cool pluck based synth
let kSynth freq => saw freq >> add (saw (freq*1.002)) >> perc2 0 1 1 >> pluck freq 1 0.9 >> perc 0.0001 0.4 0.2
kBass ~> kSynth [(kd -12) (kd -8)] [(kd -4) (kd (choose [-2, -4, -5]))] [(kd -9) (kd (choose [-7, -5]))] | (/2)


-- Cool flittery plucky melody
let kSynth3 freq => white 1 >> perc2 0 1 0.03 >> pluck freq (random 0.1 4) (random 0.05 1) >> perc 0.0 0.15 0.5
kMelody3 ~> kSynth3 [(kd -12) (kd -8)] [(kd -4) (kd (choose [-2, -4, -5]))] [(kd -9) (kd (choose [-7, -5]))] | (/2) _ _ (/2) _ (*2) _ (*2) (*4) _ (/2) _ _ (/2) _ (*2) (*4) (*8) _

-- Frequency shifting
sin 440 >> freqShift (noiseX 13 >> gain 1000) >> gain 0.3 >> play
sin 440 >> pitchShift 20 >> gain 0.3 >> play
sin 440 >> gain 0.3 >> play
square (noiseX 2 >> exprange 10 10000) >> freqShift (square (noiseX 1 >> exprange 3 40) >> gain 4000 >> gain (noiseX 1)) >> gain 0.3 >> play

---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

let sqkick => white + tri (random 148 152) >>
    (lowpass (random 990 1100) 5) >>
    perc 0.0 1 0.07
    
psqkick +> sqkick _ sqkick _ [_ sqkick] sqkick | (*1) (*1) (*2) (*3)
stop psqkick

let fmsnare => white + sin (sin (random 205 215) >> range 20 400) >>
    (highpass (random 290 310) 40) >>
    perc 0.0 0.7 0.05
    
pfmsnare +> _ [fmsnare fmsnare] _ [_ fmsnare] _ [fmsnare fmsnare] _ | (*1) (*1) (/2)
stop pfmsnare

let whitehat => white >> highpass (random 3900 4100) (random 10 15) >> perc 0.0 0.4 0.07

pwhitehat +> whitehat [whitehat whitehat] [_ whitehat] | (*1) (*2) (*2) (/2)
stop pwhitehat

---
let coleJI = Scale { tuning = [ 1, (10/9), (9/8), (8/7), (6/5), (4/3), (11/8), (3/2), (8/5), (7/4), (16/9), (9/5) ], degrees = [0,1,2,3,4,5,6,7,8,9,10,11], pitchesPerOctave = 12, rootFreq = koto::rootFreq }

let lead => brown + square ((randomI 0 24) >> (degree2Freq coleJI)) >>
    lowpass (random 600 3000) (random 5 20) >>
    delay 0.1 0.7 >>
    perc 0.01 (random 0.1 0.125) (random 0.2 1.2)

plead +> lead _ lead _ lead lead [_ lead] lead | (*1) (*1) (/2) (*1) (*2) (/2)


let coleJI = Scale { tuning = [ 1, (10/9), (9/8), (8/7), (6/5), (4/3), (11/8), (3/2), (8/5), (7/4), (16/9), (9/5) ], degrees = [0,1,2,3,4,5,6,7,8,9,10,11], pitchesPerOctave = 12, rootFreq = koto::rootFreq }


let growl freqq => osc >> fold 0.125 >> filt >> gain 128 >> env
    where
        freq    = freqq * 0.25
        env     = perc 0.0 0.6 1
        osc     = (square (freq*1.05)) + (sin (freq*1)) + (square (freq*0.49) )+ (tri (freq * 2))
        filt    = lowpass (freq * 0.25 * (pow 2 $ randomI 2 3)) 10

growlTime ~> growl 0 _ _ _ 2 _ 0 _ 5 _ 4 _ | (degree2Freq coleJI)
stop growlTime
let spinning freqq => osc >> filt  >> gain 0.25 >> env
    where
        freq    = freqq * 1
        env     = perc 0.6 0.6 0.01
        osc     = (tri (freq*1.00)) + (saw (freq*1)) + (tri (freq*0.5) )+ (tri (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 3)) 10

spinTime ~> spinning 0 _ _ _ 2 _ 0 _ 5 _ 4 _ _ _ | (degree2Freq coleJI)

let spinning2 freqq => osc >> filt >> gain 0.25 >> env
    where
        freq    = freqq * 0.5
        env     = perc 0.6 0.6 0.01
        osc     = (tri (freq*1.00)) + (saw (freq*1)) + (tri (freq*0.5) )+ (tri (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 3)) 10

let x = 5
spinTime2 ~> spinning2 0 (x) _ _ 2 _ 0 _ 5 _ 4 _ 6 _ _ _ | ((*x) . (degree2Freq coleJI))
    where x = 2


let ice9 freqq => osc >> dec >> filt >> delay 0.25 0.5 >> gain 0.25 >> env
    where
        freq    = freqq * 2
        env     = perc 1 0.6 4
        dec     = decimate (freq * (randomI 1 2))
        osc     = (tri freq) + (square (freq * 0.5)) + (saw (freq * 0.25)) + (sin (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 5)) 20
        
iceChords ~> ice9 
    0 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _
    | (degree2Freq coleJI)
    
let ice10 freqq => osc >> dec >> filt >> delay 0.25 0.5 >> gain 0.25 >> env
    where
        freq    = freqq * 2
        env     = perc 1 0.6 4
        dec     = decimate (freq * (randomI 1 3))
        osc     = (tri freq) + (square (freq * 0.5)) + (saw (freq * 0.25)) + (sin (freq * 2))
        filt    = lowpass (env $ freq * 4 * (pow 2 $ randomI 2 5)) 40

iceChords2 ~> ice10
    0 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    0 5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    | (degree2Freq coleJI)
    
stop iceChords2
stop iceChords
stop spinTime
stop spinTime2
stop growlTime


--| Chad Sounds

--| Section 1 stuff, combos with Cole/Curtis Sounds
let snare => choose [violet,pink,brown,white,clipNoise>>gain 0.5] >> delay (1/(ff -14)) 0.999 >> env [0,1,1,0] [0,(random 0.02 0.15),0] 0 >> auxThrough 5
let ss => pink >> bandpass (ff 16) 4 >> gain 16 >> delay (1/(ff (random -16 -8))) 0.999 >> env [0,0.3,0.3,0] [0,0.05,0] 0 >> auxThrough 5
let lkick => square (ff -16) >> add (tri $ ff -24) >> perc 0 0.6 0.05 >> auxThrough 5
lkicker2 +> [lkick ss] [snare ss] [ss lkick] [ss snare]


-- Section 2 stuff, Not to be mixed with other sounds
let bd => tri (degree2Freq coleJI -32) >> add (tri (degree2Freq coleJI -20)) >> lowpass 100 0.1 >> perc 0 1.2 0.15
let bd2 => tri (degree2Freq coleJI -22) >> lowpass 500 0.1 >> perc 0.005 2 1
let sd1 => sin ((freq 0) + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> highpass (freq 0) 30 >> env [0, 0.03, 0.0035, 0] [0, 0.0001, random 0.01 0.2] 0 >> auxThrough (randomI 0 3)
    where freq x = degree2Freq coleJI (add 12 $ randomI -1 1)
let sd2 => sin (freq + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> bandpass freq 50 >> env [0, 1, 0.035, 0] [0, 0.05, 1] 0 >> auxThrough (randomI 0 3)
    where freq = (degree2Freq coleJI 15)
let sd3 => violet + pink >> bandpass (degree2Freq coleJI 26) 1 >> lowshelf 200 12 >> env [0,1,0.03,0] [0,0.1,1] 0 >> auxThrough (randomI 0 3)
    
drumsD2 +> bd [_ bd] [_ sd2] sd2 bd [_ bd] [sd1 sd2] sd2 _ [bd _] sd2 [sd1 sd2] [bd sd2] [sd1 bd] [sd2 sd1] sd2
drumsD3 +> _ sd3 | (*2)

let delayFX = auxIn 0 >> lowpass (sin 0.1767 >> range 200 1000) 5 >> delay 0.5 0.6 >> play
let delayFX2 = auxIn 1 >> highpass (sin 0.1 >> range 200 1000) 5 >> delay 0.75 0.5 >> play
let delayFX3 = auxIn 2 >> gain 2 >> bandpass (sin 0.1317 >> range 200 2000) 5 >> delay 1.125 0.75 >> play
-- Don't stop these right now, just for later
stop delayFX
stop delayFX2
stop delayFX3
stop drumsD2
stop drumsD3


let neonBass freq => (square (freq/2)) + (saw (freq*2)) + (saw (freq*(add 2 (sin 4 >> gain 0.04)))) + (pink 1 >> lowpass freq 50) >> lowpass (sin 0.1 >> range 200 1000) 0.01 >> env [0.0,0.2,0.03,0] [0.002,1,3] 0
let ff = degree2Freq coleJI
neonBassSeq ~> neonBass (ff -12) _ (ff -8) _ _ _ (ff -4) _ (ff (choose [1, -1, -5])) _ _ (ff -9) _ _ (ff -5) | (/2) _ _ _ _ _ (/2) _
stop neonBassSeq


let neonBass2 freq => (saw (freq/2)) + (saw (freq/(add 2 (tri 4 >> gain 0.08)))) + (pink 1 >> lowpass freq 10) >> env [0.0,0.25,0.03,0] [0.001,0.1,3] 0 >> auxThrough 3
neonBassSeq2 ~> neonBass2 [(ff $ choose [-6, -12]) (ff $ choose [-5,-8])] [(ff $ choose [-5, -4]) (ff (choose [1, -1, -5]))] [(ff -9) (ff -5)] | (*4) (*8) (*4) (*2) (*2) _ (/2)

-- Don't stop yet, this is just for later
stop neonBassSeq2
-- This goes with neonBass2
let delayFX4 = auxIn 3 >> env2 [0,1] [1] 0 >> delay (sin 0.3 >> range 0.01 0.001) 0.1 >> delay 1.25 0.6 >> gain 0.25 >> play
stop delayFX4



-- Noisey
let snare => pink >> delay (1/(ff -8)) 0.1 >> perc 0.0 0.9 0.3 >> auxOut 5
let ss => violet >> bandpass (ff 3) 30 >> gain 30 >> perc 0.0 0.4 0.1 >> auxOut 5
let lkick => square (ff -12) >> add (tri 40) >> perc 0 0.3 0.1 >> auxOut 5
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let drumDecimFX = auxIn 5 >> delay 0.125 0.2 >> crush 1 >> decimate (add 8000 (simplex 0.1 >> gain 3500)) >> gain 0.5 >> play
stop drumDecimFX



---------------------------------------
-- Crunchy Drums
---------------------------------------

let ff = degree2Freq coleJI
let snare => pink 1 >> delay (1/(ff -8)) 0.1 >> perc 0.0 0.9 0.3 >> auxOut 5
let ss => violet 1 >> bandpass (ff 3) 30 >> gain 30 >> perc 0.0 0.4 0.1 >> auxOut 5
let lkick => square (ff -12) >> add (tri 40) >> perc 0 0.3 0.1 >> auxOut 5
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let drumDecimFX = auxIn 5 >> delay 0.125 0.2 >> crush 1 >> decimate (add 8000 (simplex 0.1 >> gain 3500)) >> gain 0.5 >> play
stop drumDecimFX












// synthesis techniques worth implementing
Comb Filter -- This is basically what delay is. Consider refactoring?
Karplus-Strong -- Done but slow
Moog Style filter -- maybe lator...
Pitch and Freq Shift -- Pitch Shift doesn't work right, but Freq Shift is done. both are very expensive.
Better Wave Shaping, distion types of effects (Need Chebyshev polynomials to good dist I think) >> done, but shaper is buggy
Chorus, Phaser, Flanger -- Done
Trigger UGens, Stepper -- Done






--| Chord progression example code

-- curried function for creating minor chords. Octave 4 is where middle C is ona piano.
let mc = Chord minor 4

-- chordProgression returns a pbind that just sequences through the chords. They can be queried using ::value
let doom = chordProgression "doom" [mc [0,2,4], mc [1,3,5], mc [2,4,6], mc [3,5,7], mc [4,6,8], mc [5,7,9]] [8] 

let synth freq => saw freq >> lowpass (freq * 4) 1 >> perc 0 0.6 0.5

-- We can use the progression similar to a scale, with c2f instead of d2f. c2f takes a scale and a chord degree.
-- The chord degree can be any integer including negative numbers and will scale octaves appropriately
bass ~> synth (pseries 0 (pseq [-2,5]) >> pfold -2 6) | (c2f doom)


-- block chords, right now doesn't work in patterns :(
let chordSynth freqs => map sf freqs
    where
        sf freq = saw freq >> lowpass (freq * 16) 0 >> perc 0 0.3 0.3

map play $ chordSynth $ blockChord doom

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

{-
    Welcome to Lich.js!
    Lich.js is a new language for live coding music and graphics directly in a web browser. 
    This is a little demo page to give you an idea of what's possible. 
    The language isn't quite done yet (beta!), and there's still some bugs, but there is much fun to be had. 
    The syntax is similar to Haskell, but if you haven't used it, don't be scared. 


    If you want to get the source code or learn how to run your own server go to https://github.com/ChadMcKinney/Lich.js
    
    (If you want to chat with any other players you can use alt-c to enter chat messages)

	Chad McKinney
	chad@chadmckinneyaudio.com
-}



-- Hacker Tip #1: Comments begin with --

-- Lets warm up with some math. Put your cursor on the next line and hold shift, then press enter. You should see 4 post.
2 + 2

-- Lich.js uses normal order of operations. For example, this will return 7:
1 + 2 * 3

-- The keyword let is used to declare variables at global scope. The next line defines monster as the string Cthulhu.
let monster = "Cthulhu"

-- Functions are evaluated simply by supplying arguments with spaces. 
reverse monster

-- New functions can be composed by using argument names after variable declarations, like so:
let addFive x = x + 5
addFive 1
addFive 2
addFive 1337

-- One last thing before we make some noise. Let's talk about partial application. 
-- Partial application is used heavily in Lich.js so it will be good to get used to it.
-- Normally a language requires you to supply all the arguments for a function for it to work. For example:
add 2 3 -- Evaluates to 5

-- In Haskell (and Lich) we can actually provide less than the expected number of arguments.
-- What will return is a new function expecting the rest of the arguments. For example:
add 2 -- Evaulates to (\r ->)
add -- Evaulates to (\l r ->)

-- We can assign this to variable and use it like any other function
let addTwo = add 2
addTwo 5 -- 7


-- This can be done with any function at all. Math operations are so common we have shortcuts
(/2) 4 -- 4 / 2 = 2
(*4) 3 -- 3 * 4 = 12
(3/) 6 -- 3 / 6 = 0.5
(4-) 2 -- 4 - 2 = 2

-- because of the haskell like syntax (-4) just means negative 4. We have to use subtract to get what we want. 
(subtract 4) 2 -- 2 - 4 = -2

-- If this is a bit confusing, don't worry, as you go through the examples you'll see how they're used and how useful they are!

------------------------------------------------------------
-- OK. You came here for music right? Let's make some noise.

let sineWave = play (sin 440)
stop sineWave -- when you've heard enough

-- Hacker Tip #2: Ctrl-Period will make all the sound stop. 
-- Sometimes you accidently make zombies. Ctrl-. is your nuclear option.

-- Lich.js makes it easy to get sound going and there's a large collection of custom functions to do just that. 
-- Evaluate the next line to see the collection of audio functions.
ugenList

-- Let's try another, how about something a bit more interesting?
let sawz = saw 40 >> lowpass 792 15 >> play
stop sawz

-- What's going on hear? We're using the >> operator to chain different functions together.
-- The >> operator just passes the left hand side to the function on the right. 
-- This is useful for audio because it makes function chains look like a signal path, like guitar pedals.
-- In the previous example we have a saw wave at 40hz fed into a lowpass filter with a cutoff of 792 hz and 15 for the res.
-- If you want to know what arguments a particular function has, just evaluate it with no arguments. For example:
lowpass

-- If you evaluation lowpass you will see this print: (\freq q input ->)

-- Ok This is fine and all but how about we make a melody?
-- First we need to make a synth definition, we'll use the new operator =>
let sawSynth freq => saw freq >> lowpass (freq * 16) 1 >> perc 0 0.3 0.7


-- Synth definitions are like functions, they can take arguments and can be evaluated like this:
play (sawSynth 440) -- You can evaluate this multiple times, it will free itself because of the perc above
sawSynth 440 >> play -- These are equivelent.

-- Now lets make a melody using a Solo Pattern
sawMelody ~> sawSynth 110 220 330 440 550 660 770 880
stop sawMelody

-- We can get a frequency as a degree from a scale by using the degree2Freq function
degree2Freq major 6
degree2Freq minor -2
d2f bartok 10 -- d2f is shorthand for degree2Freq.

-- Choose a scale degree in the bartok scale and play the sawSynth with it. in the Execute this several times.
sawSynth (d2f bartok (choose [-12..12])) >> play

-- to see a full list of scales evaulate the next line
scaleList

-- We can use modifiers on a sequence by using a |
-- After the pipe | we need to provide a function. 
-- Here we're creating a new function from d2f minor. Partial application FTW!
sawMelody ~> sawSynth 0 1 2 3 4 5 6 7 | (d2f minor)

-- This isn't a terribly interesting melody. We can change it just be redefining it:
sawMelody ~> sawSynth 5 5 5 4 4 7 7 1 11 1 12 2 4 0 | (d2f minor)
stop sawMelody -- When you've heard enough


-- The ~> operator creates a new Solo Pattern. The first argument is a synth definition (sawSynth from above)
-- After that we get a list of numbers. The | pipe indicates that we want to use a modifier on these values.
-- The d2f function simply translates the numbers as scale degrees into frequencies in hz. 
-- If that's a bit too much, don't worry, just make your pattern look like above and you're in business.

-- This melody is a little fast, wouldn't it be nice if we could use rests in our melody?
sawMelody ~> sawSynth 5 5 5 _ 4 4 _ 7 7 _ 1 11 1 12 2 _ 4 0 _ | (d2f minor)

-- The _ is a rest, and no synth will be played on those beats. We can use [] to make faster notes:
sawMelody ~> sawSynth 0 1 2 3 [4 5] [6 7] | (d2f minor)

-- Note that there's no commas in these []. That's because we're using a special syntax, this is unique to these patterns. 
-- How about we mix _ and []
sawMelody ~> sawSynth 0 _ 1 2 3 [_ 4] [_ 5] [6 7] | (d2f minor)
stop sawMelody -- when you've heard enough



-- How about some drums?
-- We can make some very simple drums using the => again.
-- They don't need arguments for our purpose as you'll see.
-- Evaluate these lines one at a time.
let bd => square 39 >> lowpass 1000 0 >> perc 0 1 0.2
let sn => pink 1 >> perc 0 1 0.2
let hh => violet 1 >> perc 0 0.3 (wchoose [0.8,0.2] [0.1,0.5])

-- Now we can create an Impulse Pattern using the +> operator
drums +> bd hh sn hh


-- just like before we can edit them on the fly. Evaluating each line in turn will change the pattern
drums +> bd hh sn hh bd [hh hh] sn [hh sn]
drums +> [_ hh] hh
drums +> [bd bd]

-- We can use modifiers to change the durations. 
-- The | (*2) makes all the durations twice as long
drums +> bd hh sn hh bd [hh hh] sn [hh sn] | (*2)
drums +> bd hh sn hh bd [hh hh] sn [hh sn] -- back to normal

-- Hey, we can bring that melody back in
sawMelody ~> sawSynth 5 5 5 _ 4 4 _ 7 7 _ [1 11] [1 12] 4 0 _ 4 0 _ | (d2f minor)

-- OK what about some cool generative melody?
sawMelody ~> sawSynth (psin 0.1 >> prange 0 10) | (d2f minor)

-- Lets change it up more
sawMelody ~> sawSynth (psin 0.2 >> prange 0 10 >> pwarp (psin 0.7)) | (d2f minor)

-- how about some bass? 
-- HackerTip #3: Head phones or nicer speakers will make everything sound better
sawBass ~> sawSynth (psin 0.2 >> prange -2 -16 >> pstutter 14) | (d2f minor)

-- And some harmony?
sawHarmony ~> sawSynth (psaw 0.15 >> prange -2 5 >> pstutter 6)  | (d2f minor)

-- Break it down
drums +> bd hh sn hh [hh bd] [hh hh] sn [hh [sn sn]] | (*2)

-- When you've heard enough, compile these in turn
stop drums 
stop sawMelody
stop sawBass
stop sawHarmony


{-
    Pattern functions
    
    "p" functions are pattern functions. These functions return lambdas that when given a beat will return a value.
    Look over the code below to get a feel fro what the different pattern functions can do.
    Don't worry if you don't completely grok them yet. You'll get a feel for how to use them as you go.
-}


-- There are a plethora of special pattern functions in Lich. Evaluate the next line to see a list
patternList

-- Each pattern function takes some number of arguments and returns a Pattern data type object.
pseq [1,2,3] -- evaluates to: Pattern { p = (\t ->) }

-- A pattern object is simply a type wrapper for a function that takes a time argument and returns a value
-- For example we can assign the previous pattern to a value and then invoke that contained function to get a value.
let ps = pseq [0,1,2]
ps::p 0 -- 0
ps::p 1 -- 1
ps::p 2 -- 2
ps::p 3 -- 0, pseq will wrap around to the beginning
ps::p 4 -- 1

-- Lets look at another pattern function, pseries
let ps = pseries 1 2
ps::p 0 -- 1
ps::p 1 -- 3
ps::p 2 -- 5
ps::p 3 -- 7

-- Some pattern functions expect a pattern as one of their arguments.
-- We call these pattern filters. For example pstutter
let ps = pseries 1 2 >> pstutter 2
ps::p 0 -- 1
ps::p 1 -- 1
ps::p 2 -- 3
ps::p 3 -- 3
ps::p 4 -- 5
ps::p 5 -- 5

-- Here's some examples of using pattern functions to generate lists of values.
-- Normally we'd use pattern functions in solo streams or impulse streams like above
-- You'll see this soon, but the next several examples are just to give you some idea of what they can do.

-- Evaulate a sequence of values
let s = pseq [pseq [0,pseq [0.5, 666]], pseq [1,10], pseq [2,20]]
foldl (\acc t -> acc ++ (s::p t)) [0] [0..12]

-- Random selections from array
let sh = prand [pseq [555,666,777], 1, 2]
foldl (\acc t -> acc ++ (sh::p t)) [0] [0..12]

-- weighted random selections
let ws = pwrand [0.5, 0.25, 0.25] [pseq [555,666,777], 1, 2]
foldl (\acc t -> acc ++ (ws::p t)) [0] [0..12]

-- shuffle array and return a pattern that sequences it
let ps = pshuf [0..4]
foldl (\acc t -> acc ++ (ps::p t)) [0] [0..12]

-- a pattern filter. Stutters the output of a pattern
let st = pstutter 3 $ pseq [0..5]
foldl (\acc t -> acc ++ (st::p t)) [0] [0..12]

-- Another pattern filter. Wraps a filter within a range
let pw = pwrap 3 6 (pseq [0..7])
foldl (\acc t -> acc ++ (pw::p t)) [0] [0..12]

-- Generates a range of values from an initial value and step size
let ps = pseries 2 5
foldl (\acc t -> acc ++ (ps::p t)) [0] [0..12]

let ps = pwrap 0 13 $ pseries 0 2
foldl (\acc t -> acc ++ (ps::p t)) [0] [0..12]

-- Generates a range of values using multiplcation, from an initial value and step size
let pg = pgeom 1 2
foldl (\acc t -> acc ++ (pg::p t)) [0] [0..12]

let pg = pwrap 0 13 $ pgeom 1 2
foldl (\acc t -> acc ++ (pg::p t)) [0] [0..12]

let pr = preverse $ pseq [0..4]
foldl (\acc t -> acc ++ (pr::p t)) [0] [0..12]


-- Now normally you don't have to worry about using the ::p and supplying an argument
-- When using the patter functions in a pattern stream such as ~> and +> functions this will be done auto-magically
-- The next few example use patterns to generate values in ~> streams

let si freq => sin freq >> perc 0 0.3 0.15
siner ~> si (pseq [444,555,666,777])

siner ~> si (pseq [444,555,666,777] >> pstutter 3)

siner ~> si (pseq [444,555,666,777] >> pwarp (pseq [13.5, pseq [-5.3, 1]]))
stop siner

-- We can also use patterns with +> streams
-- Here we're using pattern function to select which synth definition to use

let s => sin 444 >> pan 0 >> perc 0 0.5 0.3
let s2 => sin 666 >> pan -1 >> perc 0 0.5 0.3
let s3 => sin 777 >> pan 1 >> perc 0 0.5 0.3
siner2 +> (pseq [s2,s3,s] >> pstutter 2)

siner2 +> (pseq [s,s3,s2] >> pwarp (pseq [(1/3),(1/4)])) | (/2)
stop siner2



{-
    beatPattern
    
    
    You can't use a pattern function such as pseq or pstutter inside a synthdef normally. 
    However by using the beatPattern function we can embed a pattern func in a synthdef, 
    and the value according to the current beat will be returned.
    
    For ease we can use bp instead of beatPattern.
-}


let bSyn => sin freq >> pan -1 >> perc 0 1 0.25
    where freq = pseq [1..10] >> bp >> d2f pelog

beatSynthesizer +> bSyn

let bSyn2 => sin freq >> pan 1 >> perc 0 1 0.25
    where freq = pseq [1..8] >> bp >> d2f pelog

beatSynthesizer +> bSyn bSyn bSyn bSyn2 bSyn2 bSyn2
stop beatSynthesizer

-- The beat based pattern functions using bp will update independant of the speed of the sequence.
-- This is because their values are based on the current beat number, this value is found by executing: currentBeat 0
-- If you evaluate currentBeat 0 several times you'll see the number it returns always rises according to the current tempo.
currentBeat 0

-- by using this current beat value with a pattern function we can get updated values
-- Evaluate this several times
(pseq [0..5])::p (currentBeat 0)

-- All beatPattern (bp) does is exactly that. The next line is effectivly the same as the last
pseq [0..5] >> bp


-- Evaulate the next two lines to see how this separation effects the sampling of values
beatSynthesizer +> bSyn bSyn bSyn bSyn2 bSyn2 bSyn2 | (*2) -- Slower
beatSynthesizer +> bSyn bSyn bSyn bSyn2 bSyn2 bSyn2 | (/2) -- Faster

-- More beatPattern fun
let bSyn => sin freq >> pan -1 >> perc 0 1 0.25
    where 
        freq = psin 0.1 >> prange 0 6 >> pmul (pseq [1,2]) >> pwarp (psquare 0.2) >> bp >> d2f pelog
    
    
let bSyn2 => sin freq >> pan 1 >> perc 0 1 0.25
    where
        freq = psin 0.075 >> prange 0 6 >> pmul (pseq [1,2,3]) >> pwarp (psquare 0.15) >> bp >> d2f pelog


-- Sooo many notes, make it stttoooooppppp
stop beatSynthesizer


{-
    pbind

    Above we've shown solo streams (~>) and impulse streams (+>), but there's a third kind of stream generator, pbind.
    
    pbind is similar to the SuperCollider Pbind and Pdef
    It takes: 
        a pattern name (used to store in a global dictionary for updates via redefinition)
        a synth definition (can be a pattern of synth definitions)
        an array of arguments (each argument can be a pattern)
        and a duration (can be pattern)
        
    
    pbind name synthDef arguments duration
-}


let t f dur => sin (d2f slendro f) >> pan -1 >> perc 0 0.5 (dur * 1.5)
let u f dur => sin (d2f slendro f) >> pan 1 >> perc 0 0.5 (dur * 1.5)

-- pbind name synthDef arguments duration
let testp = pbind "test" t [5, dur] dur
    where dur = 2

-- redefine, using patterns to make the sequencing more interesting
let testp = pbind "test" (pseq [t,u,t,t,u,u,u]) [pshuf [0..5], dur] dur
    where
        dur = (pseq [1/2,1/2,1])

-- even more patterning 
let testp = pbind "test" syn [freqs >> pstutter 3, dur] dur
    where 
        syn = pseq [t,u] >> pwarp (psaw 0.3 >> pmul 10)
        freqs = pseries 0 7 >> pmod (pseq [1..10] >> pwarp (psaw 0.03 >> pmul 20) >> pstutter 2)
        dur = pseq (map (div 1) [1..6]) >> pwarp (psaw 0.7 >> pmul 10) >> pstutter 3

stop testp



{-
    Chord Progressions
-}

let mc = Chord minor 4

-- chordProgression returns a pbind that just sequences through the chords. They can be queried using ::value
let doom = chordProgression "doom" [mc [0,2,4], mc [1,3,5], mc [2,4,6], mc [3,5,7], mc [4,6,8], mc [5,7,9]] [8] 

let synth freq => saw freq >> lowpass (freq * 4) 1 >> perc 0 0.6 0.5

-- We can use the progression similar to a scale, with c2f instead of d2f. c2f takes a scale and a chord degree.
-- The chord degree can be any integer including negative numbers and will scale octaves appropriately
bass ~> synth (pseries 0 (pseq [-2,5]) >> pfold -2 6) | (c2f doom)
stop bass

-- We can play block chords by using the map function in conjunction with the blockChord function. 
-- Make sure the doom progression is playing!
-- Note: block chords don't work in patterns yet :(
let chordSynth freqs => map sf freqs
    where
        sf freq = saw freq >> lowpass (freq * 16) 0 >> perc 0 0.3 0.3

map play $ chordSynth $ blockChord doom


{- 
    Buffers
-}


-- We can create an audio buffer by using the newBuffer function
let myBuf = newBuffer sampleRate

-- You can use buffers with the recPlayBuf ugen. This will simultaneously record into and play from a buffer, at variable rates
let noisySynth = sin 440 >> recPlayBuf (newBuffer sampleRate) (noiseX 1) (noiseX 1 >> gain 2) >> gain 0.5 >> play
stop noisySynth

-- Even more chaotic
let noisySynth = sin (noiseL 2 >> exprange 200 2000) >> rec >> gain 0.5 >> play
    where 
        rec = recPlayBuf (newBuffer sampleRate) (noiseL 7) (sin (noiseX 1 >> exprange 1 40) >> gain (noiseL 3 >> range 0 4))

stop noisySynth


-- You can create a buffer as a variable and have multiple synths share it for interesting effects
let myBuf = newBuffer (sampleRate * 4)
let bufSynth freq => square freq >> recPlayBuf myBuf 1 -2 >> perc 0 0.5 2
recSequence ~> bufSynth (pseq [0..10]) | (d2f koto) -- Generate a sequence of synths that share the same buffer
stop recSequence





{- 
    Effects and Buses
    
    We can route audio using the auxIn and auxOut ugens
    By default there are 10 global aux buses, but you can also create local buses.
-}



let ff = degree2Freq coleJI
let snare => pink 1 >> delay (1/(ff -8)) 0.1 >> perc 0.0 0.9 0.3 >> auxOut 5
let ss => violet 1 >> bandpass (ff 3) 30 >> gain 30 >> perc 0.0 0.4 0.1 >> auxOut 5
let lkick => square (ff -12) >> add (tri 40) >> perc 0 0.3 0.1 >> auxOut 5

-- This won't make sound yet because the synths are writing to bus 5
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

-- Execute the next line to hear crunchy drums.
let drumDecimFX = auxIn 5 >> delay 0.125 0.2 >> crush 1 >> decimate (add 8000 (simplex 0.1 >> gain 3500)) >> gain 0.5 >> play
stop drumDecimFX
stop lkicker2



-- We can use aux buses for feedback
let s3 = auxIn 1 >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough 1 >> gain 2 >> play
stop s3

-- We can also use a localBus so as to not collide with anything else that might use a particular auxillary bus
let s4 = feed >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough feed >> gain 2 >> play
    where feed = localBus 1 -- local bus!
    
stop s4

-- Filters and feed back go great together. fir is a good choice because it's more stable than an iir.
-- Stop and execute this several times to hear different harmonics
let feedSynth = sq >> add (auxIn 0 >> delay (1/6) 0) >> fil >> limiter -3 >> auxThrough 0 >> gain 0.3 >> play
    where
        sq = square (saw 1 >> exprange 1 20000)
        fil = fir [random -0.4 0.4 | x <- [1..10]] -- haskell-like list comprehensions 
        
stop feedSynth


{-
    Graphics
    
    Careful, the graphics can really bog down the editor! 

    The graphics library is still young and needs more development.
    At the moment it's very stateful, which isn't ideal, but hey, it works! ...ish
-}

initGraphics 0 -- MUST DO THIS FIRST!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
setBackground (random 0 255) (random 0 255) (random 0 255)
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -100 100] [25, 25, 25] [random 0 (2*pi), random 0 (2*pi), random 0 (2*pi)] [0,200,150] 

setShader $ choose shaders
deleteMesh s
deleteMesh c

deleteScene
shaders

let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -100 100] [25, 25, 25] [random 0 (2*pi), random 0 (2*pi), random 0 (2*pi)] [0,200,150] 


setShaders $ map (choose) $ replicate 2 shaders
clearShaders 0
wireframe true s
wireframe true c
wireframe false s
wireframe false c


wireframeAll (choose [true, false])

move [-1, -10, -2] s
move [-1, 1, -1] c
moveAll [random -1 1, random -1 1, random -1 1]

setColor [random 0 255, random 0 255, random 0 255] c
setColor [random 0 255, random 0 255, random 0 255] s
setColorAll [random 0 255, random 0 255, random 0 255]

rotate [random -1 1, random -1 1, random -1 1] c
rotateAll [random -1 1, random -1 1, random -1 1]

linear [0, 0, 1] c
linearAll [random -1 1, random -1 1, random -1 1]

angular [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1] c
angularAll [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1]

setPosition [random -50 50, random -50 50, random -50 50] s
setPositionAll [random -50 50, random -50 50, random -50 50]

scale [random 0.1 1, random 0.1 1, random 0.1 1] s
scaleAll [random 0.1 1, random 0.1 1, random 0.1 10]

-- supports streaming style syntax
s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]

deleteScene 0 -- clear out the scene

cloudMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
deleteScene 0 -- clear out the scene
gaussianMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
deleteScene 0 -- clear out the scene
sinMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
deleteScene 0 -- clear out the scene

sinMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scaleAll [4, 4, 4]
deleteScene 0 -- clear out the scene

let n = noiseMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] n
angular [0.01, 0.01, 0.03] n

deleteMesh n

let g = gaussianMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] g
angular [0.01, 0.01, 0.03] g

deleteMesh g


let s = squareMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [6,6,6] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let s = sawMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let t = triMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [10, 10, 10] t
angular [0.01, 0.01, 0.03] t

deleteMesh t

-- Won't be able to initially see it because of culling, set the angular!
let f = flatMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] f
angular [0.01, 0.01, 0.03] f

deleteMesh f
deleteScene

let s = sawMapMesh 20 20 [random 0 255, random 0 255, random 0 255]
scale [7, 7, 7] s
angular [0.01, 0.01, 0.03] s

-- Generate random shader. Potentially very chaotic! Get ready to execute the line below!
spliceShader $ randomString $ random 1 5
clearShaders 0

deleteScene 0

-- Patterns are supported as well!
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -10 10] [50,50,50] [0.1,0,0] [random 0 255, random 0 255, random 0 255]

-- execute these two "meshSynths", then the pattern below
let meshSynth => s >> wireframe (choose [true, false]) >> po >> co >> li
    where
        po = setPosition [random -10 10, random -10 10, random -10 10]
        co = setColor [random 0 255, random 0 255, random 0 255]
        li = linear [random -1 1, random -1 1, random -1 1]
        
let meshSynth2 => c >> wireframe (choose [true, false]) >> po >> co >> li
    where
        po = setPosition [random -10 10, random -10 10, random -10 10]
        co = setColor [random 0 255, random 0 255, random 0 255]
        li = linear [random -1 1, random -1 1, random -1 1] >> angular [random 0 0.1, random 0 0.1, random 0 0.1]

meshSeq +> meshSynth meshSynth2 meshSynth [meshSynth2 meshSynth]

-- Shader sequencing, yay!
let shaderSynth => spliceShader $ randomString $ random 1 5
shaderSeq +> shaderSynth | (*2)

stop shaderSeq
clearShaders 0
stop meshSeq
deleteScene 0
