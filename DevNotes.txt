//////////////////////////////
// Dev Notes
//////////////////////////////


//////////////////////////////
// Known Bugs
//////////////////////////////

//////////////////////////////
// Multiple let declarations
// Dec 14, 2013

Multi-line compiling with let declarations doesn't parse. For example compiling these two together:
let one = 1
let two = 2



-- Recursion tests. These all exhaust memory with the current setup
let fib n = if n == 0 then 0 else if n == 1 then 1 else (fib (n - 1)) + (fib (n - 2))
fib 9

let fac n = if n == 0 then 1 else n * fac (n - 1)
fac 100

let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


/////////////////////
// State Monad
/////////////////////

let testdo = do
    x <- get
    mprint x -- mprint is a monadic print that allows for easy printing with do syntax
    put (x + 1)
    y <- get
    mprint y
    mprint "Hello, world."
    result (y + 1)

runState testdo 0
evalState testdo 8
execState testdo 0
runState (result 5 >>= \x -> mprint x >>= \_ -> mprint "Hello, world.") 0
let m = (result 5 >>= \x -> mprint x >>= \x -> result x)
runState m 99
runState (m >>= \_ -> result 10) 0
runState (mprint 5 >>= \x -> result x) 0


-- lift
let testdo = do
    x <- get
    lift play (sin x >> perc 0 0.7 2)
    put (x + 13)
    y <- get
    lift play (sin y >> perc 0 0.7 2)
    result (y + 1)

let m = 440
let m = evalState testdo m -- Continually rises on execution


-- Stack example (borrowed from Learn You a Haskell)
let pop = State (\(x:xs) -> Result x xs)
let push a = State (\xs -> Result Nothing (a:xs))

let stackManip = do
    push 3
    pop
    pop
    
    
runState stackManip [5,8,2,1]

let stackStuff = do
    a <- pop
    if a == 5
        then push 5
        else do
            push 3
            push 8
            
runState stackStuff [9,0,2,1,0]



//////////////////////////////////////////
// Pattern matching 

data Monster { says = "howl" }
data Species = Hydra | Gorgon | Unspeakable | MindFlay

let m = Monster
let n = Monster "slither"
let h = Hydra
let g = Gorgon

let pattern p = case p of
    Nothing             -> "Nothing to see here."
    1                   -> "One is the loneliest number."
    666                 -> "Hail satan."
    3.14                -> "Dessert."
    (Monster says)      -> "Monster says " + says
    "string"            -> "This is not."
    ["String",66,(\_->)] -> "That's a really weird list."
    [x,y,z]             -> "x: " + x + ", y: " + y + ", z: " + z
    (x:xs)              -> "x: " + x + ", xs: " + (show xs)
    Hydra               -> "Cut off all the heads!"
    Gorgon              -> "Shield your eyes!"
    (\_ _ _ ->)         -> "lambda x y x -> " + (show $ p 6 6 6) 
    _                   -> "Anything goes."

pattern n
pattern (\y r p -> y + r + p)
let threeD x y z = [x,y,z]
pattern threeD
pattern ["String",66,(\x -> x + 1)]

data Coordinate = North | East | South | West

let c = East

case c of
    North    -> "North!"
    East     -> "East!"
    South    -> "South!"
    West     -> "West!"


let whereFunc x = z x
    where
       z (x:xs) = replicate (length xs) x 

whereFunc (2:[1..4])

Pattern matching function arguments


let myFunc (x:xs) []  Nothing _ = x * 2

myFunc [1] -- Curries to (\[] Nothing _ ->)
myFunc [1] [] -- (\Nothing _ ->)
myFunc [1] [] Nothing -- (\_ ->)
myFunc [1] [] Nothing "Anything" -- x * 2 = 1
myFunc [1] [1] Nothing "Anything" -- Won't match, second arg needs to be []
myFunc [] [] Nothing "Anything" -- Won't match first arg needs at least a head for x:xs matching

let myFunc 1 = "ONE"
myFunc 1
myFunc 2 -- error

let myFunc (x:xs) = replicate (length xs) x
myFunc [7..1] -- [7,7,7,7,7,7]
myFunc [7] -- [], xs has a zero length, so no replication
myFunc [] -- error, requires at least a head

-- lambdas can match numbers of arguments
let myFunc (\_ _ ->) = print "Lambda with 2 arguments"
myFunc (\x y -> x + y)
myFunc (\x -> x) -- Error, requires a function with 2 arguments

let myFunc [] = Nothing
myFunc [] -- Nothing
myFunc 1 -- Error

data Monster { mash = "The monster mash." }
let m = Monster
m :: mash
let myFunc (Monster ms) = "What are we going to do? " + ms
myFunc m
let n = Monster "Kill all reptilians."
myFunc n
myFunc 1 -- Error, requires a monster



-- Won't work, requires TCO.
let sums x y = if y > 0 then (sums (x + 1) (y - 1)) else if y < 0 then (sums (x - 1) (y + 1)) else x
sums 20 100000


// List comprehensions work! They're a little bit different than haskell in that the filters are collected up front and called on each item. Examples:

[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..5]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

let z = let x = 10 in x + 1 -- returns 11

let q = x / pi -- returns 10.822536130248883
    where 
        x = let y = 33 in y + 1



cave = bear ? otherBear -- Checks if Bear is nothing, returns if not, otherwise returns otherBear


// More prelude functions!
sum, take, drop, length, null,maximum, minimum, product, elem, replicate, slice

// $ function application and composition works!
mul 3 $ mul 3 $ div 2 $ add 3 $ 1 -- returns 4.5

(+) 2 . (/3) $ 3 + 4 -- returns 4.333333333333334
(+) 2 . (/3) . (^) 3 $ 3 + 4 -- returns 731
map ((+) 2 . (/3) . (^) 3) [1..9] -- returns 3,5,11,29,83,245,731,2189,6563
map ((+) 2 . (/) 3) [1..9] -- returns 5,3.5,3,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335

[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]
[5.0,3.5,3.0,2.75,2.6,2.5,2.4285714285714284,2.375,2.3333333333333335]

// These now work!
foldl, foldr, zip, zipWith, filter, head, tail, init, and last

// List creation syntax
[1,2,3,4] -- 1,2,3,4
[1..7] -- 1,2,3,4,5,6,7
[2,5..99] -- 2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98



// Dictionaries have been implemented as such

// Dictionary creation
("fives" = 555)
(someVar = 555, "A String" = [1,2,3], 1.5 = "Three")
let doom = ("Doom" = 3)

// Dictionary look up uses the !! operator or the lookup function.
doom !! "Doom"
lookup "Doom" doom -- Note that the dictionary is the last argument for the lookup function

// Insertion uses cons, and essentially merges two dictionaries returning a new one, with the left hand overwriting the right.
let gloom = ("Gloom" = "doom") : doom
let doom2 = ("Doom3" = 2, "Liar" = "Face") : doom

// You can also use the insert function
insert ("frogs" = [0,1,2]) doom

doom2 !! "Doom" -- returns 3
lookup "Doom3" doom2 -- returns 2
doom2 !! "Liar" -- returns "Face"


//////////////////////////////////////////
// Case Statements

examples:

-- Returns (\x y -> x + y)
case False of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns one
case 30 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns Nothing
case 0.5 of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)


-- Returns "YOYOYO"
case "Zombie" of
    "String" -> True
    20.1 -> "Good jarb"
    30 -> one
    False -> (\x y -> x + y)
    _ -> "YOYOYO"


//////////////////////
// Data 
//////////////////////

-- data declaration using record like syntax
data MyData { 
    thisThing = 1,
    two = 2,
    three = 44
}

-- data instantiation, less than the total number of members in the constructor will return with default value
MyData 0.1 0.5 0.2 -- returns MyData 1 2 44
MyData 0.1 0.5 -- returns MyData 0.1 0.5 44
MyData 666 -- returns MyData 666 2 44
let myCoolObject = MyData -- returns MyData 1 2 44

-- lookup is similar to namespace resolution in C++.
myCoolObject :: thisThing -- returns 1
myCoolObject :: two -- returns 2
myCoolObject :: three -- returns 44

data MyData { one = 1, two = 2, three = 3 }

let m = MyData 0.1 0.2 0.3
let m2 = m { two = 66 } -- returns 0.1 666 0.3


//////////////////
// Guard Patterns
// Dec 14, 2013

Is this any useful with Case statements the way they are?

Need to add syntax for guard patterns, for example:

myGuard x
    | x > 4 = 99
    | otherwise = 100



-- Test code for pattern matching with prelude functions
let actors = mapSpawn (add 2) [1..9]
let zipActors = zipSpawn [(add 2), (div 3), (sqrt)] [1..3]
zip [(add 2), (div 3), (sqrt)] [1..3]
map (\[x,y] -> show [x,y]) $ zip [(add 2), (div 3), (sqrt)] [1..3]
(\[x,y] -> x + y) [1,2]
filter (\[x,y] -> y > 5) $ zip [1..5] [3,7,9,5,2]
map (\[x,y] -> show [x * 2,y]) ("Doom" = [1,2], "Satan" = [3,"Sandwich"])
foldl (\acc [x,y] -> acc ++ [x,y]) [] $ zip [66..99] [1..9]
foldr (\[x,y] acc -> acc : [x,y]) [] $ zip [66..99] [1..9]
foldl (\acc x -> x : acc) [] [1..9]
foldr (\x acc ->  acc ++ x) [] [1..9]
zipFlat [1..99] [33,-16..-100]
zipWith (\x [y,z] -> [x ^ y, x ^ z]) [1..9] $ zip [33,-22..-1000] [1..9]
zipWith (add) [1..9] [3..5]
filter (\[x,y] -> y /= Nothing) $ zip [1..9] (zipFlat [33..1] $ replicate 5 Nothing)
filter (\[x,y] -> x < 3) ("Doom" => [1,2], "Satan" => [3,"Sandwich"])
let addOneSwitch = (\[x,y] -> [y,x]) . (\x -> [x + 1, x])
addOneSwitch 



data MyType { d = 4 }

let makeData x = MyType x

makeData 1

let myLoop m =
   receive
       "test"        -> self $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let myLoopTest m = case m of
       MyType        -> m{d = m::d + 1}
       "finished"     -> m::d



let m = MyType
m { d = m::d + 1 }

myLoopTest m



map (/=3) ("Doom" = "kj", "Doom2" = 2, "Doom3" = 3)



let hydra 666 = 6666
hydra 1

let hydra [x,y,z] = x + y + z
let hydra (x:xs) = x * 3
let hydra Nothing = 666
let res = hydra Nothing


-- Lexical Scoping Tests
let pi = 3.141592654
let pi_holder = 5 -- should be overwritten inside createArea
let createArea = area
    where
        pi_holder = pi -- The value we want to hold true in the createArea closure scope
        area r = pi_holder * r * r


let area = createArea -- redefinition of area but at global scope. Should not effect area from inside createArea
area 10 -- 314.1592653589793
pi_holder -- Should still be 5, because pi_holder in createArea doesn't change the global scope pi_holder
let pi_holder = 3 -- This should have no effect on createArea's evaluation
area 10 -- Succes! Still 314.1592653589793


-- Pattern matching tests
let headTail (x:xs) = xs
headTail [1,5..99]

let listMatch list@[1,Nothing,z] = list
listMatch [1,Nothing,3]

let lambdaMatch lamb@(\_ _ _ ->) = lamb 6 6 6
lambdaMatch (\x y z -> x + y + z)
lambdaMatch 1

(\(x:xs) y z -> x + y + z) [1,2] 2 3

let add3 x y z = x + y + z
add3
add3 1
add3 1 2 3
let add31 = add3 1
lambdaMatch (add3)
add31 2 3
let one = 1

-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let combo = add 3 . div 4
combo 6
add 3 . div 4 $ 6


let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add 1) [1..9]
(adds !! 2)

1 + 2
let three = add 1 2
three + 1
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 3
let add2 = (addList !! 1)
add2 1
let three = (addList !! 3) 0
three

let addDict = ("ADD3" = add 3, "ADD12" = add 1 2)
(addDict !! "ADD3") 1

add 1 2
let six = add3 1 2 3
six + 1
let add3 x y z = x + y + z
let add31 = add3 1
add31 2 3

add31
1 + 2
let addList = [add 1 2, add 2, add 3, add 4]
([add 1 2, add 666] !! 1) 2


[1..9] !! 3


-- Higher order function tests
let flip f a b = f b a
flip div 2 3
flip subtract 2 3

let one 1 = "ONEONEONE"
one 1
let one1 = 1
one one1
one (0.5 + 0.5)

let double x = x * 2
map (double) [1..9]


let listf [(x:xs),y,z] = x + y + z
listf [[3,7,88],7,9]

let whereFunc x = z [x, x * 2]
    where
        z (x:_) = x * 6
[1..9]
whereFunc 6

let adds = map (add) [1..9]
(adds !! 2) (-1)

let double x = x * 2
double
double 10
add
add 2
lookup 1


North /= West
zipFlat [1..9] [27,53..1000]
flip subtract 2 3
clientName
even 10
odd (-4)
[[x,y] | x <- [1..50], y <- [1..90]]
[x | x <- [1..10], even x]


[x | x <- [1..9]] -- returns [1,2,3,4,5,6,7,8,9]
[[x,y] | x <- [1..9], y <- [1,2]] -- returns [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,1],[7,2],[8,1],[8,2],[9,1],[9,2]]
[x * y| x <- [1..9], y <- [2..25]] -- returns [2,3,4,5,4,6,8,10,6,9,12,15,8,12,16,20,10,15,20,25,12,18,24,30,14,21,28,35,16,24,32,40,18,27,36,45]
[x * y | x <- [1..30], y <- [88,77,44], (x % 5) == 0, odd y] -- returns [385,770,1155,1540,1925,2310]

(3<=) 

2 - (-1)
2 : [3]
add (-1) 2
subtract
map (subtract) [1..9]
minus
minus 3 1
subtract 3 1
add x y = x + y

(+1) . (3/) . (subtract 1) . (1-) $ 5

let x = 11
let y = 22
4 << 3
add 2 3 >> div 2
3 >> add 2
add 2 $ 3

add 2 << 3

let one = 6
2 + (-one)

(5 >>) (div 3)


map (subtract 2) [1..9]

5 >> div 3 >> add 2 >> mul 6
5 >> (/3) >> (+2) >> (*6) >> (3+) >> (66-)

((3 / 5) + 2) * 6

mul 6 << add 2 << div 3 << 5
5 >> (div 3) >> (add 2) >> mul 6 >> (/3) >> (*2) >> (3/)
add 2 . div 3 $ 5
map (5 >>) $ map (div) [1..9]
map (5 >>) $ map (/) [1..9]

add 2 << (div 3 << 5)
5 >> div 3 >> add 2
(5 >>) (div 3)
5 >> div 3

spawn add [2,3]
spawn (add 2) [3]
spawn (\x y -> x / y * 666) [1,2]

data MyType{d = 4}

let myLoop m =
   receive
       "test"        -> myLoop $ m{d = m::d + 1}
       "finished"     -> m::d

let newLoop = spawn #Test2 myLoop [MyType 5]

"test" :>> newLoop
"finished" :>> newLoop

let newLoop = spawn #Test myLoop [MyType 5]

"test" :>> #Test
"finished" :>> #Test

let makeData x = MyType x
makeData 1
let m = MyType
let n = m { d = m::d + 1 }
m
n

data Monster { size = 6 }
let makeMonster x = Monster x
let monsterFactory maker =
    receive
        [x] -> maker x

let monsterActor = spawn #Monster (monsterFactory) [makeMonster]
[666] :>> monsterActor

map (map (/3)) [[x,y] | x <- [1..9], y <- [1..9], odd x, even y]
map (map (/3)) ("Doom" => [1..9], "Three" => [1..3])
replicate 3 $ replicate 3 $ replicate 3 0
deepMap (2+) $ replicateN [2,3,1,2] [1..9]
deepMap (2+) [1,2,[3],4,[[5]]]

print 1
2 + 2

spawn #print (\x -> x myName) [print]

let double x = x * 2

let printAndDouble x = do 
    print x
    double x

let printAndTriple x = do print x; print( x * 2); x * 3

printAndDouble 20

printAndTriple 10


-- Mountains of Madness testing
compile "MountainsOfMadness"
let actor = spawn #Madness madnessLoop [demoGame]

(Walk north "casiosk1") :>> actor
(Look north "casiosk1") :>> actor
Finish :>> actor

(Walk north "casiosk1") :>> #Madness
(Look north "casiosk1") :>> #Madness
Finish :>> #Madness

(findSomethingWithName "casiosk1") demoGame


chat ";lkwedlkwwf;lwkewe;ldkwd;lwkfwf;lkwef;lwkf"

clientName
1 + 1
random 1 7

spawn #ChatActor (chat) ["Hello, world."]
spawn #ChatActor (actorChat) ["Hello, world." + (random 0 1)]

importjs "../Pieces/MountainsOfMadnessPanel.js"
updateNarration "Yo!"
spawn #ChatActor (updateNarration) ["Hello, world."]
updateNarration


-- Guards are in
let myGuard (x:xs) 
    | x > 4 = 99
    | _ = 100

myGuard [1..9]



let whereGuard (x:xs) = y x
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard [1..99]
whereGuard [11..99]

let whereGuard2 = y
    where
        y z
            | z > 10 = "> 10 > 10 > 10"
            | otherwise = " < 10 < 10 < 10"

whereGuard2 1
whereGuard2 11

let fib n
    | n == 0 = 0
    | n == 1 = 1
    | otherwise = fib (n - 1) + fib (n - 2)

fib 8

let fib n = case n of
    0 -> 0
    1 -> 1
    _ -> fib (n - 1) + fib (n - 2)


setTempo 60
setTempo 300

let tempoSetter x = do setTempo x; sleep 0.1; tempoSetter $ random 60 1000
tempoSetter 60



{-
    Sequencing Ideas!!!!!
-}


-- Percussion sequencing is similar to tidal, but _ represents a rest, space seperates identifiers. We use | like in list comprehensions, but here they're for tempo multipliers and offsets
pattern     +> bass _
pattern2    +> _ snare
pattern3    +> _ hi
pattern4    +> down down down _ down [_ _ down] | (*4)
pattern     +> a | (*2) (\x -> 1 / x) (*3) (/4)

-- We can predefine percussive patterns without assignment using lambda style syntax (+>). This will create a new pattern without autoplaying for storage.
(+> a b c)
(+> a b [hi hi [_ low low hi]] | (+4))
-- Melodies use a similar scheme. Spaces separate numbers. Wild cards are rests. We use | like list comprehension but for offsets/multipliers which themselves can be sequenced with _ being default
octoSynth ~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-) (sqrt) _ _ _

-- Lambda style melody pattern
(~> synth1 1 2 3)
(~> synth2 1 2 3 44 2 4 _ _ _ 1 _ (-4) 9 1 23 | (* 3) (/4) _ (+1) )
(~> octopus 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (4-))
-- We can pass any function expecting one argument, including lambdas
(~> bass 1 _ 2 _ 3 _ _ 4 5 _ 6 _ -1 _ 3 _ -66 -99 99 | (sqrt) _ (\x -> if odd x then x + 1 else x))
-- We can also use lists like in Perc Sequencing to get tuples
(~> noise 1 2 [3 4 5] 1 [[1 2] 3])


let s = (sin 440) >> gain 0.5 >> play
stop s

let s = sin 3 >> gain 33 >> sin >> gain 666 >> sin >> gain 0.3 >> play
s >> stop

let s2 = sin 0.5 >> gain 66 >> sin >> gain 600 >> sin >> gain 0.3 >> play
s2 >> stop

let s3 = square 7 >> gain 66 >> square >> gain 33 >> square >> gain 0.2 >> play
s3 >> stop


let s4 = tri 2 >> gain 4 >> tri >> gain 99 >> square >> gain 0.2 >> play
s4 >> stop


let s5 = tri 66 >> gain 3 >> tri >> gain 14 >> square >> gain 0.3 >> play
s5 >> stop


let s = play (tri 440 >> gain 0.2)
stop s


let table = waveTable 33 (map (random 0) $ cycle 15 [(-1), 1]) >> play
stop table

let table = waveTable 33 (map (sin) [1..99]) >> play
stop table


-- Filters

let allpasser =  (dry * 0.5) + (wet * 0.5) >> play
    where
        dry = (square 88) * ((saw 60) * 0.1)
        wet = dry >> allpass (100) (sin 0.5)

stop allpasser



-- Function Composition Styles for Synth Definitions

let testFunc = play . sin . gain 440 $ sin 33
stop testFunc

let testFunc = sin 33 >> gain 440 >> sin >> play
stop testFunc

let testFunc = play(sin (gain 440 (sin 33)))
stop testFunc


let p = (playSample (choose sampleList) 2 0 2) >> play
stop p

let convolver = square 2 >> convolve "cluster" >> play
stop convolver

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> notch 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> lowpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> highpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 80 >> bandpass 666 20 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> lowshelf 33 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> highshelf 3333 16 >> gain 0.3 >> play
stop filterer

let filterer = square 33 >> peaking 3333 16 30 >> gain 0.3 >> play
stop filterer


-- range and exprange work!
let filterer = square 5 >> lowpass ((tri 1 >> range 1 100) * (sin 0.1 >> range 1 100)) 3 >> play
stop filterer

let filterer2 = square 13 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> play
stop filterer2


let glitter = (sin (sin 0.3 >> exprange 1 66)) * (sin 666) * (sin 3) >> delay (1/13) 0.9 >> gain 0.1 >> play

let glitter2 = (sin (sin 0.2 >> exprange 1 33)) * (sin (999)) * (sin 3) >> delay (4/13) 0.9 >> gain 0.1 >> play

let glitter3 = (sin (sin 0.5 >> exprange 1 66)) * (sin (666*2)) * (sin 2) >> delay (3/13) 0.5 >> gain 0.1 >> play

let glitter4 = (sin (sin 0.1 >> exprange 1 33)) * (sin (333*5)) * (sin 6.5) >> delay (1/13) 0.9 >> gain 0.1 >> play


let guitar = (saw 80) * (square 3) >> lowpass (sin 0.1 >> exprange 20 2000) 10 >> delay (1/3) 0.9 >> gain 0.3 >> play
stop guitar



let kick => square 80 >> perc 0.0 0.7 0.05
kicker +> kick _

let snare => square (80 * 16) >> perc 0.0 0.7 0.05
snarer +> _ snare

let hihate => tri (mul 80 $ randomI 1 32) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _ _
hater2 +> _ _ hihate _ _ _
hater2 +> _ hihate _ _ _ _ _
hater3 +> hihate _ _
hater4 +> hihate _ _ _ _ _ _ _ _

setTempo 500
setTempo 1000

-- Metric Onset Test, should produce consistent quarter notes no matter the timing of the starts
let hihate => tri (mul 80 $ randomI 1 24) >> perc 0.0 0.4 0.05
hater +> _ hihate _ _
hater2 +> hihate _ _ _
hater2 +> _ _ hihate _
hater3 +> _ _ _ hihate



-- Just Intonation Fun

let glitter4 = (sin (saw 0.1 >> exprange 1 40)) * (sin (160*10)) * (tri 6.5) >> delay (1/3) 0.3 >> gain 0.1 >> play

let k => tri 40 >> lowpass 320 1 >> perc 0.0001 1 0.3
kicker +> k _ _ k _ _ k _ | (/2)

let hh => sin (mul 80 12) >> perc 0.0 0.4 0.05
hate5 +> _ hh | (/2)

let hh2 => sin (160 * 10) >> perc 0 0.3 0.1
hate2 +> hh2 hh2 _

let hh3 => white 10 >> bandpass (80 * 17) 455 >> gain 10 >> perc 0.0001 1 0.1
hihate3 +> hh3 _ _ | (/2)
hihate4 +> hh3 _ _ _ _ | (/2)

let snare => white >> perc 0.0 0.7 0.5
let lkick => square 40 >> perc 0.001 0.7 0.4
lkicker +> lkick snare [_ lkick] snare | (*2)


let guitar => (saw (40 * (randomI 1 10))) * (sin 3) >> lowpass (80*17) 10 >> delay (1/5) 0.4 >> perc 0.1 0.3 3
guitarer +> guitar _ guitar _ _ guitar _ _

let filterer2 = square 80 >> lowpass ((saw 3 >> exprange 1 100) * (sin 0.3 >> exprange 1 100)) (sin 0.2 >> range 0.1 10) >> gain 0.3 >> play
stop guitarer
stop filterer2
stop glitter4



setTempo 300

let cluster => square 20 >> waveShape (map (nsin) [1..99]) >> lowshelf 40 12 >> perc 0 1 0.1
clusterz +> cluster _ cluster cluster | (/2)
let cluster2 => square 20 >> waveShape (map (nsin) [1..179]) >> perc 0 1 0.1
clusterz2 +> _ cluster2 _ | (/2)
let cluster3 => square 20 >> waveShape (map (nsin) [1..199]) >> perc 0 1 0.05
clusterz3 +> _ cluster3 | (/2)
clusterz4 +> cluster3 _  _ cluster3 | (/2)
let cluster0 => white 1 >> perc 0 0.4 0.5
clusterz0 +> _ cluster0 | (*2)



-- Melody sequencing is beginning to work!
let hh => white >> bandpass (100 * 32) 50 >> perc 0 3 0.1
hhh +> hh [_ hh] [_ hh] hh

let hh2 => white >> bandpass (100 * 16) 100 >> gain 20 >> perc 0 0.5 0.05
hhh4 +> hh2 hh2 | (/2)

let snare => white >> perc 0.0 0.7 0.3
let ss => white >> bandpass (340 * 8) 100 >> gain 30 >> perc 0.0 1 0.1
let lkick => square 80 >> add (tri 40) >> perc 0 0.6 0.1
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let bass freq => (sin freq) + white >> lowpass (freq * (pow 2 $ randomI 1 3)) 40 >> perc 0.01 0.3 (random 0.05 3)
bassSeq ~> bass 20 42.5 _ 80 160 _ 190 | (*2) (/2) (*1.75) _ _ (*1.5) (*2) _

let bass2 freq => (square freq) + white >> lowpass (freq * (pow 2 $ randomI 2 3)) 40 >> perc 0.0 0.6 0.1
bassSeq2 ~> bass2 [20 42.5] [42.5 80] [160 160] [190 190] | (*2) _ (*1.75) _ _ (*1.5) (*2) _ (*1.5)

let plunk freq => (sin freq * 16) >> perc 0.0 0.1 0.05
plunkSeq ~> plunk [80 170] [40 42.5] [42.5 80] [160 160] [190 _ 190 20] | (*2) (*2) (*1.75) (*6) (*8) (*6) (*4) (*2) (*1.5)

stop lkicker2
stop hhh4
stop hhh
stop plunkSeq
stop bassSeq2

-- chill for a minute
stop bassSeq

-- spliceOsc is back!
spliceOsc "someString!" 5



///////////////////////////////////
// GRAPHICS TEST CODE
///////////////////////////////////

initGraphics -- MUST DO THIS FIRST!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
setBackground (random 0 255) (random 0 255) (random 0 255)
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -100 100] [25, 25, 25] [random 0 (2*pi), random 0 (2*pi), random 0 (2*pi)] [0,200,150] 

setShader $ choose shaders
deleteMesh s
deleteMesh c

deleteScene
shaders
setShaders $ map (choose) $ replicate 3 shaders
clearShaders
wireframe true s
wireframe true c
wireframe false s
wireframe false c


wireframeAll (choose [true, false])

move [-1, -10, -2] s
move [-1, 1, -1] c
moveAll [random -1 1, random -1 1, random -1 1]

setColor [random 0 255, random 0 255, random 0 255] c
setColor [random 0 255, random 0 255, random 0 255] s
setColorAll [random 0 255, random 0 255, random 0 255]

rotate [random -1 1, random -1 1, random -1 1] c
rotateAll [random -1 1, random -1 1, random -1 1]

linear [0, 0, 1] c
linearAll [random -1 1, random -1 1, random -1 1]

angular [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1] c
angularAll [random -0.1 0.1, random -0.1 0.1, random -0.1 0.1]

setPosition [random -50 50, random -50 50, random -50 50] s
setPositionAll [random -50 50, random -50 50, random -50 50]

scale [random 0.1 1, random 0.1 1, random 0.1 1] s
scaleAll [random 0.1 1, random 0.1 1, random 0.1 10]

-- supports streaming style syntax
s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]

cloudMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
gaussianMesh (random 10 100) [random 0 255, random 0 255, random 0 255]
sinMesh (random 10 100) [random 0 255, random 0 255, random 0 255]

sinMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scaleAll [4, 4, 4]

let n = noiseMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] n
angular [0.01, 0.01, 0.03] n

deleteMesh n

let g = gaussianMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] g
angular [0.01, 0.01, 0.03] g

deleteMesh g


let s = squareMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [6,6,6] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let s = sawMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] s
angular [0.01, 0.01, 0.03] s

deleteMesh s

let t = triMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [10, 10, 10] t
angular [0.01, 0.01, 0.03] t

deleteMesh t

-- Won't be able to initially see it because of culling, set the angular!
let f = flatMapMesh 30 30 [random 0 255, random 0 255, random 0 255]
scale [4, 4, 4] f
angular [0.01, 0.01, 0.03] f

deleteMesh f
deleteScene
initGraphics

let s = sawMapMesh 20 20 [random 0 255, random 0 255, random 0 255]
scale [7, 7, 7] s
angular [0.01, 0.01, 0.03] s

spliceShader $ randomString $ random 1 5

-- Patterns are supported as well!
initGraphics
let s = sphere [random -100 100, random -100 100, random -10 10] 50 [random 0 255, random 0 255, random 0 255]
let c = cube [random -100 100, random -100 100, random -10 10] [50,50,50] [0.1,0,0] [random 0 255, random 0 255, random 0 255]
let meshSynth => s >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1]
let meshSynth2 => c >> wireframe (choose [true, false]) >> setPosition [random -10 10, random -10 10, random -10 10] >> setColor [random 0 255, random 0 255, random 0 255] >> linear [random -1 1, random -1 1, random -1 1] >> angular [random 0 0.1, random 0 0.1, random 0 0.1]
meshSeq +> meshSynth meshSynth2 meshSynth [meshSynth2 meshSynth]

-- Shader sequencing, yay!
let shaderSynth => spliceShader $ randomString $ random 1 5
shaderSeq +> shaderSynth _ _ _



-- Bus and Feed Back tests

let s = square 1 >> auxOut 0 >> play
let s2 = saw 3 >> gain 0.1 >> auxOut 0 >> play
let v = auxIn 0 >> convolve "cluster" >> gain 0.5 >> play

stop s
stop s2
stop v

fade 1 v

-- We can use aux buses for feedback
let s3 = auxIn 1 >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough 1 >> gain 2 >> play
stop s3

-- We can also use a localBus so as to not collide with anything else that might use a particular auxillary bus
let s4 = feed >> exprange 40 160 >> square >> gain 0.2 >> delay 1 0.5 >> auxThrough feed >> gain 2 >> play
    where feed = localBus 1

-- splice filters and feed back is cool, but they blow easily. Remember children, ctr-. is your friend!
square (saw 1 >> exprange 1 20000) >> add (auxIn 0 >> delay (1/3) 0 >> gain 0.9) >> spliceFilter (randomString 16) >> limiter -6 >> auxThrough 0 >> play

-- We can implement something similar with an fir and it will be much more stable
square (saw 1 >> exprange 1 20000) >> add (auxIn 0 >> delay (1/6) 0) >> fir [random -0.4 0.4 | x <- [1..10]] >> limiter -3 >> auxThrough 0 >> play


-- Scale testing code
let s freq => saw (freq) >> perc 0 0.4 0.75
sSeq ~> s 0 1 2 3 4 5 6 7 8 9 10 11 12 14 15 | (degree2Freq koto)s


-- Noises
white >> gain 0.4 >> play
clipNoise >> gain 0.4 >> play
pink >> gain 0.4 >> play
brown >> gain 0.4 >> play
violet >> gain 0.4 >> play

simplex 440 >> gain 0.4 >> play -- Not great for high frequencies
simplex 1 >> exprange 20 20000 >> sin >> gain 0.4 >> play -- cool lfo though
simplex 13 >> exprange 20 20000 >> sin >> gain 0.4 >> play
(square 40) * (saw 3 >> range 0 1) >> lowpass (simplex 0.3 >> exprange 20 20000) 20 >> gain 0.4 >> play

-- Simple averaging filters
square 440 >> gain 0.4 >> play -- For comparison
square 440 >> lpz1 >> gain 0.4 >> play
square 440 >> lpz2 >> gain 0.4 >> play
square 440 >> hpz1 >> gain 0.4 >> play
square 440 >> hpz2 >> gain 0.4 >> play
square 440 >> bpz2 >> gain 0.4 >> play
square 440 >> brz2 >> gain 0.4 >> play


-- Clip 
sin 440 >> clip 0.05 >> gain 4 >> play
sin 440 >> clip (tri 1 >> range 0 1) >> gain 0.4 >> play
-- Feedback clip modulation, use headhones!
square 40 >> clip (delay (1.6) 0 (auxIn 0) >> range 0.01 1) >> auxThrough 0 >> gain 0.4 >> play


-- Audio division works, yay!
sin (simplex 1 >> exprange 1 20000) >> delay (1/(simplex 0.79 >> exprange 2 100)) 0.9 >> gain 0.2 >> play

-- Bit Crunching and Decimation
sin 440 >> crunch (sin 0.3 >> range 0.01 4) >> gain 0.25 >> play
sin 440 >> decimate (sin 0.3 >> range 100 8000) >>  gain 0.3 >> play
sin (simplex 1 >> range 20 20000) >> decimate (sin 0.3 >> range 100 8000) >>  gain 0.3 >> play

-- Wrapping and Folding
sin (simplex 1 >> exprange 1 2000) >> wrap 0.1 >> gain 3 >> play
sin (simplex 1 >> exprange 1 2000) >> fold 0.1 >> gain 3 >> play


-- Env takes a list of levels, and times (with times being a length of 1 less), and a shape value, 0 is linear 1 is exponential
let s = sin (env [20, 20000, 1000, 1] times 1 1) >> env [0, 0.5, 0.125, 0] times 0 >> play
    where times = [1, 2, 3]


let s freq => brown 1 >> perc2 0 1 0.01 >> pluck freq 1 0.9 >> perc 0 1 2
sSeq ~> s 0 1 2 3 4 5 6 7 8 9 10 11 12 14 15 | ((/2) . (degree2Freq justMajor))

-- phaser
white 1 >> phaser 0.333 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> phaser 0.333 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> phaser 2 >> gain 0.3 >> play

-- flanger
white 1 >> flanger 0.333 0.3 0.3 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> flanger 0.333 0.3 0.3 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> flanger 2 0.3 0.3 >> gain 0.3 >> play

-- chorus
white 1 >> chorus 4 0.1 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> chorus 0.333 0.5 >> gain 0.3 >> play
(saw 80) + (saw 160) >> gain 0.5 >> chorus 2 0.5 >> gain 0.3 >> play

-- Mouse UGens
mouseX 400 20000 1 >> lag 0.1 >> sin >> add (sin (lag 0.1 $ mouseY 400 20000 1)) >> gain 0.3 >> play

-- First Order and Second Order filters
saw 200 >> fos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) >> gain 0.3 >> play
impulse 4 >> decay 0.5 >> fos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) >> gain 0.3 >> play

saw 200 >> sos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) (mouseX -0.5 0.5 0) (mouseY -0.5 0.5 0) >> gain 0.3 >> play
impulse 4 >> decay 0.5 >> sos (saw 0.5 >> range 1 0) (saw 8 >> range 0 0.4) (saw 1 >> gain 0.99) (mouseX -0.5 0.5 0) (mouseY -0.5 0.5 0) >> gain 0.3 >> play

-- Simple Reverb
impulse 1 >> decay 0.5 >> gain (white 1) >> reverb 0.5 40 2 0.3 >> gain 0.3 >> play
saw (noiseX 1 >> exprange 20 20000) >> reverb 0.5 100 5 0.5 >> gain 0.3 >> play
playSample "Ra1" 1 2 3 >> reverb 0.5 50 2 0.2 >> play


-- Graphics Notes
Make Graphics API more like Audio API
you should use stop instead of delete
and envelopes should give a mesh a lifetime?
New graphics functionality:
2D Drawing
Mesh Morphing/Animation between meshes
Sphere/Rect Height Maps (heights wrap around surface)
Mesh loading from file, similar to sample loading
More shader generating code -- Compile Lich.js directly to a shader?

-- Language to do
Enforce purity: Done?!
    Prevent redefinition of variables at global scope in library compilation
    Prevent multiple declaration of variables in and let statements


-- Audio to do
Fix Node leaks with custom UGens -- Fixed? Need to implement disconnect via setTimeout for all inputs like in exprange
spliceFilter? -> Adds poles according to splice string characters -- Done
Implement Limiter, writeBuf, and any other loose ends. Put in Master limiter? -- No write buffer in API. Compressor/Limiter is done.
Buses and Effects routing -- Done!?
Panning! -- Doneish, the API isn't responding to float panning



square 440 >> gain 0.4 >> play
square 440 >> lpz1 >> gain 0.4 >> play
square 440 >> lpz2 >> gain 0.4 >> play
square 440 >> hpz1 >> gain 0.4 >> play
square 440 >> hpz2 >> gain 0.4 >> play
square 440 >> bpz2 >> gain 0.4 >> play
square 440 >> brz2 >> gain 0.4 >> play

simplex 440 >> gain 0.4 >> play -- Not great for high frequencies
simplex 1 >> exprange 20 20000 >> sin >> gain 0.4 >> play -- cool lfo though
simplex 13 >> exprange 20 20000 >> sin >> gain 0.4 >> play
(square 40) * (saw 3 >> range 0 1) >> lowpass (simplex 0.3 >> exprange 20 20000) 20 >> gain 0.4 >> play

simplex
sin 440 >> clip (tri 1 >> range 0 1) >> gain 0.4 >> play
square 40 >> clip (delay (1.6) 0 (auxIn 0) >> range 0.01 1) >> auxThrough 0 >> gain 0.4 >> play   

sin 440 >> clip 0.05 >> gain 4 >> play


setTempo 100

let bass2 freq => osc >> dist >> filt >> env
   where
       osc     = (square freq) + (square (freq*0.5) ) + (white 1)
       dist    = peaking (freq * 0.25 * (pow 2 $ randomI 2 3)) 40 20
       filt    = lowpass (freq * 0.25 * (pow 2 $ randomI 2 3)) 30
       env     = perc 0.0 0.6 1
       

bassSeq2 ~> bass2 [20 42.5] [42.5 80] [160 160 160 160] [190 _ 190] | (*2) _ (*1.75) _ _ (*1.5) (*2) _ (*1.5)


-- Gamelan improv stuff
let sinSynth freq => saw freq >> gain (sin 4 >> range 0 1) >> lowpass (freq * 2 * (sin 4 >> range 0 1)) 1 >> perc (random 0 0.5) 0.3 (random 1 5)
sinSeqer ~> sinSynth 1 _ _ 1 | (\x -> degree2Freq slendro (randomI -5 10))
sinSeqer3 ~> sinSynth _ 1 1 _ | (\x -> degree2Freq slendro (randomI -5 10))

stop sinSeqer

let sinSynth3 freq => saw freq >> gain (sin 4 >> range 0 1) >> lowpass (freq * 2 * (sin 4 >> range 0 1)) 1 >> perc 0 0.2 0.2
sinSeqer4 ~> sinSynth3 _ _ 1 _ | (\x -> degree2Freq slendro (randomI -5 10))
sinSeqer5 ~> sinSynth3 1 _ _ _ | (\x -> degree2Freq slendro (randomI -5 10))
stop sinSeqer5
let sinSynth2 freq => square freq >> gain 4 >> clip 0.1 >> gain 10 >> perc 0 0.4 4
sinSeqer2 ~> sinSynth2 1 _ _ _ | (\x -> degree2Freq slendro (randomI -15 -10))
let sinSynth3 freq => tri freq >> gain (sin 4 >> range 0 1) >> lowpass (sin 4 >> range 80 (freq * 2)) 0.0001 >> perc 0.0001 0.2 2
sinSeqer4 ~> sinSynth3 1 4 2 4 | (\x -> (/8) $ (*x) $ degree2Freq slendro (randomI -5 10))
stop sinSeqer4
let bd => tri (degree2Freq slendro -10) >> add (brown >> gain 1) >> lowpass 100 1 >> perc 0 3 0.25
let sd2 => sin (freq + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> bandpass freq 50 >> env [0, 1, 0.035, 0] [0, 0.05, 1] 0 >> auxThrough 0
    where freq = (degree2Freq slendro 5)
    
drumsD2 +> bd [_ bd] [_ sd2] sd2 | (*2)

let delayFX = auxIn 0 >> gain 1 >> lowpass 500 1 >> delay 0.5 0.6 >> play
stop delayFX


let bd => square (degree2Freq slendro (randomI -10 -5)) >> lowpass 300 1 >> perc 0 0.5 0.1
let sd2 => sin (degree2Freq slendro 10) >> perc 0 0.2 0.05
let sd2 => white 1 >> perc 0 0.2 0.1
drumsD2 +> bd _ [bd sd2] sd2 | (*2)

pink 1 >> gain 0.2 >> play


-- More ugen test code

noiseL (sin 1 >> range 1 13) >> exprange 400 4000 >> sin >> gain 0.3 >> play
noiseX (sin 1 >> range 1 30) >> exprange 400 4000 >> sin >> gain 0.3 >> play

linexp 10 0 20 1 2000


pink >> perc 0 1 0.06 >> play

slopeX 2000 1000 20 >> sin >> gain 0.3 >> play
slopeX 1000 2000 20 >> sin >> gain 0.3 >> play


impulse 13 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play


tri 0.1 >> exprange 400 2000 >> latch (impulse 7) >> sin >> gain 0.3 >> play

sin 1 >> exprange 400 2000 >> divider (noiseN 5 >> exprange 1000 40000) >> sin >> gain 0.3 >> play

square 80 >> divider (random 1 500) >> perc 0 0.5 2 >> play

noiseN 40 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play

square 5 >> gate (sin 440) >> gain 0.3 >> play

dust 10 >> play

dust 20 >> toggle >> gain 2000 >> add 1000 >> sin >> gain 0.3 >> play

sin (noiseN 3 >> exprange 1 30) >> range 0 3 >> select [sin (slopeX 1000 4000 20), sin 2000, sin (slopeX 4000 1000 20)] >> gain 0.3 >> play 
dust 30 >> stepper 1000 400 -100 >> sin >> gain 0.3 >> play

dust 10 >> sweep (sin 0.3 >> gain 1000) >> add 1000 >> sin >> gain 0.3 >> play
phasor 200 10000 (sin 0.3 >> gain 2) >> sin >> gain 0.3 >> play

sin 666 >> poll >> gain 0.3 >> play

crackle 1.95 >> sin >> gain 0.3 >> play

dust 5 >> trand 400 2000 >> sin >> gain 0.3 >> play
dust 5 >> trandX 400 2000 >> sin >> gain 0.3 >> play

impulse 10 >> coinGate 0.5 >> stepper 1000 400 -100 >> sin >> gain 0.2 >> play

-- Buffer UGens
playBuf (sin 440 >> recordBuf (newBuffer 1024) 1) 1 >> play
playBuf (fillBuffer $ map (nsin) [1..1024]) (noiseX 10 >> exprange 0.001 sampleRate) >> play
sin 440 >> recPlayBuf (newBuffer sampleRate) (noiseX 1) (noiseX 1 >> gain 2) >> gain 0.5 >> play
sin (noiseL 2 >> exprange 200 2000) >> recPlayBuf (newBuffer sampleRate) (noiseL 7) (sin (noiseX 1 >> exprange 1 40) >> gain (noiseL 3 >> range 0 4)) >> gain 0.5 >> play

-- Filters
square 2 >> range 400 1600 >> lag 0.1 >> sin >> gain 0.3 >> play
square 1 >> range 400 1600 >> lag (sin 0.1 >> range 0.001 1) >> sin >> gain 0.3 >> play
impulse 2 >> decay2 (sin 0.25 >> exprange 0.001 1) 2 >> gain (pink * 0.1) >> play
impulse 2 >> reson 1000 1 >> gain 0.5 >> play
impulse 2 >> reson (sin 0.3 >> exprange 400 4000) (tri 0.1 >> range 0.001 2) >> gain 0.05 >> play

-- Pluck
let kd = degree2Freq koto -- Compile this first!
white 1 >> perc2 0 1 0.05 >> pluck (kd (random -5 10)) 3 0.3 >> perc 0.01 0.15 1 >> play
pink 1 >> perc2 0.5 1 0.05 >> pluck (kd (random -5 10)) 3 0.3 >> perc 0.1 0.1 2 >> play
brown 1 >> perc2 1 0.3 3 >> pluck (kd (random -5 10)) 6 0.7 >> perc 1 0.5 3 >> play

let kSynth freq => white 1 >> perc2 0 1 0.05 >> pluck freq 6 0.3 >> perc 0.01 0.15 1
kMelody ~> kSynth (kd -12) _ (kd -8) _ (kd -4) (kd (choose [1, -1, -5])) (kd -9) (kd -5) | (*2) _ _ _ _ _ (*2) _
kMelody2 ~> kSynth (kd -12) _ (kd -8) (kd -4) _ (kd (choose [1, -1, -5])) _ (kd -9) _ (kd -5) | (*4) (*4) (*2)
stop kMelody
stop kMelody2

--cool pluck based synth
let kSynth freq => saw freq >> add (saw (freq*1.002)) >> perc2 0 1 1 >> pluck freq 1 0.9 >> perc 0.0001 0.4 0.2
kBass ~> kSynth [(kd -12) (kd -8)] [(kd -4) (kd (choose [-2, -4, -5]))] [(kd -9) (kd (choose [-7, -5]))] | (/2)


-- Cool flittery plucky melody
let kSynth3 freq => white 1 >> perc2 0 1 0.03 >> pluck freq (random 0.1 4) (random 0.05 1) >> perc 0.01 0.15 0.5
kMelody3 ~> kSynth3 [(kd -12) (kd -8)] [(kd -4) (kd (choose [-2, -4, -5]))] [(kd -9) (kd (choose [-7, -5]))] | (/2) _ _ (/2) _ (*2) _ (*2) (*4) _ (/2) _ _ (/2) _ (*2) (*4) (*8) _

-- Frequency shifting
sin 440 >> freqShift (noiseX 13 >> gain 1000) >> gain 0.3 >> play
sin 440 >> pitchShift 20 >> gain 0.3 >> play
sin 440 >> gain 0.3 >> play
square (noiseX 2 >> exprange 10 10000) >> freqShift (square (noiseX 1 >> exprange 3 40) >> gain 4000 >> gain (noiseX 1)) >> gain 0.3 >> play

---------------------------------------------------------------------------------
---------------------------------------------------------------------------------

let sqkick => white + tri (random 148 152) >>
    (lowpass (random 990 1100) 5) >>
    perc 0.0 1 0.07
    
psqkick +> sqkick _ sqkick _ [_ sqkick] sqkick | (*1) (*1) (*2) (*3)
stop psqkick

let fmsnare => white + sin (sin (random 205 215) >> range 20 400) >>
    (highpass (random 290 310) 40) >>
    perc 0.0 0.7 0.05
    
pfmsnare +> _ [fmsnare fmsnare] _ [_ fmsnare] _ [fmsnare fmsnare] _ | (*1) (*1) (/2)
stop pfmsnare

let whitehat => white >> highpass (random 3900 4100) (random 10 15) >> perc 0.0 0.4 0.07

pwhitehat +> whitehat [whitehat whitehat] [_ whitehat] | (*1) (*2) (*2) (/2)
stop pwhitehat

---
let coleJI = Scale { tuning = [ 1, (10/9), (9/8), (8/7), (6/5), (4/3), (11/8), (3/2), (8/5), (7/4), (16/9), (9/5) ], degrees = [0,1,2,3,4,5,6,7,8,9,10,11], pitchesPerOctave = 12, rootFreq = koto::rootFreq }

let lead => brown + square ((randomI 0 24) >> (degree2Freq coleJI)) >>
    lowpass (random 600 3000) (random 5 20) >>
    delay 0.1 0.7 >>
    perc 0.01 (random 0.1 0.125) (random 0.2 1.2)

plead +> lead _ lead _ lead lead [_ lead] lead | (*1) (*1) (/2) (*1) (*2) (/2)


let coleJI = Scale { tuning = [ 1, (10/9), (9/8), (8/7), (6/5), (4/3), (11/8), (3/2), (8/5), (7/4), (16/9), (9/5) ], degrees = [0,1,2,3,4,5,6,7,8,9,10,11], pitchesPerOctave = 12, rootFreq = koto::rootFreq }


let growl freqq => osc >> fold 0.125 >> filt >> gain 128 >> env
    where
        freq    = freqq * 0.25
        env     = perc 0.0 0.6 1
        osc     = (square (freq*1.05)) + (sin (freq*1)) + (square (freq*0.49) )+ (tri (freq * 2))
        filt    = lowpass (freq * 0.25 * (pow 2 $ randomI 2 3)) 10

growlTime ~> growl 0 _ _ _ 2 _ 0 _ 5 _ 4 _ | (degree2Freq coleJI)
stop growlTime
let spinning freqq => osc >> filt  >> gain 0.25 >> env
    where
        freq    = freqq * 1
        env     = perc 0.6 0.6 0.01
        osc     = (tri (freq*1.00)) + (saw (freq*1)) + (tri (freq*0.5) )+ (tri (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 3)) 10

spinTime ~> spinning 0 _ _ _ 2 _ 0 _ 5 _ 4 _ _ _ | (degree2Freq coleJI)

let spinning2 freqq => osc >> filt >> gain 0.25 >> env
    where
        freq    = freqq * 0.5
        env     = perc 0.6 0.6 0.01
        osc     = (tri (freq*1.00)) + (saw (freq*1)) + (tri (freq*0.5) )+ (tri (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 3)) 10

let x = 5
spinTime2 ~> spinning2 0 (x) _ _ 2 _ 0 _ 5 _ 4 _ 6 _ _ _ | ((*x) . (degree2Freq coleJI))
    where x = 2


let ice9 freqq => osc >> dec >> filt >> delay 0.25 0.5 >> gain 0.25 >> env
    where
        freq    = freqq * 2
        env     = perc 1 0.6 4
        dec     = decimate (freq * (randomI 1 2))
        osc     = (tri freq) + (square (freq * 0.5)) + (saw (freq * 0.25)) + (sin (freq * 2))
        filt    = lowpass (freq * 2 * (pow 2 $ randomI 2 5)) 20
        
iceChords ~> ice9 
    0 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _
    | (degree2Freq coleJI)
    
let ice10 freqq => osc >> dec >> filt >> delay 0.25 0.5 >> gain 0.25 >> env
    where
        freq    = freqq * 2
        env     = perc 1 0.6 4
        dec     = decimate (freq * (randomI 1 3))
        osc     = (tri freq) + (square (freq * 0.5)) + (saw (freq * 0.25)) + (sin (freq * 2))
        filt    = lowpass (env $ freq * 4 * (pow 2 $ randomI 2 5)) 40

iceChords2 ~> ice10
    0 1 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    0 4 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    0 5 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
    | (degree2Freq coleJI)
    
stop iceChords2
stop iceChords
stop spinTime
stop spinTime2
stop growlTime


--| Chad Sounds

--| Section 1 stuff, combos with Cole/Curtis Sounds
let snare => choose [violet,pink,brown,white,clipNoise>>gain 0.5] >> delay (1/(ff -14)) 0.999 >> env [0,1,1,0] [0,(random 0.02 0.15),0] 0 >> auxThrough 5
let ss => pink >> bandpass (ff 16) 4 >> gain 16 >> delay (1/(ff (random -16 -8))) 0.999 >> env [0,0.3,0.3,0] [0,0.05,0] 0 >> auxThrough 5
let lkick => square (ff -16) >> add (tri $ ff -24) >> perc 0 0.6 0.05 >> auxThrough 5
lkicker2 +> [lkick ss] [snare ss] [ss lkick] [ss snare]


-- Section 2 stuff, Not to be mixed with other sounds
let bd => tri (degree2Freq coleJI -19) >> add (tri (degree2Freq coleJI -20)) >> lowpass 100 0.1 >> perc 0 1.2 0.15
let bd2 => tri (degree2Freq coleJI -22) >> lowpass 500 0.1 >> perc 0.005 2 1
let sd1 => sin ((freq 0) + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> highpass (freq 0) 30 >> env [0, 0.03, 0.0035, 0] [0, 0.0001, random 0.01 0.2] 0 >> auxThrough (randomI 0 3)
    where freq x = degree2Freq coleJI (add 12 $ randomI -1 1)
let sd2 => sin (freq + (random -13 13)) >> gain 0.25 >> add (violet >> gain 30) >> bandpass freq 50 >> env [0, 1, 0.035, 0] [0, 0.05, 1] 0 >> auxThrough (randomI 0 3)
    where freq = (degree2Freq coleJI 15)
let sd3 => violet + pink >> bandpass (degree2Freq coleJI 26) 1 >> lowshelf 200 12 >> env [0,1,0.03,0] [0,0.1,1] 0 >> auxThrough (randomI 0 3)
    
drumsD2 +> bd [_ bd] [_ sd2] sd2 bd [_ bd] [sd1 sd2] sd2 _ [bd _] sd2 [sd1 sd2] [bd sd2] [sd1 bd] [sd2 sd1] sd2
drumsD3 +> _ sd3 | (*2)

let delayFX = auxIn 0 >> lowpass (sin 0.1767 >> range 200 1000) 5 >> delay 0.5 0.6 >> play
let delayFX2 = auxIn 1 >> highpass (sin 0.1 >> range 200 1000) 5 >> delay 0.75 0.5 >> play
let delayFX3 = auxIn 2 >> gain 2 >> bandpass (sin 0.1317 >> range 200 2000) 5 >> delay 1.125 0.75 >> play
-- Don't stop these right now, just for later
stop delayFX
stop delayFX2
stop delayFX3
stop drumsD2
stop drumsD3


let neonBass freq => (square (freq/2)) + (saw (freq*2)) + (saw (freq*(add 2 (sin 4 >> gain 0.04)))) + (pink 1 >> lowpass freq 50) >> lowpass (sin 0.1 >> range 200 1000) 0.01 >> env [0.0,0.2,0.03,0] [0.002,1,3] 0
let ff = degree2Freq coleJI
neonBassSeq ~> neonBass (ff -12) _ (ff -8) _ _ _ (ff -4) _ (ff (choose [1, -1, -5])) _ _ (ff -9) _ _ (ff -5) | (/2) _ _ _ _ _ (/2) _
stop neonBassSeq


let neonBass2 freq => (saw (freq/2)) + (saw (freq/(add 2 (tri 4 >> gain 0.08)))) + (pink 1 >> lowpass freq 10) >> env [0.0,0.25,0.03,0] [0.001,0.1,3] 0 >> auxThrough 3
neonBassSeq2 ~> neonBass2 [(ff $ choose [-6, -12]) (ff $ choose [-5,-8])] [(ff $ choose [-5, -4]) (ff (choose [1, -1, -5]))] [(ff -9) (ff -5)] | (*4) (*8) (*4) (*2) (*2) _ (/2)

-- Don't stop yet, this is just for later
stop neonBassSeq2
-- This goes with neonBass2
let delayFX4 = auxIn 3 >> env2 [0,1] [1] 0 >> delay (sin 0.3 >> range 0.01 0.001) 0.1 >> delay 1.25 0.6 >> gain 0.25 >> play
stop delayFX4



-- Noisey
let snare => pink >> delay (1/(ff -8)) 0.1 >> perc 0.0 0.9 0.3 >> auxOut 5
let ss => violet >> bandpass (ff 3) 30 >> gain 30 >> perc 0.0 0.4 0.1 >> auxOut 5
let lkick => square (ff -12) >> add (tri 40) >> perc 0 0.3 0.1 >> auxOut 5
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let drumDecimFX = auxIn 5 >> delay 0.125 0.2 >> crunch 1 >> decimate (add 8000 (simplex 0.1 >> gain 3500)) >> gain 0.5 >> play
stop drumDecimFX



---------------------------------------
-- Archived Other shit
---------------------------------------

let snare => pink 1 >> delay (1/(ff -8)) 0.1 >> perc 0.0 0.9 0.3 >> auxOut 5
let ss => violet 1 >> bandpass (ff 3) 30 >> gain 30 >> perc 0.0 0.4 0.1 >> auxOut 5
let lkick => square (ff -12) >> add (tri 40) >> perc 0 0.3 0.1 >> auxOut 5
lkicker2 +> [lkick lkick] [snare _ ss snare] [ss [lkick lkick]] [_ ss snare _] | (*2)

let drumDecimFX = auxIn 5 >> delay 0.125 0.2 >> crunch 1 >> decimate (add 8000 (simplex 0.1 >> gain 3500)) >> gain 0.5 >> play
stop drumDecimFX









































































































// synthesis techniques worth implementing
Comb Filter -- This is basically what delay is. Consider refactoring?
Karplus-Strong -- Done but slow
Moog Style filter -- maybe lator...
Pitch and Freq Shift -- Pitch Shift doesn't work right, but Freq Shift is done. both are very expensive.
Better Wave Shaping, distion types of effects (Need Chebyshev polynomials to good dist I think)
Chorus, Phaser, Flanger -- Done
Trigger UGens, Stepper -- Done
