// Lich Dev Notes

// 09/24/2013

add alt-enter for an execute command combo.
For primitive that takes anything, a number, a string, whatever, and does something according to it's length.

// 09/23/2013
To Do:
Create a terminal like inteface by using the arrow keys to move the selection around with a 1 character range.
Make all primitives support all types in some form.
All functions that take arrays at any point should multichannel expand into arrays. This goes for booleans and everything else except indexing and length and shit.


Primitive support for Signals for the most part done except those primitives that don't support all types

if else control implemented. else doesn't do anything except repush the top of the stack, however it might visually be easier to understand

// 09/22/2012
AUTOMATIC VARIABLE NAME GENERATOR MACRO!!!!

Japanese emoticons:
http://www.japaneseemoticons.net/all-japanese-emoticons/

IDEAS: 
^->^Dragon
/\../\Bat
<*,^^,--Alligator

Added insert primitive for all types, but they don't support all types. Need to add this.
add new insert method:
-> mySignal 0.666 7.7
Signal now works with absolute times. Combining Signals works. Need to fill in the rest of the primitives for the other objects. Notably String.
Also, should add another interpolation type to LichSignal. Something that takes a curve number like Env in SuperCollider?
Changed LichSignal to work with absolute times.

=> mySignal Signal [[0 0] [0.1 1] [1 0]] 'linear'

points need to be added to Signal in ascending time

// 09/21/2012
.at() should push onto the stack, not just return a value DONE!
Add the other primitives for Signal
Make the Signal add, subtract, etc.. reference levels[i].value() and times[i].value() because the components are LichFloats!

New type! 
Signal - A continuous container that can be indexed at any point in time. It can have different interpolations: None, Linear, Bicubic.
supports all math operators
Fill functions? This is where the operator shit comes in down below.
Multiple Dimensions?!?!

Add primitive support for LichSignal to ALL TYPES!
=> mySignal Signal [ ] [ ] 'exponential'  

Emoticon coding?!

macros for spitting out emoticsons?


SHOULD POST ERRORS FOR VARIABLES NOT FOUND? DONE!

Should use assignment operator instead of just auto assign? DONE!
=> myVar 1

REDEFINITION WORKS!

The language is beginning to be flesh out. The question is, what makes is unique and different from lua or scheme or anything else?
All objects should support multichannel expansion. All functions should support multichannel expansion, including if statements

Comments Added!
Functions inside of functions supported!
Multidimensional Arrays supported!

While statements?
Do statements? DONE!
Increment and Decrement DONE!


Ideas for unique elements:

No errors: Any error is caught and some reasonable facsimile is compiled instead.
Symbolic notation like earlier.

Some chaotic elements?

// 09/20/2012

Array subtraction is wrong. It's negative when it should be positive

My want to check these object methods:  these should play with the length where possible, not the ascii characters
String.divide() 
String.modulus()
String.multiply() 
String.subtract()

Done?

Boolean comparisons between floats and arrays should multichannel expand. Are arrays working right?!
Overall nothing crashes (awesome!). Some behavior could be tweaked, such as strings. Also Arrays. Should everything multichannel expand?
What happens when an if statement gets an array of booleans instead of just one?!?

Should objects return themselves instead of some inner value?
Assignment should get the value of the top of the stack not just the item?
Arrays are broken with variables and primitives and shit...need to look into it.
Variable declaration no longer working with array math?
Should variable assignment push the object back onto the stack?

You can no longer assign a variable to primitive...is this a bad thing? IT SEEMS TO BE BREAKING SHIT?
FIX: Don't make variables automatically resolve primitives. Instead, have all objects return LichObjects on .value(). When you want their internal value use a different command?

IDEA FOR A NEW NETWORK PROGRAMMING LANGUAGE:
Virtual Physical Computer...3D machine language with blocks and logic gates and types, etc... Like physical computing, but virtual!!!!
Then give AI to the components? The Logic programs their own AI type behavior??
Symbolic computation!?
Cellular Automata based language?! Etc..

Add Multidimensional support in additional to multiple types with the LichArray
STILL NEED THE PRINT STRING FOR THE PRINT METHOD!
ALl OBJECTS NEED A .toPrintString() argument that returns a string for printing. To be used for both state printing and for the print object.

// 09/19/2012

TO DO:
Make array collect objects just like the function declaration does. Make an array of Lich objects and pass that to the Array class
Make a printing function (with aux help functions) that prints arrays functions, etc.. correctly inferring types and values form the LichVM.state
COMMENTS!
All primitives should work for any type. Working on this. Going to take a while. Also need to make arrays how any Lich classes, not just javascript floats. This will make operators
More booleans >, <, >=, <=
Nested Function Declarations don't work in the parsing
Arrays of different types
Cool operator stuff (similar to ixilang..ish?) as shown below.


Strings are implemented! Can use 'writing some stuff' or "writing some stuff"

LichFunction differentiates between value and call, everything else does not, they're the same
All Classes implement the same public methods!

All Types must have these methods:
value, call, type, length, at, add, subtract, multiply, divide, modulus, equivalent, inequivalent, greater than, less than, greater than equal, less than equal

What to do when primitives continuously call themselves? Fixed!...maybe? Could have other repercussions for not pushing itself. 

// 09/18/2012

Differentiate between primitives that always evaluate and functions that don't evaluate until called?

The problem I have now is that functions want to evaluate as soon as you collect them. How to differentiate between definition and evaluation. FIXED!

== and != operators have begun to be implemented. They need to be fleshed out for Primitives and Functions
true and false have been declared as constants

operator chaining? uses last ~=> ~+=> stuff like this? what could this mean? looks cool?!
what about shit like this? ((o)) (oo(ooOoo)oo) (oOo(Oo0oO)oOo) ? Rhythmic shit? Array generation?

Interesting looking stuff for array filling?

Smooth contours? Using these characters o O 0 ( )
((o)) (oo(ooOoo)oo) (oOo(Oo0oO)oOo) .o0o.0o.0..o.o0.0o.0..o00o.

Angular contours? using these characters
<<^v^^^Vvv^v^^^V>>

Sparse Contours? . : and space
..:..:.:.:.... . . .:::::.   ..::..   . .    :::: . . . .:.:.:.

|||||\\\\/////\\\\/\|||||//////////////\\\\\||||||\\|\|\|\
[][[[[[[]]]]]]]]ll[l[lllll]]]]][[[][][]lll[][]ll]

need to make >, <, >=, <= functions

If statements? While statements?

if statement { trueFunc } { falseFunc }
if statement { trueFunc } else { falseFunc }

@ myFunc myArg1 myArg2
#
&
$
~
/
^myFunc

call myFunc arg1 arg2 arg3

myFunc : { }

~>myFunc arg1 arg2

@ myArray 4
@ = at for array indexing
# myFunc arg1 arg2
call myFunc arg1 arg2

else is a function that just calls it's argument!?

Change arrays to support multiple types?
Functions that just have floats or arrays, how to return them correctly?

support for argument less functions with just { } DONE!
Switched LichFunction to LichPrimitive and LichFunctionDefinition to just LichFunction. DONE!
Need to make Functions with 1 and 0 args work and also have single functions that are just called alone not continuously push themselves. FIXED!

// 09/17/2012

Function with numbers of arguments two and higher works. Function with one or zero arguments don't work.


// Function declaration examples
// Declare
myFunction : arg1 arg2 { arg1 + arg2 }
// Evaluate
myFunction 1 1
// Returns
2

// THIS DOESN'T WORK!
// Declare
double : arg { * arg 2 }
// Evaluate
double 3
// Returns
6

change names of LichFunctionDefinition to just LichFunction, and the currently named LichFunction to LichPrimitive.
The difference being that primitives are written in pure javascript while the LichFunctions are written in Lich.

Print command!
Use an = sign for assignment!?
Functions in Arrays???
Function declaration...done?!
Comments
Variables pointing to other variables...works? Needs testing. Should probably make a unit test.
Need to use delete and null to free up memory?
Variable declaration should end up posting something more useful than "Undefined"
Calling a lone function continuously pushes and pops itself. Perhaps a better way to do assignment??

// 09/16/2012

Prefix operation order and stack implemented. 
Array and float math supported

// 09/15/2012

Dev begins!

The main editor could be something along the lines of a typical terminal, however this might be unwieldy to develop for multiple simultaneously editing user. Perhaps a simpler text editing interface with a partitioned post window/panel would be better.

I do like the square terminal style text cursor. I would like to implement this if possible, just for aesthetics. (THIS LOOKS MUCH HARDER THAN IT WOULD SEEM TO DO. PROBABLY NOT WORTH IT!)

Fill the textarea with \n. Remove deletes at the end of the line. Remove enter from creating new lines


Make post window delete old lines instead of adding new ones past the screen scroll


//////////////////
// Language Notes
//////////////////

Procedural, prefix, weakly typed 

3 Types of characters:
Names(of functions and variables, given as a string of characters)
floats
White space(space, tab, \n)

3 data types: floats, functions, and Arrays
They all subclass the same abstract class and are interchangeable as arguments
Functions store their parameters and always point to the same parameters when they are executed.

// Parsing and evaluation:

Two stacks: Token stack and Result stack

Tokens are variables, function, or floats
Results are arrays of floats

Multichannel expansion!
When adding two arrays of different sized, the smaller array is indexed with a wrapped index

NO ORDER OF OPERATIONS!!!!

1. Parsing - Tokenizes everything, pushing it onto a stack (this will have to be an Array in js) one by one
2. Work from the top to the bottom (end to the beginning), evaluating each expression as you go. Some functions require a certain number of arguments and replacing them in place? Or pushing the results to a separate stack? 
3. As variables are declared/assigned they populate the global namespace. 
4. Print the result when the stack has emptied

///////////////////////////////////
// Parsing and Evaluation Examples
///////////////////////////////////

// Simple function evaluation example

add 2.0 5.0 // the code to be evaluated, next the stacks in progress

// Token Stack 	|	Result stack	// Start from the beginning, pushing tokens onto the token stack until we reach the end
add				|
add 2.0			|
add 2.0 5.0		|					// Once we get to the end, work backwards adding results to the results stack until we hit a function
add 2.0			|	[5.0]
add				|	[5.0] [2.0]
				|	[5.0] [2.0] add // The function is pushed onto the results stack
				|	[7.0]			// We pop the function which pops results from the result stack for it's parameters and pushes it's results
				

// Slightly more complicated example

add 2.0 divide 6.0 3.0 // code to be evaluated

// Token Stack 			|	Result stack					// One by one push tokens onto the stack
add						|
add 2.0					|
add 2.0 divide			|
add 2.0 divide 6.0		|
add 2.0 divide 6.0 3.0	|	
add 2.0 divide 6.0		|	[3.0]
add 2.0 divide			|	[3.0] [6.0]
add 2.0					|	[3.0] [6.0] divide 
add						|	[3.0] [6.0] divide [2.0]
						|	[3.0] [6.0] divide [2.0] add
						|	[3.0] [6.0] divide [2.0]		// Once the token stack has all been pushed, pop the top, which is a function and evaluate
						|	[2.0] [2.0]						// The add function takes two arguments, upon popping the divide it evaluates it's own arguments
						|	[4.0]							// finally add the resulting two parameters and push the results onto the stack	2 + (6 / 3) = 4
						
						

// An simple example with arrays						
add 2.0 [3.0 4.0] // Code to be evaluated

// Token Stack 		|	Result stack		// One by one push tokens onto the stack
add					|
add 2.0				|
add 2.0 [3.0 4.0]	|
add 2.0				|	[3.0 4.0]
add					|	[2.0] [3.0 4.0]
					|	[2.0] [3.0 4.0] add // Push the add function onto the stack
					|	[5.0 6.0]			// Add by multichannel expansion 2 + 3 = 5, 2 + 4 = 6; [2.0] + [3.0 4.0] = [5.0 6.0]
					
// slightly complicated example with arrays
add [2.0 3.0] [5.0 1.0 7.0] // Code to be evaluated

// Token Stack 				|	Result stack			// One by one push tokens onto the stack
add							|
add [2.0 3.0]				|
add [2.0 3.0] [5.0 1.0 7.0]	|
add [2.0 3.0]				|	[5.0 1.0 7.0]
add							|	[2.0 3.0] [5.0 1.0 7.0]
							|	[2.0 3.0] [5.0 1.0 7.0] add // Push the add function onto the stack
							|	[7.0 4.0 9.0]				// execute the add function, multichannel expanse wraps indexing into the array

// [2.0 3.0] + [5.0 1.0 7.0] becomes [2.0 3.0 2.0] + [5.0 1.0 7.0] = [7.0 4.0 9.0]


// Another more complicated example with arrays
add [5.0 7.0] divide [4.0 12.0] [4.0] // code to be evaluated

// Token Stack							| Result Stack
add										|
add [5.0 7.0] 							|
add [5.0 7.0] divide 					|
add [5.0 7.0] divide [4.0 12.0] 		|
add [5.0 7.0] divide [4.0 12.0] [4.0]	|											// Reach the end of token stack and start pushing onto the results stack
add [5.0 7.0] divide [4.0 12.0] 		|	[4.0]
add [5.0 7.0] divide					|	[4.0] [4.0 12.0]
add [5.0 7.0]							|	[4.0] [4.0 12.0] divide
add 									|	[4.0] [4.0 12.0] divide [5.0 7.0]			
 										|	[4.0] [4.0 12.0] divide [5.0 7.0] add
 										|	[4.0] [4.0 12.0] divide [5.0 7.0]		// Pop the add function, which takes two parameters, which you pop and evaluate
										|	[1.0 3.0] [5.0 7.0]						// Execute the divide function [4.0] / [4.0 12.0] = [1.0 3.0]
										|	[6.0 10.0]								// Execute the add function [1.0 3.0] + [5.0 7.0] = [6.0 10.0]
										

// Variable declaration and assignment example
myVar 7.0 // Code to be evaluated

// Token Stack		| Result Stack
myVar				|
myVar 7.0			|
myVar				| [7.0]
					| [7.0] myVar			// myVar is evaluated as not being a function and instead is declared as the top of the stack
					| 						// myVar and parameters are popped
					
// Variable declaration and functions
myVar add // Code to be evaluted

// Token Stack		| Result Stack
myVar				|
myVar add			|
myVar				| add
					| add myVar			// myVar is evaluated as not being a function and instead is declared as the top of the stack, which is a function
					| 					// myVar and parameters are popped. When a parameter pops a function, it is declared as the function without evaluation
					
// ... later we can do this
myVar 1.0 3.0
// Which will end up with
4.0
// because myVar was declared as add

//////////////////////////////////////////////////
// Components that need to be defined and created
//////////////////////////////////////////////////

Tokenizer 			// using an array and iterating backwards to push on to the stack
The Stack 			// Where everything is pushed and popped from. The interface with the virtual machine
Virtual Machine		// Where all the memory is stored for variables

Any time a variable is evaluated it has a method called which is a return method. A float returns itself as a number, a function calls itself, return any of the 3 data type which are in turn called themselves, and arrays are collections of float which have their return method called in turn. 

The goal is to have an extremely easy to write language but that also has deep complexity in it's behavior, creating surprising results for the performer and the audience. Somewhat like dealing with feedback, where there is an organic quality to the behavior.


NO STRINGS.
NO SEMICOLONS!
No scoped variables, everything is global
Everything is mutable!
NO MATH OPERATORS!
NO INDEXING OPERATORS!
NO OPERATORS AT ALL!
No commas, periods, boolean operators, etc...

///////////////////////////////////////////
// All Commands are variable declarations!
///////////////////////////////////////////

Because floats, functions, and arrays are all objects and synonymous, every time you execute a command, it is a variable declaration. Functions which actually execute (or begin some process). Any redeclaration simply redefines the variable.

Variable declaration // myVar 1.0 3.1415 666 which ends up with a result like this: [1.0, 3.1415, 666]

// How to
Parameters are compiled inline, so you can do this: myFunction myOtherFunction myOtherFunctionParam1 myFunctionParam2
This is equivalent to myFunction(myOtherFunction(myOtherFunctionParam1), myFunctionParam2);

// Because of the prefix notation and the lack of object methods, here are some examples of common commands
index myArray myIndex // Array indexing
add myVar myVar2 // Math operators

Some Variables are immutable:
at, plus, Play back etc...
They can't be redeclared, they just return their values (as a float, function, or array)


//////////////////////////////
// Virtual Machine Structure
//////////////////////////////

Have a global namespace for variables
Every time you execute something it posts the return (maybe type instead?)
The global namespace is essentially an ever growing memory bank of every variable ever

///////////
// Demo
///////////


// Lich.js

This is a short work in progress demo.
Play with the language and let me know what you think! 

A brief intro:
Lich is a functional language implemented in javascript Because of this extra layer, it is pretty sludgey, though we do get some nice things in return.

In Lich we have 7 types. 

Floats
Lich has no ints; all numbers are floats. Just type a number and it's a float object. ex: 666 or 7.7709

Strings
Normal text string. Strings can be created with ' ' or " ".

Arrays
Holds any other types including other Arrays. Declared using [].

Signals
Continuous float containers similar to SC envelopes, although they are created with [time level] pairs and can have new points added at any time as well as indexed at any point in 'time'. You can use $ or Signal to create a new signal. More on this later.

Variables
Can be assigned to anything else except for Primitives. You have to assign a variable using the assign operator => otherwise you'll get an undefined error.

Functions Functions are first class citizens, as in SC and can be called directly or passed as arguments and assigned to variables. Functions are defined using
: someArg someOtherArg thisCanGoOnForever { do someArg }
More on this later.

Primitives
Primitives are functions written in Javascript. They can't be assigned to variables and they are always resolved on call. These include operators such as +, -, /, *, as well as some other important functions. You can't create a primitive, however they are called constantly.

The goal of the language is to keep the list short in the hopes that they can be used in any combination (although this isn't quite the case yet).

Here's the catch. Everything is written with prefix notation. What the means is there is no operator precedence and everything is executed from the left. This takes some getting used to with most of the common operators like math, but actually makes alot of sense from a functional perspective and It also allows us to forgo any parentheses. It was also much easier for me to make and given this is my first language I didn't want to make it harder than it already was.
 


//////////////////////////////////////////////////////////////////////
// Unit Tests For testing that the language still works after changes
//////////////////////////////////////////////////////////////////////

+ 1 1
- 1 1
* 2 1
/ 1 2
% 5 3
+ 1 [2 2]
+ [2 2]  [3 3 3]
- [0 1 2] [3 3 3 3]
=> two + 1 1
+ [two 3 3] [two two]
// Test Comments!
// + 1 [0 1 2]
+ 1 [0 1 2] // Code evaluated, but not the comment!
[[0 1 2] [1 2 3] [2 3 4]]
+ [1 2 3] [[1 2 3] [1 1 1]]
+ [1 2 3 4 5 '!'] [[[0 1 2] [1 2 3]] [[3 4 5] [6 7 8] [9 0 9]]]
=> myAdd : arg1 arg2 { + arg1 arg2 }
::myAdd 1 1
::myAdd ::myAdd 1 1 1
=> myFuncCall : arg2 operator arg3 { ::operator arg2 arg3 }
::myFuncCall [0.5 0.5] myAdd 2
=> addOne : arg1 { + arg1 1 }
::addOne 1
=> addOne2 : arg1 { + 1 arg1 }
::addOne2 1
=> onePlusOne : { + 1 1 }
::onePlusOne
+ ::onePlusOne ::onePlusOne
=> otherTwo { + 1 1 }
=> alsoTwo { + ::otherTwo 0 }
+ ::alsoTwo 3
== 1 1
== 1 0
== [2 2] [2 2]
== [2 2] [3 3]
!= 1 1
!= 1 0
!= [2 2] [2 2]
!= [2 2] [3 3]
if == 1 1 { print true } { print false }
if != 1 1 { print true } { print false }
=> myPrint : arg1 { print arg1 }
::myPrint true
=> myString "YO!"
print myString
=> myString2 'yo yo yo'
print myString2
// if statements can use if bool trueFunc falseFunc 
// OR if bool trueFunc else falseFunc syntax
if == 1 1 { print 'TRUE!' } else { print 'false.' }
if != 1 1 { print "TRUE!" } else { print "false." }
if > 1 1 { print 'true' } { print 'false' }
if >= 1 1 { print 'true' } { print 'false' }
if < 1 1 { print 'true' } else { print 'false' }
if >= 1 1 { print 'true' } else{ print 'false' }
=> ifInFunc : arg { if arg { print 'true' } { print 'false' } }
::ifInFunc 1
::ifInFunc 0
=> myArray ['Yo!' 2 { print 'This should not print!'}]
print myArray
=> redefine 1
redefine
=> redefine 2
redefine
=> i 0
do 5 { print ++ i }
=> anArray [90 91 92 93 94 95]
@ anArray 4
+ @ anArray 2 1
=> doomString "This is about doom god damnit!"
@ doomString 5
=> i 0
do 50 { print @ doomString ++ i }
=> mySignal Signal [[0 0.0001] [0.1 1] [1 0.0001]] 'linear'
=> i 0
do 20 { print @ mySignal / ++ i 20}
=> mySignal2 + mySignal 1
=> mySignal4 + mySignal mySignal2
@ mySignal4 1
=> mySignal3 Signal [[0.5 5] [0.8 2] [3 0.1] [5 0]] 'linear'
mySignal3
+ mySignal mySignal3 
=> i 0
do 20 { print @ mySignal3 / ++ i 4}
-> mySignal 3 0.6666
-> mySignal 0.25 7.7
-> mySignal 10 999
=> myString "Doom"
-> myString 0 'Hey'
-> myString 5 '!!!?!?!?!'
-> myString 999 '999'
=> myArray [0 1 2 3 4 5]
-> myArray 1 111
-> myArray 2 222
-> myArray 3 333
-> myArray 999 999

/*
String
Float
Function
Primitive (Can't test with primitives directly because they always resolve to something else)
Array
Variable
add, subtract, multiply, divide, modulus, equivalent, inequivalent, greater than, less than, greater than equal, less than equal*/

// DECLARE VARIABLES FOR TESTING

=> myTestFunc { + 1 1 }
=> someVar 'other string'

// STRINGS

+ 'Yo!' 'Yo2!' 
+ 'Yo!' 1
+ 'Yo!' ::myTestFunc
+ 'Yo!' + 1 1
+ 'Yo!' [1 2 3]
+ 'Yo!' someVar
+ 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

- 'Yo!' 'Yo!2' 
- 'Yo!' 1
- 'Yo!' ::myTestFunc
- 'Yo!' + 1 1
- 'Yo!' [1 2 3]
- 'Yo!' someVar
- 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

* 'Yo!' 'Yo2!' 
* 'Yo!' 1
* 'Yo!' ::myTestFunc
* 'Yo!' + 1 1
* 'Yo!' [1 2 3]
* 'Yo!' someVar
* 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ 'Yo!' 'Yo2!' 
/ 'Yo!' 1
/ 'Yo!' ::myTestFunc
/ 'Yo!' + 1 1
/ 'Yo!' [1 2 3]
/ 'Yo!' someVar
/ 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

% 'Yo!' 'Yo2!' 
% 'Yo!' 1
% 'Yo!' ::myTestFunc
% 'Yo!' + 1 1
% 'Yo!' [1 2 3]
% 'Yo!' someVar
% 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

== 'Yo!' 'Yo2!' 
== 'Yo!' 1
== 'Yo!' ::myTestFunc
== 'Yo!' + 1 1
== 'Yo!' [1 2 3]
== 'Yo!' someVar
== 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= 'Yo!' 'Yo2!' 
!= 'Yo!' 1
!= 'Yo!' ::myTestFunc
!= 'Yo!' + 1 1
!= 'Yo!' [1 2 3]
!= 'Yo!' someVar
!= 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

> 'Yo!' 'Yo2!' 
> 'Yo!' 1
> 'Yo!' ::myTestFunc
> 'Yo!' + 1 1
> 'Yo!' [1 2 3]
> 'Yo!' someVar
> 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

< 'Yo!' 'Yo2!' 
< 'Yo!' 1
< 'Yo!' ::myTestFunc
< 'Yo!' + 1 1
< 'Yo!' [1 2 3]
< 'Yo!' someVar
< 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= 'Yo!' 'Yo2!' 
>= 'Yo!' 1
>= 'Yo!' ::myTestFunc
>= 'Yo!' + 1 1
>= 'Yo!' [1 2 3]
>= 'Yo!' someVar
>= 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= 'Yo!' 'Yo2!' 
<= 'Yo!' 1
<= 'Yo!' ::myTestFunc
<= 'Yo!' + 1 1
<= 'Yo!' [1 2 3]
<= 'Yo!' someVar
<= 'Yo!' Signal [[0 0] [0.1 1] [1 0]] 'linear'

// FLOATS

+ 1 'Yo!' 
+ 1 1
+ 1 ::myTestFunc
+ 1 + 1 1
+ 1 [1 2 3]
+ 1 someVar
+ 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

- 1 'Yo!' 
- 1 1
- 1 ::myTestFunc
- 1 + 1 1
- 1 [1 2 3]
- 1 someVar
- 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

* 1 'Yo!' 
* 1 1
* 1 ::myTestFunc
* 1 + 1 1
* 1 [1 2 3]
* 1 someVar
* 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ 1 'Yo!' 
/ 1 1
/ 1 ::myTestFunc
/ 1 + 1 1
/ 1 [1 2 3]
/ 1 someVar
/ 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

% 1 'Yo!' 
% 1 1
% 1 ::myTestFunc
% 1 + 1 1
% 1 [1 2 3]
% 1 someVar
% 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

== 1 'Yo!' 
== 1 1
== 1 ::myTestFunc
== 1 + 1 1
== 1 [1 2 3]
== 1 someVar
== 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= 1 'Yo!' 
!= 1 1
!= 1 ::myTestFunc
!= 1 + 1 1
!= 1 [1 2 3]
!= 1 someVar
!= 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

> 1 'Yo!' 
> 1 1
> 1 ::myTestFunc
> 1 + 1 1
> 1 [1 2 3]
> 1 someVar
> 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

< 1 'Yo!' 
< 1 1
< 1 ::myTestFunc
< 1 + 1 1
< 1 [1 2 3]
< 1 someVar
< 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= 1 'Yo!' 
>= 1 1
>= 1 ::myTestFunc
>= 1 + 1 1
>= 1 [1 2 3]
>= 1 someVar
>= 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= 1 'Yo!' 
<= 1 1
<= 1 ::myTestFunc
<= 1 + 1 1
<= 1 [1 2 3]
<= 1 someVar
<= 1 Signal [[0 0] [0.1 1] [1 0]] 'linear'

// Function

+ ::myTestFunc 'Yo2!' 
+ ::myTestFunc 1
+ ::myTestFunc ::myTestFunc
+ ::myTestFunc + 1 1
+ ::myTestFunc [1 2 3]
+ ::myTestFunc someVar
+ ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

- ::myTestFunc 'Yo!2' 
- ::myTestFunc 1
- ::myTestFunc ::myTestFunc
- ::myTestFunc + 1 1
- ::myTestFunc [1 2 3]
- ::myTestFunc someVar
- ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

* ::myTestFunc 'Yo2!' 
* ::myTestFunc 1
* ::myTestFunc ::myTestFunc
* ::myTestFunc + 1 1
* ::myTestFunc [1 2 3]
* ::myTestFunc someVar
* ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ ::myTestFunc 'Yo2!' 
/ ::myTestFunc 1
/ ::myTestFunc ::myTestFunc
/ ::myTestFunc + 1 1
/ ::myTestFunc [1 2 3]
/ ::myTestFunc someVar
/ ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

% ::myTestFunc 'Yo2!' 
% ::myTestFunc 1
% ::myTestFunc ::myTestFunc
% ::myTestFunc + 1 1
% ::myTestFunc [1 2 3]
% ::myTestFunc someVar
% ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

== ::myTestFunc 'Yo2!' 
== ::myTestFunc 1
== ::myTestFunc ::myTestFunc
== ::myTestFunc + 1 1
== ::myTestFunc [1 2 3]
== ::myTestFunc someVar
== ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= ::myTestFunc 'Yo2!' 
!= ::myTestFunc 1
!= ::myTestFunc ::myTestFunc
!= ::myTestFunc + 1 1
!= ::myTestFunc [1 2 3]
!= ::myTestFunc someVar
!= ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

> ::myTestFunc 'Yo2!' 
> ::myTestFunc 1
> ::myTestFunc ::myTestFunc
> ::myTestFunc + 1 1
> ::myTestFunc [1 2 3]
> ::myTestFunc someVar
> ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

< ::myTestFunc 'Yo2!' 
< ::myTestFunc 1
< ::myTestFunc ::myTestFunc
< ::myTestFunc + 1 1
< ::myTestFunc [1 2 3]
< ::myTestFunc someVar
< ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= ::myTestFunc 'Yo2!' 
>= ::myTestFunc 1
>= ::myTestFunc ::myTestFunc
>= ::myTestFunc + 1 1
>= ::myTestFunc [1 2 3]
>= ::myTestFunc someVar
>= ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= ::myTestFunc 'Yo2!' 
<= ::myTestFunc 1
<= ::myTestFunc ::myTestFunc
<= ::myTestFunc + 1 1
<= ::myTestFunc [1 2 3]
<= ::myTestFunc someVar
<= ::myTestFunc Signal [[0 0] [0.1 1] [1 0]] 'linear'

// Arrays

+ [1 2 3] 'Yo2!' 
+ [1 2 3] 1
+ [1 2 3] ::myTestFunc
+ [1 2 3] + 1 1
+ [1 2 3] [1 2 3]
+ [1 2 3] someVar
+ [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

- [1 2 3] 'Yo!2' 
- [1 2 3] 1
- [1 2 3] ::myTestFunc
- [1 2 3] + 1 1
- [1 2 3] [1 2 3]
- [1 2 3] someVar
- [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

* [1 2 3] 'Yo2!' 
* [1 2 3] 1
* [1 2 3] ::myTestFunc
* [1 2 3] + 1 1
* [1 2 3] [1 2 3]
* [1 2 3] someVar
* [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ [1 2 3] 'Yo2!' 
/ [1 2 3] 1
/ [1 2 3] ::myTestFunc
/ [1 2 3] + 1 1
/ [1 2 3] [1 2 3]
/ [1 2 3] someVar
/ [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

% [1 2 3] 'Yo2!' 
% [1 2 3] 1
% [1 2 3] ::myTestFunc
% [1 2 3] + 1 1
% [1 2 3] [1 2 3]
% [1 2 3] someVar
% [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

== [1 2 3] 'Yo2!' 
== [1 2 3] 1
== [1 2 3] ::myTestFunc
== [1 2 3] + 1 1
== [1 2 3] [1 2 3]
== [1 2 3] someVar
== [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= [1 2 3] 'Yo2!' 
!= [1 2 3] 1
!= [1 2 3] ::myTestFunc
!= [1 2 3] + 1 1
!= [1 2 3] [1 2 3]
!= [1 2 3] someVar
!= [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

> [1 2 3] 'Yo2!' 
> [1 2 3] 1
> [1 2 3] ::myTestFunc
> [1 2 3] + 1 1
> [1 2 3] [1 2 3]
> [1 2 3] someVar
> [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

< [1 2 3] 'Yo2!' 
< [1 2 3] 1
< [1 2 3] ::myTestFunc
< [1 2 3] + 1 1
< [1 2 3] [1 2 3]
< [1 2 3] someVar
< [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= [1 2 3] 'Yo2!' 
>= [1 2 3] 1
>= [1 2 3] ::myTestFunc
>= [1 2 3] + 1 1
>= [1 2 3] [1 2 3]
>= [1 2 3] someVar
>= [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= [1 2 3] 'Yo2!' 
<= [1 2 3] 1
<= [1 2 3] ::myTestFunc
<= [1 2 3] + 1 1
<= [1 2 3] [1 2 3]
<= [1 2 3] someVar
<= [1 2 3] Signal [[0 0] [0.1 1] [1 0]] 'linear'

// Variable

+ someVar 'Yo2!' 
+ someVar 1
+ someVar ::myTestFunc
+ someVar + 1 1
+ someVar [1 2 3]
+ someVar someVar
+ someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

- someVar 'Yo!2' 
- someVar 1
- someVar ::myTestFunc
- someVar + 1 1
- someVar [1 2 3]
- someVar someVar
- someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

* someVar 'Yo2!' 
* someVar 1
* someVar ::myTestFunc
* someVar + 1 1
* someVar [1 2 3]
* someVar someVar
* someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ someVar 'Yo2!' 
/ someVar 1
/ someVar ::myTestFunc
/ someVar + 1 1
/ someVar [1 2 3]
/ someVar someVar
/ someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

% someVar 'Yo2!' 
% someVar 1
% someVar ::myTestFunc
% someVar + 1 1
% someVar [1 2 3]
% someVar someVar
% someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

== someVar 'Yo2!' 
== someVar 1
== someVar ::myTestFunc
== someVar + 1 1
== someVar [1 2 3]
== someVar someVar
== someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= someVar 'Yo2!' 
!= someVar 1
!= someVar ::myTestFunc
!= someVar + 1 1
!= someVar [1 2 3]
!= someVar someVar
!= someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

> someVar 'Yo2!' 
> someVar 1
> someVar ::myTestFunc
> someVar + 1 1
> someVar [1 2 3]
> someVar someVar
> someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

< someVar 'Yo2!' 
< someVar 1
< someVar ::myTestFunc
< someVar + 1 1
< someVar [1 2 3]
< someVar someVar
< someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= someVar 'Yo2!' 
>= someVar 1
>= someVar ::myTestFunc
>= someVar + 1 1
>= someVar [1 2 3]
>= someVar someVar
>= someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= someVar 'Yo2!' 
<= someVar 1
<= someVar ::myTestFunc
<= someVar + 1 1
<= someVar [1 2 3]
<= someVar someVar
<= someVar Signal [[0 0] [0.1 1] [1 0]] 'linear'

// Signals

+ Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
+ Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

- Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo!2' 
- Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
- Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
- Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
- Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
- Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
- Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

* Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
* Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
* Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
* Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
* Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
* Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
* Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

/ Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
/ Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

% Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
% Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
% Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
% Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
% Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
% Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
% Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

== Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
== Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
== Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
== Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
== Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
== Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
== Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

!= Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
!= Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

> Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
> Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
> Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
> Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
> Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
> Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
> Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

< Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
< Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
< Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
< Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
< Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
< Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
< Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

>= Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
>= Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'

<= Signal [[0 0] [0.1 1] [1 0]] 'linear' 'Yo2!' 
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' 1
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' ::myTestFunc
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' + 1 1
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' [1 2 3]
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' someVar
<= Signal [[0 0] [0.1 1] [1 0]] 'linear' Signal [[0 0] [0.1 1] [1 0]] 'linear'