/~
	Lich.js Lexer/Parser generator written in JS/CC

	Chad McKinney, chad@chadmckinneyaudio.com
	www.chadmckinneyaudio.com

	----------------------------
	--| Language Rewrite Notes
	----------------------------

	--| Inspired by Haskell, Tidal, Ixlang, Gibber, SuperCollider, Fluxus, and many more.

	--| Comments
	
	-- This is a comment

	{-
		This is a range specified comment
	-}

	--| function composition
	myFunc arg1 arg2 = expression
		where expresion = expression2

	--| function composition/chaning. Similar to haskells func1 . func2 $ func3, but no $
	func1 = func2 . func3 . func4
	res x y = (*2) . tail . reverse . map (+666) (1..99)

	--| function application
	myFunc 1 2
	(myFunc 2 3)

	--| Function currying
	(+2)
	map (myFunc) (1..99)

	--| Lambdas
	(\arg1 argN -> expression)

	--| Lists look like Haskell tuples. We dont use [] so as to differentiate sequences (defined below) from lists.
	4,5 -- Creates the list (4,5)
	4..7 -- Creates the list (4,5,6,7)
	4,6..12 -- Creates the list (4,6,8,10,12)
	(1,2,3,4)
	(1..7)
	(1,3..9)
	1:2:3:() -- Cons, (1,2,3)
	2:3:(5..99) -- Cons, (2,3,5,6,7,8 *keeps going to 99*)
	(1..6) ++ (7..8) -- Concat, (1,2,3,4,5,6,7,8)

	// List functions
	map (+2) (1..7)
	filter (odd) (0..10)
	filter (>3) (-1,1..9)
	zip (1,2,5,7,99) (0..99)

	--| SynthDefs, streaming operators
	phatBass freq res = Pulse freq (LFSin 0.5) >> RLPF (freq * 2) res >> delay 0.01 >> PercEnv -- LFSin and other LF UGens are automatically 0.0 - 1.0 instead of -1.0 to 1.0
	silkySin freq = SinOsc (freq, freq * 2) >> SlowEnv >> delay (Quarter * 2) 0.3 -- Quarter is a global variable for the length of a quarter note 

	--| Beat Sequencing, the letters are beat synths or samples. A combination of Tidal and Ixi lang sequencing
	--| Each character is parsed individually as either a variable name or number 0 - 9.
	--| The => operator signifies the usage of beat syntax. Beat syntax uses a synth with no arguments, spaces are rests, nested square brackets are nested rhythms
	beat1 => [b s ]
	beat2 => [[ h]]
	beat3 => every 3 ((skip 1) . reverse) [[[pon] o n] [   n][ n  ]]

	--| Melody Sequencing, similar to Ixi lang
	--| The ~> operator signifies melody syntax. First provide a synth followed by value streams. Spaces = rest, underscore = sustain. Can adjust values with operation at end
	melody1 ~> phatBass [123 4 [997] 1 2 ]-12 [123 4 59]/10
	melody2 ~> silkySin (every 4 (half . reverse) [9______8_____7______4____3___[123]]+12)

	--| MeshDef Function, MeshDefs are like SynthDefs. They define an object and its transformations
	cubic x size color = Cube x 0 200 >> Color color >> Scale size >> Rot (random3 * 0.1) >> Splay (random3 * 0.25) 

	--| Mesh Sequencing, in beats just like the melody sequencing
	cubic1 ~> cubic [1238456]-10*20 [1232] [14579_7_9]

	--| Shader Sequencing, similar to beat sequencing
	shaders1 => [g ri p [ z]] -- g,r,i,p, and z are shader functions

	--| Scales
	Scale = C#Minor -- set the current scale
	Scale = DMinor
	Scale = Javanese
~/

[*
// Initial header code

*]

/~
	--- Token Definitions ---
~/

/~ Whitespace and Comments ~/
!	'\r|\n| |\t|\-\-.*|\{\-.*\-\}';

/~ Non-associative tokens and keywords ~/
	'\('			
	'\)'
	'\['
	'\]'
	'='
	','
	'\.'
	'\.\.'
	'>>'
	'=>'
	'~>'
	'\->'
	':'
	'\220' /~ this is the \ character as in (\x -> y) for lambdas ~/
	'\_'
	'\+\+'
	'where'
	'if'
	'then'
	'else'
	'true'
	'false'
	'[A-Za-z_][A-Za-z0-9_]*' IDENTIFIER
	'\"([^\"]|\"\")*\"' STRING [* %match = %match.substr( 1, %match.length - 2 ); %match = %match.replace( /''/g, "\'" ); *]
	'[0-9]+'		INT [* %match = parseInt( %match );	*]
	'[0-9]+\.[0-9]*|[0-9]*\.[0-9]+' FLOAT [* %match = parseFloat( %match ); *]
	;


/~ Expression operators ~/
>	'=='			
	'/='
	'<='
	'>='
	'>'
	'<'
	;			

/~ Left-associative tokens, lowest precedence ~/
<	'\+'			
	'\-'
	'%';
	
/~ Left-associative tokens, middle precedence ~/
<	'\*'			
	'/';

/~ Left-associative tokens, highest precedence ~/
<	'^'
	'\*\*';

##

/~
	--- And here's the grammar specification ---
~/

Program:	Program Stmt										[* LichVM.compileProgram(%2); *]
			|
			;

Stmt_List:	Stmt_List Stmt 										[* %% = createNode(NODE_OP, OP_VOID, %1, %2); *]
			|
			;

Stmt: 		IDENTIFIER ArgList '=' Expression 					[* %% = createNode(NODE_OP, OP_FUNCASSIGN, %1, %2, %4); *]
			| Expression 										[* %% = %1; *]
			;

ArgList: 	IDENTIFIER ArgList									[* %% = createNode(NODE_ARGLIST, %1, %2); *]
			|
			;

ExpressionList: 	Expression ExpressionList					[* %% = createNode(NODE_EXPRLIST, OP_VOID, %1, %2); *]
					|
					;

/~
lexeme: 	varid_e				[* %% = %2 *]
			| condid_e			[* %% = %2 *]
			| varsym_e			[* %% = %2 *]
			| qvarid 			[* %% = %2 *]
			| qconid 			[* %% = %2 *]
			| qvarsym 			[* %% = %2 *]
			| qconsym 			[* %% = %2 *]
			| literal 			[* %% = %2 *]
			| special 			[* %% = %2 *]
			| reservedop 		[* %% = %2 *]
			| reservedid 		[* %% = %2 *]
			;

varid_e: 	~/


/~
	Don't confuse with the tokens:
	Here, we use the unescaped values because these are not
	interpretered as regular expressions at this position!
~/
Expression: 	'if' Expression 'then' Expression 'else' Expression 	[* %% = createNode(NODE_OP, OP_IF, %2, %4, %6); *]
				| Expression '==' Expression 							[* %% = createNode(NODE_OP, OP_COMPEQ, %1, %3); *]
				| Expression '/=' Expression 							[* %% = createNode(NODE_OP, OP_COMPNEQ, %1, %3); *]
				| Expression '>' Expression 							[* %% = createNode(NODE_OP, OP_COMPGT, %1, %3); *]
				| Expression '<' Expression 							[* %% = createNode(NODE_OP, OP_COMPLT, %1, %3); *]
				| Expression '>=' Expression 							[* %% = createNode(NODE_OP, OP_COMPGTEQ, %1, %3); *]
				| Expression '<=' Expression 							[* %% = createNode(NODE_OP, OP_COMPLTEQ, %1, %3); *]
				| Expression'+' Expression								[* %% = createNode(NODE_OP, OP_PLUS, %1, %3); *]
				| Expression '-' Expression								[* %% = createNode(NODE_OP, OP_MINUS, %1, %3); *]
				| Expression '*' Expression								[* %% = createNode(NODE_OP, OP_MUL, %1, %3); *]
				| Expression '/' Expression								[* %% = createNode(NODE_OP, OP_DIVIDE, %1, %3); *]
				| Expression '^' Expression 							[* %% = createNode(NODE_OP, OP_POW, %1, %3); *]
				| '-' Expression			&'*'						[* %% = createNode(NODE_OP, OP_NEG, %2); *]
				| Expression '%' Expression 							[* %% = createNode(NODE_OP, OP_MOD, %1, %3); *]
				| '(' Expression ')'									[* %% = %2; *]
				| INT 													[* %% = createNode(NODE_CONST, %1); *]
				| FLOAT 												[* %% = createNode(NODE_CONST, %1); *]
				| STRING 												[* %% = createNode(NODE_CONST, %1); *]
				| IDENTIFIER ExpressionList 							[* %% = createNode(NODE_OP, OP_FUNCINVOKE, %1, %2); *]
				| 'true'												[* %% = createNode(NODE_CONST, true); *]
				| 'false'												[* %% = createNode(NODE_CONST, false); *]
				;

/~
	This is the parser entry point; Because this entry point could be
	very individual, the compiler programmer has to decide which way
	he want to read the source, parse it and report the errors, if
	there are any.
~/
[*

// Tail Code

var error_offsets = new Array();
var error_lookaheads = new Array();
var error_count = 0;

/* Switching one of these variables on will enable debug facilities
	of the various parser drivers */
##PREFIX##_dbg_withtrace = false;

function parseCurrentLine()
{	
	// Tokenize current line
	var tokens, objects, line,str;
	line = currentLine("terminal");
	str = line.line;
	// document.getElementById(loginName).value = str;

	try
	{
		if( ( error_count = __##PREFIX##parse( str,
			error_offsets, error_lookaheads ) ) > 0 )
		{
			var errstr = new String();
			for( var i = 0; i < error_count; i++ )
				errstr += "Parse error near \"" 
						+ str.substr( error_offsets[i] ) +
							"\", expecting \"" +
								error_lookaheads[i].join() +
									"\"\n" ;
			post(errstr);
			// alert( errstr );
		}
	}
	
	catch(e)
	{
		post(e);
	}

	// I no longer like this behavior.
	// setCaretPosition(line.end + 1); // Move the cursor to the next line
}

*]